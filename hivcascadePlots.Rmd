---
title: "Australian HIV Cascade"
author: "Richard T. Gray"
date: Latest version - `r format(Sys.Date(), format="%B %d %Y")`
output:
  word_document:
    pandoc_args: --output="docs/HIVcascades.docx"
    reference_docx: docs/mystyles.docx
csl: docs/plos.csl
bibliography: docs/HIVcascades.bib
---

This document shows various plots related to the HIV care and treatment 
cascade for Australia. These results illustrate estimates for the key 
stages and populations used in the Kirby Annual Surveillance Reports.

```{r setup, echo = FALSE, messages = FALSE, include=FALSE}
# Clear workspace
rm(list=ls()) 
options(scipen=999)  # To get rid of scientific notation

# Setup directories
basePath <- file.path(path.expand("~"), "Research", 
                      "!Evaluation_Modelling", "project_care_cascades")
Rcode <- file.path(basePath, "code") 
docFolder <- file.path(basePath,"docs")
figFolder <- file.path(basePath,"output", "figures", "hiv_cascade")
resultsFolder <- file.path(basePath,"output")

# Set working directory
setwd(basePath)

# Load standard libraries and options ----------------------------------
source(file.path(Rcode, "LoadLibrary.R"), echo=TRUE)
source(file.path(Rcode, "DataLibraries.R"), echo=TRUE)
source(file.path(Rcode, "PlotOptions.R"), echo=TRUE)

# Function to format data and range into thousands
source(file.path(basePath, "code", "FormatData.R"), echo=TRUE)

# Current time for appending to outputs
currTime <- format(Sys.time(), "%y-%m-%d") # to append to files

# Script parameters
resultsYear <- 2014  # year of cascade we will plot
minYear <- 10        # how long ago do we plot things
startYear <- resultsYear - minYear + 1 
savePlots <- TRUE    # save plots as separate files
pubPlots <- TRUE     # create additional plots for publications
if (pubPlots) {
  savePlots <- TRUE
}
saveFormat <- ".png" # file extension for saved plots 

# Include linked and reatined in care?
excludeCare <- FALSE
if (excludeCare) {
  asrcols <- asrcols[c(1, 2, 4, 5)]
}

```

```{r loadresults, echo = FALSE, messages = FALSE, include=FALSE}
# Load the previously saved hiv notifications data frame
load(file.path(resultsFolder, paste("HIVset-",
                    toString(resultsYear), ".rda", sep = "")))

# Load the previously saved hivresults data frame
load(file.path(resultsFolder, paste("HIVresults-",
                    toString(resultsYear), ".rda", sep = "")))

# Load hiv cascade dataframe
inputFile <- file.path(resultsFolder,paste("HIVcascadeEstimates-", 
  toString(resultsYear), ".rda", sep = ""))
load(inputFile)

# Exclude linked to care if it exists
hivCascade <- filter(hivCascade, !(stage == "linked"))

# Removed retained from hivCascade if specified but keep for final 
# year bar chart
if (excludeCare) {
  hivCascade <- filter(hivCascade, stage != "retained")
}
```

# National estimates

```{r allpops, echo = FALSE, messages = FALSE, include=FALSE}
# Create a series of plots related to the overall cascade

# Plot specs
stages <- c("infected", "pldhiv",  
            "retained", "numART", "suppressed")
stageNames <- c("Living with HIV", "Diagnosed", 
                  "Retained in care", "Receiving ART", "Suppressed virus")
stageNamesNeat <- c("Living \n with HIV", "Diagnosed", 
                      "Retained \n in care", 
                      "Receiving \n ART", "Suppressed \n virus")

# Sort out labels and colors depending on script options - code a bit messy
if (excludeCare) {
  # Exclude corresponding stages
  include <- c(1, 2, 5, 6)
  stages <- stages[include]
  stageNames <- stageNames[include]
  stageNamesNeat <- stageNamesNeat[include]
}

# Create bar chart of current year's cascade and over time ----------------

# Sort out the data we want
resultsAll <- filter(hivCascade, 
                     population == "all",
                     year >= startYear)

resultsAllYear <- filter(resultsAll, year == resultsYear)

# Plot a bar chart for the results year ------------------------------------
plotBarAll <- ggplot(data = resultsAllYear, aes(x = stage, y = value)) + 
  geom_bar(stat = "identity", color = asrcols, 
           fill = asrcols, width = 0.8) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.1, 
                color = "black", size = 1.1) +
  scale_x_discrete(limits = stages, labels = stageNamesNeat) + 
  ylab("Number of people") + xlab("") +  
  plotOpts

if (pubPlots) {
  # Create an additional stacked bar chart for publications removing 
  # retained stage
  
  plotLabels <- c("Undiagnosed", 
                  "Diagnosed untreated", 
                  "On ART:  VL > 400 last test", 
                  "On ART: VL < 400 last test")
  
  plotCols <- asrcols[c(1, 2, 4, 5)]
  xValues <- seq(startYear, resultsYear, by = 3)
  
  # Set up data for plotting
  stackResults <- resultsAll %>%
    filter(stage != "retained") %>%
    select(year, stage, value) %>%
    spread(stage, value) %>%
    mutate(undiagnosed = infected - pldhiv,
           diagosed = pldhiv - numART,
           unsuppressed = numART - suppressed) %>%
    select(year, undiagnosed, diagosed, unsuppressed, suppressed) %>%
    gather("stage", "value", 2:5)
  
  # Create plots
  stackPlotBase <- ggplot(data = stackResults, aes(x = year, y = value, 
    fill = stage)) + xlab("Year") +
    scale_fill_manual(values = plotCols, name = "", labels = plotLabels, 
      guide = guide_legend(reverse=TRUE, nrow = 2)) +  
    scale_x_continuous(breaks = xValues) + plotOpts + 
    theme(legend.text = element_text(size = 8))
  
  stackPlotNum <- stackPlotBase + geom_bar(stat="identity") + 
    ylab("Number of PLHIV") 
  stackPlotProp <- stackPlotBase + geom_bar(stat="identity", 
    position= "fill") + ylab("Proportion of PLHIV")
  
}

# Save if required ---------------------------------------------------------
if (savePlots) {
  graphics.off()
  
  if (excludeCare) {
    width = 10
  } else {
    width = 12
  } 
  
  ggsave(file.path(figFolder, paste("HIVcascade-all-", 
    toString(resultsYear), saveFormat, sep = "")), 
    plot = plotBarAll, width =  12, height = 10, units = "cm")

} 

if (pubPlots) {  
  ggsave(file.path(figFolder, paste("HIVcascade-Stacked-", 
    toString(resultsYear), saveFormat, sep = "")),
    plot = stackPlotNum, width = 10, height = 10, units = "cm")
  
  ggsave(file.path(figFolder, paste("HIVcascade-Proportion-",
    toString(resultsYear), saveFormat, sep = "")),
    plot = stackPlotProp, width = 10, height = 10, units = "cm")

}

# Plot time varying values for each stage ----------------------------------

# Set up levels for faceting appropriately - have to do this manually
resultsAll$stage <- factor(resultsAll$stage)
if (excludeCare) {
  resultsAll <- within(resultsAll, 
    stage <- factor(stage, levels(stage)[c(1, 3, 2, 4)]))
} else {
  resultsAll <- within(resultsAll, 
    stage <- factor(stage, levels(stage)[c(1, 4, 2, 3, 5, 6)]))
}

# Do a faceted plot for the document 
plotStagesAll <- ggplot(data = resultsAll, aes(x = year, y = value)) + 
  geom_ribbon(aes(ymin = lower, ymax = upper), 
              fill = asrcols[2], alpha = 0.4) +
  geom_line(color = asrcols[2]) + facet_wrap(~ stage, scales = "free")  +
  scale_x_continuous(breaks = seq((resultsYear - minYear + 1), 
                                  resultsYear, by = 3)) +
  expand_limits(y = 0) +
  ylab("Number of people") + xlab("Year") +  
  plotOpts

if (savePlots) {
 ggsave(file.path(figFolder, paste("HIVcascade-Stages-", 
    toString(resultsYear), saveFormat, sep = "")),
    plot = plotStagesAll, width = 15, height = 12, units = "cm")
  
  # ggsave(file.path(figFolder, paste("HIVcascade-Proportion-", 
  #   toString(resultsYear), saveFormat, sep = "")),
  #   plot = stackPlotProp, width = 10, height = 10, units = "cm")
}

# Do individual plots for publications
if (pubPlots) {
  # Only do certain stages
  plotStages <- c("infected", "pldhiv", "numART", "suppressed")
  
  # Set base plotting data
  plotData <- filter(resultsAll, stage %in% plotStages)
  
  yLabels <- c("infected" = "Number of PLHIV",
               "pldhiv" = "Number diagnosed",
               "numART" = "Number on ART",
               "suppressed" = "Number with VL < 400")
  
  # Loop across stages and save plots 
  for (ii in plotStages) {
    #Select data we want
    tempData <- filter(plotData, stage == ii)
    
    # Plot the stage over time
    plotCurrent <- ggplot(data = tempData, aes(x = year, y = value)) + 
      geom_ribbon(aes(ymin = lower, ymax = upper), 
                  fill = asrcols[2], alpha = 0.4) +
      geom_line(color = asrcols[2]) + 
      scale_x_continuous(breaks = seq(startYear,                        
                                      resultsYear, by = 3)) +
      expand_limits(y = 0) +
      ylab(yLabels[ii]) + xlab("Year") +  
      plotOpts
    
    # Save the current plot
    ggsave(file.path(figFolder, paste("HIVcascade-", ii, "_", 
      toString(startYear), "-", toString(resultsYear), 
      saveFormat, sep = "")),
      plot = plotCurrent, width = 7.5, height = 6, units = "cm") 
  }
}

# Additional time trend plots for publications -----------------------------
if (pubPlots) {
  
  # Plot cummulative unique cases
  casesPlot <- ggplot(data = filter(hivResults, yeardiagnosis >= startYear), 
         aes(x = yeardiagnosis, y = uniquecases)) +
    geom_line(color = asrcols[2])  +
    scale_x_continuous(breaks = seq(startYear, resultsYear, by = 3)) +
    expand_limits(y = 0) +
    ylab("Number of unique cases") + xlab("Year") +  
    plotOpts
  
  # Plot death related data - this is a bit trickier than I thought.
  # Need to multiply deathrates by PLDHIV and divided by 
  # (1 - % undiagnosed). Can't just multiply by this number due to small 
  # numbers at the start of the epidemic. 
  #
  # Alternatively could just plot deaths in PLDHIV which is easy (what I 
  # decided to do below)
  
  # Extract PLDHIV for 
  pldhiv <- hivCascade %>%
    filter(stage == "pldhiv", population == "all") %>%
    select(-stage, -population) 
  
  # Generate the death data we want calculating the cumulative number of 
  # deaths after 2003 
  
  deathData <- hivResults %>%
    rename(year = yeardiagnosis) %>%  
    select(year, deathrate, drlower, drupper) %>%
    inner_join(pldhiv, ., by = "year") %>%          # add pldhiv data frame
    mutate(estdeaths = cumsum(value * deathrate),  # do the calculations
           estdeaths_min = cumsum(lower * drlower),
           estdeaths_max = cumsum(upper * drupper)) %>%
    filter(year >= startYear, year <= resultsYear) %>%
    select(-value, -lower, -upper)
  
  # Now generate our plots
  plotDeaths <- ggplot(data = deathData, aes(x = year, y = estdeaths)) +
    geom_ribbon(aes(ymin = estdeaths_min, ymax = estdeaths_max), 
              fill = asrcols[2], alpha = 0.4) + 
    geom_line(color = asrcols[2])  +
    scale_x_continuous(breaks = seq((resultsYear - minYear + 1), 
                                    resultsYear, by = 3)) +
    expand_limits(y = 0) +
    ylab("Number of deaths") + xlab("Year") +  
    plotOpts
  
  plotDeathRate <- ggplot(data = deathData, 
                          aes(x = year, y = 100 * deathrate)) +
    geom_ribbon(aes(ymin = 100 * drlower, ymax = 100 * drupper), 
              fill = asrcols[2], alpha = 0.4) + 
    geom_line(color = asrcols[2])  +
    scale_x_continuous(breaks = seq((resultsYear - minYear + 1), 
                                    resultsYear, by = 3)) +
    ylim(c(0, 2)) +
    ylab("Mortality rate (%)") + xlab("Year") +  
    plotOpts
  
  # Save plots
  ggsave(file.path(figFolder, paste("HIVcases_", 
      toString(startYear), "-", toString(resultsYear), 
      saveFormat, sep = "")),
      plot = casesPlot, width = 7.5, height = 6, units = "cm")
  
  ggsave(file.path(figFolder, paste("HIVdeaths_", 
      toString(startYear), "-", toString(resultsYear), 
      saveFormat, sep = "")),
      plot = plotDeaths, width = 7.5, height = 6, units = "cm") 
  
  ggsave(file.path(figFolder, paste("HIVdeath_rate_", 
      toString(startYear), "-", toString(resultsYear), 
      saveFormat, sep = "")),
      plot = plotDeathRate, width = 7.5, height = 6, units = "cm")
  
  # Treatment coverage plot -----------------------------------------------
  
  # Do our calculations and sort out data we want to plot
  treatData <- hivCascade %>%
    filter(stage == "numART", population == "all") %>%
    rename(artvalue = value, artlower = lower, artupper = upper) %>%
    select(-population, -stage) %>%
    left_join(pldhiv, ., by = "year") %>%
    filter(year >= startYear, year <= resultsYear) %>%
    mutate(artcov = artvalue / value,
           artcov_min = artlower / upper, 
           artcov_max = artupper / lower) %>%
    select(year, artcov, artcov_min, artcov_max)
    
  # plot art coverage
  coveragePlot <- ggplot(data = treatData, aes(x = year, y = 100*artcov)) +
    geom_ribbon(aes(ymin = 100*artcov_min, ymax = 100*artcov_max), 
              fill = asrcols[2], alpha = 0.4) + 
    geom_line(color = asrcols[2])  +
    scale_x_continuous(breaks = seq((resultsYear - minYear + 1), 
                                    resultsYear, by = 3)) +
    ylim(c(0, 100)) +
    ylab("ART coverage (%)") + xlab("Year") +  
    plotOpts
  
  # Save plots
  ggsave(file.path(figFolder, paste("ARTcoverage_", 
      toString(startYear), "-", toString(resultsYear), 
      saveFormat, sep = "")),
      plot = coveragePlot, width = 7.5, height = 6, units = "cm")
}
```

```{r linkageplots, echo = FALSE, messages = FALSE, include=FALSE}
# Create  a series of plot related to linkag to care


```


```{r statecascade, echo = FALSE, messages = FALSE, include=FALSE}
### Create separate figures of each state cascade

states <- c("nsw", "vic", "qld", "nt", "wa", "sa", "tas", "act")


for (ii in seq(along = states)){
  resultsStatesYear <- filter(hivCascade, population == states[ii] & year == resultsYear)
  
  
  # Plot specs
  if (excludeCare) {
    stages <- c("infected", "pldhiv", "numART", "suppressed")
    stageNames <- c("Living with HIV", "Diagnosed", "Receiving ART", "Suppressed virus")
    stageNamesNeat <- c("Living \n with HIV", "Diagnosed", "Receiving \n ART", 
                        "Suppressed \n virus")
    
    if (states[ii] == "nsw") {
      # Add ipharmacies data
      nswCascade <- resultsStatesYear
      
      nswCascade$data <- "pbs"

      newFrame <- nswCascade
      newFrame[1,4:6] <- c(0, NA, NA)
      newFrame[2,4:6] <- c(0, NA, NA)
      newFrame[3,4:6] <- c(9130, NA, NA)
      newFrame[4,4:6] <- c(8400, 8130, 8450)
      newFrame$data <- "iPharmacies"
      
      nswCascade <- rbind(nswCascade, newFrame)
      
    }
    
    } else {
      stages <- c("infected", "pldhiv", "linked", "retained", "numART", "suppressed")
      stageNames <- c("Living with HIV", "Diagnosed", "Linked to care", 
                      "Retained in care", "Receiving ART", "Suppressed virus")
      stageNamesNeat <- c("Living \n with HIV", "Diagnosed", "Linked \n to care", 
                          "Retained \n in care", "Receiving \n ART", "Suppressed \n virus")
    }
  
  ### Plot the bar chart  
  if (states[ii] == "nsw" & excludeCare) {
    plotbarState <- ggplot(data = nswCascade, aes(x = stage, y = value, fill = data)) + 
      geom_bar(stat = "identity", width = 0.8, position = "dodge") +
      geom_errorbar(aes(ymin = lower, ymax = upper), 
                position = position_dodge(width = 0.8),
                width = 0.2, color = "black", size = 1.2) +
      scale_fill_brewer(palette = "Paired", name = "", labels = c("iPharmacies", "PBS")) +
      scale_x_discrete(limits = stages, labels = stageNamesNeat) + 
      ylab("Number of people") + xlab("") +  
      plotopts  
  } else {
    plotbarState <- ggplot(data = resultsStatesYear, aes(x = stage, y = value)) + 
      geom_bar(stat = "identity", color = maincols[2], fill = maincols[2], width = 0.6) +
      geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.1, color = "black", size = 1.2) +
      scale_x_discrete(limits = stages, labels = stageNamesNeat) + 
      ylab("Number of people") + xlab("") +  
      plotopts
  }
  # Save if required
  if (saveplots) {
    png(file.path(figFolder, paste("HIVcascade-", states[ii] ,"-", 
                                   toString(resultsYear), ".png",sep ="")), 
        width = 5, height = 5, units = "in", res = 300)
    print(plotbarState)
    dev.off()
    }
  }
```

**Figure 1** -- The HIV care and treatment cascade for Australia in `r resultsYear`.
```{r insertplot1, echo = FALSE, messages = FALSE, warning = FALSE, results = "hide", fig.width= 5.5, fig.height=3}
print(plotbarAll)
```

<!--- **Figure 2** -- The HIV care and treatment cascade stages `r resultsYear - minYear`-`r resultsYear`. --->
```{r insertplot2, echo = FALSE, messages = FALSE, warning = FALSE, results = "hide", fig.width= 5.5, fig.height=3.5}
# print(plotstagesAll)
```

```{r createtable1, echo = FALSE, messages = FALSE, include = FALSE}
# Create and insert table 
tableAll <- select(resultsAllYear,-year, -population)
# tableAll[,2:4] <- lapply(tableAll[,2:4],round)

finalTable <- select(tableAll, stage)
finalTable$estimate <- NA

# Convert lower and upper into a range string
if (excludeCare) {
  skip <- NULL #c(3)
} else {
  skip <- c(4,5)
}

for (ii in 1:nrow(tableAll)){
  if (ii %in% skip) {
    finalTable$estimate[ii] <- FormatData(tableAll$value[ii], places = -1)
  } else {
    finalTable$estimate[ii] <- FormatData(tableAll$value[ii], 
                                           tableAll$lower[ii], 
                                           tableAll$upper[ii], places = -1)
  }
}

# Reorder rows
if (excludeCare) { 
  finalTable[1:4,] <- finalTable[c(2, 1, 3, 4),]
} else {
  finalTable[1:6,] <- finalTable[c(2, 1, 3, 5, 4, 6),]
}

# Remove NA from final range
# finalTable[finalTable$stage == "numART",]$stimate <- "-"

# Rename first column
finalTable$stage <- stageNames

# Rename columns
finalTable <- rename(finalTable, "Cascade stage" = stage, 
                     "Estimate (range)" = estimate)

```

**Table 1** -- Estimates and range for each stage of the HIV care and treatment cascade for Australia in `r resultsYear`.
```{r inserttable1, echo = FALSE, messages = FALSE, warning = FALSE, results = "asis"}
kable(finalTable, align = c("l", "c", "c"))
```

# State estimates

```{r allstates, echo = FALSE, messages = FALSE, include=FALSE}
# Create bar charts of current year's cascade for each state
states <- c("nsw", "vic", "qld", "nt", "wa", "sa", "tas", "act")

# resultsState <- filter(hivCascade, population %in% states & year >= (resultsYear - minYear))
resultsStatesYear <- filter(hivCascade, population %in% states & year == resultsYear)

resultsStatesYear$stage <- factor(resultsStatesYear$stage)
if (excludeCare) {
  levels(resultsStatesYear$stage) <- c("Living with HIV", "Receiving ART", 
                                "Diagnosed", "Suppressed virus")
  resultsStatesYear <- within(resultsStatesYear, stage <- factor(stage, levels(stage)[c(1, 3, 2, 4)]))  
} else {
 levels(resultsStatesYear$stage) <- c("Living with HIV", "Linked to care", 
                              "Receiving ART", "Diagnosed", 
                              "Retained in care", "Suppressed virus")
  resultsStatesYear <- within(resultsStatesYear, stage <- 
                                factor(stage, levels(stage)[c(1, 4, 2, 5, 3, 6)])) 
  
}

# Set up state factor levels
resultsStatesYear$population <- factor(resultsStatesYear$population)
levels(resultsStatesYear$population) <- c("ACT", "NSW", "Northern Territory",
                                          "Queensland", "South Australia", "Tasmania",
                                          "Victoria", "Western Australia")

resultsStatesYear <- within(resultsStatesYear, 
    population <- factor(population, levels(population)[c(2, 7, 4, 8, 5, 1, 6, 3)]))


### Plot the bar charts
plotbarAllStates <- ggplot(data = resultsStatesYear, aes(x = stage, y = value)) + 
  geom_bar(stat = "identity", color = maincols[2], fill = maincols[2], width = 0.6) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.1, color = "black", size = 1.2) +
  facet_wrap(~ population, scales = "free") + 
  scale_x_discrete(labels = "") + 
  ylab("Number of people") + xlab("") +  
  plotopts

# Save if required
if (saveplots) {
  png(file.path(figFolder, paste("HIVcascade-States-", toString(resultsYear), ".png",sep ="")), 
        width = 8, height = 6, units = "in", res = 300)
  print(plotbarAllStates)
  dev.off()
  
}

```

**Figure 3** -- The HIV care and treatment cascade for each State and Territory in `r resultsYear`.
From left to right the bars are for each stage of the care and treatment cascade: living with HIV, diagnosed, recieving ART, and suppressed virus.
```{r insertplot3, echo = FALSE, messages = FALSE, warning = FALSE, results = "hide", fig.width= 5.5, fig.height=4.5}
print(plotbarAllStates)
```

```{r createtable2, echo = FALSE, messages = FALSE, include = FALSE}
# Create bar charts of current year's cascade for each state
states <- c("nsw", "vic", "qld", "wa", "sa", "act", "tas", "nt", "all")

stateTable <- filter(hivCascade, population %in% states & year == resultsYear)

# Convert population from factor to character
index <- sapply(stateTable, is.factor)
stateTable[index] <- lapply(stateTable[index], as.character)

# Create final table for states
finalTable <- stateTable %>%
  select(stage, population)
finalTable$estimate <- NA

# Convert lower and upper into a range string

for (ii in 1:nrow(stateTable)){
  if (stateTable$stage[ii] == "linked") {
    finalTable$estimate[ii] <- FormatData(stateTable$value[ii], places = -1)
  } else {
    finalTable$estimate[ii] <- FormatData(stateTable$value[ii], 
                                           stateTable$lower[ii], 
                                           stateTable$upper[ii], places = -1)
  }
}

finalTable$stage <- factor(finalTable$stage)
if (excludeCare) {
  levels(finalTable$stage) <- c("Living with HIV", "Receiving ART", 
                                "Diagnosed", "Suppressed virus")
  finalTable <- within(finalTable, stage <- factor(stage, levels(stage)[c(1, 3, 2, 4)]))  
} else {
 levels(finalTable$stage) <- c("Living with HIV", "Linked to care", 
                              "Receiving ART", "Diagnosed", 
                              "Retained in care", "Suppressed virus")
  finalTable <- within(finalTable, stage <- 
                                factor(stage, levels(stage)[c(1, 4, 2, 3, 5, 6)])) 
  
}

# Spread to the format we want
finalTable <- spread(finalTable, stage, estimate)

# Reorder columns and rows
if (!excludeCare) {
  finalTable <- finalTable[,c(1, 2, 5, 3, 6, 4, 7)]
}
finalTable <- finalTable[c(3, 8, 5, 9, 6, 1, 7, 4, 2),]

# Reformat names
colnames(finalTable) <- c("State", stageNames)
finalTable$State <- toupper(states)
finalTable$State[9] <- "National"

```

**Table 2** -- The HIV care and treatment cascade estimates for each State and Territory in `r resultsYear`. The table shows the cascade estimates with ranges in brackets for each State and Territory.

```{r inserttable2, echo = FALSE, messages = FALSE, warning = FALSE, results = "asis"}
kable(finalTable, align = c("l", "c", "c", "c", "c", "c", "c"))
```

# Key population group estimates

```{r subpops, echo = FALSE, messages = FALSE, include=FALSE}
# Create bar charts of pLHIV for exposure groups and country of birth
# Set up our population groupings
modes <- c("msm", "hetero", "pwid", "otherexp")
modeNames <- c("MSM", "Heterosexual", "PWID", "Other exposure") 
pops <- c("non-indigenous", "indigenous", "bornssa", "bornsea","othercob")
popNames <- c("Non-indigenous \n Australians", "Indigenous \n Australians", 
              "Born in \n Sub-Saharan \n Africa", "Born in \n South East Asia", 
              "Other country \n of birth") 

# Extract the results
expResults <- filter(hivCascade, population %in% modes & year == resultsYear & stage != "linked")
popResults <- filter(hivCascade, population %in% pops & year == resultsYear & stage != "linked")

# Create the plots
plotModeBar <- ggplot(data = expResults, aes(x = population, y = value, fill = stage)) + 
  geom_bar(position = "dodge", stat = "identity") + 
  geom_errorbar(aes(ymin = lower, ymax = upper), 
                position = position_dodge(width = 0.9),
                width = 0.2, color = "black", size = 1.2) +
  scale_fill_brewer(palette = "Set1", name = "", labels = c("Living with HIV", "Diagnosed")) + 
  scale_x_discrete(limits = modes, labels = modeNames) + 
  ylab("Number of people") + xlab("") +  
  plotopts

plotPopBar <- ggplot(data = popResults, aes(x = population, y = value, fill = stage)) + 
  geom_bar(position = "dodge", stat = "identity") + 
  geom_errorbar(aes(ymin = lower, ymax = upper), 
                position = position_dodge(width = 0.9),
                width = 0.2, color = "black", size = 1.2) +
  scale_fill_brewer(palette = "Set1", name = "", labels = c("Living with HIV", "Diagnosed")) + 
  scale_x_discrete(limits = pops, labels = popNames) + 
  ylab("Number of people") + xlab("") +  
  plotopts

# Save if required
if (saveplots) {
  png(file.path(figFolder, paste("HIVcascade-Modes-", toString(resultsYear), ".png",sep ="")), 
        width = 6, height = 4, units = "in", res = 300)
  print(plotModeBar)
  dev.off()
  
  png(file.path(figFolder, paste("HIVcascade-Pops-", toString(resultsYear), ".png",sep ="")), 
        width = 6, height = 4, units = "in", res = 300)
  print(plotPopBar)
  dev.off()
}

```

**Figure 4** -- Number of people living with HIV by mode of exposure in `r resultsYear`.
```{r insertplot4, echo = FALSE, messages = FALSE, warning = FALSE, results = "hide", fig.width= 5.5, fig.height=3.5}
print(plotModeBar)
```

```{r createtable3, echo = FALSE, messages = FALSE, include = FALSE}
# Create and insert table 
tableExp <- select(expResults,-year)
tableExp[,3:5] <- lapply(tableExp[,3:5],round)

finalTable <- select(tableExp, stage, population, value)
finalTable$Range <- NA

# Convert lower and upper into a range string
for (ii in 1:nrow(tableExp)){
  finalTable$Range[ii] <-paste("(", toString(tableExp$lower[ii]), "-", 
                                     toString(tableExp$upper[ii]),")", sep = "")
}

# Manually reorder rows
finalTable <- arrange(finalTable, population, stage)
finalTable <- finalTable[c(3,4,1,2,7,8,5,6),]

# Rename first column
finalTable[finalTable$stage == "infected",]$stage <- "Living with HIV"
finalTable[finalTable$stage == "pldhiv",]$stage <- "Diagnosed"

# Rename second column
finalTable[finalTable$population == "msm",]$population <- "MSM"
finalTable[finalTable$population == "hetero",]$population <- "Heterosexual"
finalTable[finalTable$population == "pwid",]$population <- "PWID"
finalTable[finalTable$population == "otherexp",]$population <- "Other"

# Rename columns
finalTableExp <- rename(finalTable, "Cascade stage" = stage, 
                     "Population by exposure" = population, Estimate = value)

```

**Table 3** -- Number of people living with HIV by exposure population in `r resultsYear`.
```{r inserttable3, echo = FALSE, messages = FALSE, warning = FALSE, results = "asis"}
kable(finalTableExp, align = c("l", "l", "c", "c"))
```

**Figure 5** -- Number of people living with HIV by country of birth in `r resultsYear`.
```{r insertplot5, echo = FALSE, messages = FALSE, warning = FALSE, results = "hide", fig.width= 5.5, fig.height=3.5}
print(plotPopBar)
```

```{r createtable4, echo = FALSE, messages = FALSE, include = FALSE}
# Create and insert table 
tablePop <- select(popResults,-year)
tablePop[,3:5] <- lapply(tablePop[,3:5],round)

finalTable <- select(tablePop, stage, population, value)
finalTable$Range <- NA

# Convert lower and upper into a range string
for (ii in 1:nrow(tablePop)){
  finalTable$Range[ii] <-paste("(", toString(tablePop$lower[ii]), "-", 
                                     toString(tablePop$upper[ii]),")", sep = "")
}

# Manually reorder rows
finalTable <- arrange(finalTable, population, stage)
finalTable <- finalTable[c(7,8,5,6,1,2,3,4,9,10),]

# Rename first column
finalTable[finalTable$stage == "infected",]$stage <- "Living with HIV"
finalTable[finalTable$stage == "pldhiv",]$stage <- "Diagnosed"

# Rename second column
finalTable[finalTable$population == "non-indigenous",]$population <- "Australian born non-indigenous"
finalTable[finalTable$population == "indigenous",]$population <- "Australian born indigenous"
finalTable[finalTable$population == "bornsea",]$population <- "Born in South East Asia"
finalTable[finalTable$population == "bornssa",]$population <- "Born in sub-Saharan Africa"
finalTable[finalTable$population == "othercob",]$population <- "Other"

# Rename columns
finalTablePop <- rename(finalTable, "Cascade stage" = stage, 
                     "Country of birth" = population, Estimate = value)

```

**Table 4** -- Number of people living with HIV by country of birth in `r resultsYear`.
```{r inserttable4, echo = FALSE, messages = FALSE, warning = FALSE, results = "asis"}
kable(finalTablePop, align = c("l", "l", "c", "c"))
```

# Methods and data sources

The following sections describe the methods and data sources used to produce the estimates for each stage of the cascade.

## Estimating the number of people with diagnosed infection

To estimate the number of people living with diagnosed HIV infection (PLDHIV) we performed a simple
calculation using annual notifications, estimated mortality rates, and overseas
migration rates.  

Annual HIV notifications data was provided by Australia's National HIV registry. Due to incomplete or
inaccurate recording of name codes the registry contains multiple reports for some individuals. To
estimate the number of duplicates we applied a statistical technique which has previously been applied
to Australia's National HIV Registry [@nakhaee2009changes]. This calculation estimated the number of duplicate
notifications annually resulting in 8.4% duplicate cases by 2014 with the majority of duplicates
occurring early in the epidemic.  

We combined two approaches to estimate the number of deaths among people diagnosed 
with HIV infection. To estimate the number of deaths up to 2003 we used a linkage 
study conducted between Australia's National Death Index and the National HIV Registry 
for cases to the end of 2003 [@nakhaee2009changes]. This study calculated HIV- and AIDS-related
deaths and also
calculated standardized mortality ratios for people with HIV during different ART eras. It identified
8,519 deaths among people diagnosed with HIV or AIDS to the end of 2003. Of these deaths, 6,900 were recorded in the HIV registry meaning 19% of all deaths were missing from the registry. Due to the back dating of deaths in the HIV registry after 2003, we used this percentage to inflated the number of recorded deaths in the registry until the end of 2003 (inflating the 7,102 deaths recorded to the end of 2003 to 8,768 deaths overall) and estimated the overall average mortality rate for PLDHIV prior to 2003. After 2003 we used annual mortality rates from the Australian HIV Observational Database (AHOD) [@ahod2014report]. Over 2004-2014, similar annual mortality rates were estimated for the AHOD cohort regardless of whether people were retained, lost or returned to follow up. We used the annual overall mortality rate from AHOD as the best estimate and the 95% confidence interval as a range in our calculations for the number of PLDHIV. 

We also considered the impact of overseas migration. As people are not
included in the HIV registry until they have been diagnosed in Australia (even if they have been
diagnosed previously overseas) we did not consider the entry of people living with diagnosed HIV. We
estimated an overseas migration rate for PLDHIV using data from the Australian Bureau of Statistics (ABS
). Given there is likely to be a flux of people leaving temporarily and returning to Australia (some of
which may still receive care and treatment while overseas), we used data on the annual number of people
in the overall population who permanently leave Australia (provided by the ABS since 1976 in series 340102)
and the estimated resident population (ABS series 310104) to calculate an overall migration rate. Since 1981 this rate has risen from around 0.1% to 0.4% of the resident population leaving Australia permanently. Due to the requirement for ongoing care and treatment (which is not subsidised in many countries) we assumed a range in the annual overseas migration rate between zero and the overall rate of permanent departure with a best estimate in the middle. 

Our overall estimate of the number of PLDHIV in Australia each year is obtained by adding the number of unique notifications to the previous year's estimate and subtracting the number of deaths and permanent overseas migrants using the mortality and migration rates. 

### State and territory and sub-population estimates

We also provided HIV estimates for the number of PLHIV and PLDHIV for each state and territory, mode of
exposure, region of birth, and Aboriginal and Torres Strait Islander status. 

For these sub-population calculations we assumed the proportion of duplicates, overseas migration
rate, and HIV mortality rate for each population equals the values for the overall population.
Mortality rates were adjusted for the Indigenous and non-Indigenous Australian born population to
reflect the higher overall mortality in Aboriginal and Torres Strait Islanders as reported by the ABS 
(http://www.abs.gov.au/ausstats/abs@.nsf/mf/3302.0).

To produce HIV cascades for each state we also considered population movement between states. The ABS
provides estimates for interstate arrivals and departures (series 3101016). Using this data and estimated resident population in each state, we estimated the rate people leave each state and territory and the rate people enter from the other jurisdictions. We assumed PLDHIV move between states
at the same rate as the overall population as the provision of care and treatment is maintained across
jurisdictions. 

## Estimating the number of people living with HIV

To estimate the overall number of MSM living with HIV (PLHIV), both diagnosed and undiagnosed,
we estimated the the proportion of MSM and non-MSM PLHIV who are undiagnosed. For MSM we used empirical
data from the COUNT study conducted alongside routine behavioural surveillance surveys in which gay and
homosexually active men from Sydney, Melbourne, Canberra and Perth recruited from a range of gay
community sites in 2013 - 2014. In this study 8.9% of participants had previously undiganosed HIV (95%
CI 5.8-13.5%). For non-MSM we used results from a statistical back projection method  which reported
20% of non-MSM living with HIV are undiagnosed [@wand2010increasing, @mallitt2012incidence]. For 
non-MSM we assumed a range of 15 to 25%.  

Multiplying the proportion of MSM and non-MSM undiagnosed by the proportion of all diagnoses attributed
to male homosexual contact and other exposure gives a weighted average for the overall population of
PLHIV who are undiagnosed of 12.3%. We assumed a range of 9% to 17%. The overall prevalence of 
HIV in Australia was then estimated by inflating the calculated number of people living with diagnosed
infection by the estimated level of undiagnosed infection.

### State and territory and sub-population estimates

We applied the national estimates for the proportion of MSM and non-MSM undiagnosed with HIV to each state and territory and sub-population--- with the non-MSM estimates were used for all non-MSM sub-populations. 

## Estimating antiretroviral treatment coverage

We estimated the number of people receiving ART using a 10% sample of Pharmaceutical Benefits Scheme (PBS) patient level script claims data provided by the company Prospection. This is a randomised patient level, de-identified PBS script claims data set from 2006-present. Currently the data set has 170 million script claims and 3 million patients. It includes all PBS listed drugs with HIV 
indications. Our estimate is the number of unique patients in the PBS data set who filled in at least one script in the 12 months prior to the end of December 2014 multiplied by 10. We assumed that 10% of the Australian population were sampled to estimate the uncertainty range (which equates to approximately $\pm$ 5%)

## Estimating levels of virological suppression

We define virological suppression as less than 400 viral copies per ml. The proportion of people
on ART with viral suppression is taken to be the proportion of people recorded in the Australian
HIV Observational Database (AHOD) who had less than 400 copies per ml at their last viral load
test.Uncertainty bounds were taken to be the proportion of people recorded in AHOD who had less than 1000 copies per ml and 50 copies per ml at their last viral load test. We estimate the number of PLHIV on ART with viral suppression by multiplying this proportion and range by estimated the number of people receiving ART. 

# References
