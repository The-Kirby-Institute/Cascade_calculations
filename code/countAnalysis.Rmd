---
title: "Count HIV Cascade calculations"
author: "Richard T. Gray"
date: "Tuesday, April 21, 2015"
output: word_document
---

This Rmarkdown document describes an analysis of the HIV care and treatment cascade to estimate the proportion of new HIV infections in the overall population due to each stage of the cascade. The stages we are considering are people living with undiagnosed HIV (PLUHIV), people living with diagnosed HIV (PLDHIV), people receiving ART with detectable viral load, and people recieving ART with undetectable viral load. The analysis uses annual estimates for new infections and HIV notifications. 

The results are written in an abstract format at the end of the document for submission to ASHM.....


```{r initialization, echo = FALSE, messages = FALSE, include=FALSE}
# Clear workspace
rm(list=ls()) 
options(scipen=999)  # To get rid of scientific notation

# Load libraries used and that nice for data manipulation
require(ggplot2)
# require(reshape2)
# require(RColorBrewer)
require(readxl)
require(dplyr)
require(tidyr)
require(utils)
require(nnls) # For optimization
require(knitr)
require(gridExtra)

# Set workin directory
setwd("C:/Users/Rgray/Documents/Research/!Evaluation_Modelling/projects/Care_Cascade_Calculations/code")

```

```{r inputdetails, echo = FALSE, messages = FALSE, include=FALSE}
# Details of where to store outputs
dataFolder <- "../data/"
outputFolder <- "../output/"
inputFile <- "countAbstractData.xlsx"
currTime <- format(Sys.time(), "%Y-%m-%d(%H-%M)") # to append to files

# Analysis parameters
numSamples <- 1000  # Number of sampled parameter sets for each year
numInits <- 1000    # Number of init starting points for optimization 
useDiagnoses <- FALSE 

# Options for running and saving things
fullRun <- TRUE # Everytime we do a run from scratch save everything 
folder <- paste("CountAbstractAnalysis_",currTime,sep="")
if(fullRun){
  dir.create(file.path(outputFolder,folder), showWarnings = FALSE)
  outputFolder <- file.path(outputFolder,folder)
}

```


```{r loaddata, echo=FALSE, messages = FALSE, include=FALSE}
# Load data from the countdata.xlsx file 
countData <- read_excel(paste(dataFolder,inputFile,sep =""), na = "NA")

# Using the input data calculate numbers in each column
countClean <- countData[,c("year","diagnoses","infectsmin","infectsmax")]

countClean$undiagmin <- countData$diagnosedmin/(1-countData$undiagmin)-countData$diagnosedmin
countClean$undiagmax <- countData$diagnosedmax/(1-countData$undiagmax)-countData$diagnosedmax
countClean$diagnosedmin <- countData$diagnosedmin-countData$treatedmin
countClean$diagnosedmax <- countData$diagnosedmax-countData$treatedmax

# Number detectables is a little tricker to get the max and min right
countClean$detectablemin <- countData$treatedmin-countData$suppressedmax*countData$treatedmax
countClean$detectablemax <- countData$treatedmax-countData$suppressedmin*countData$treatedmin
countClean$undetectablemin <- countData$suppressedmin*countData$treatedmin
countClean$undetectablemax <- countData$suppressedmax*countData$treatedmax

# Save count files as csv files for later 
if (fullRun){
  write.csv(countData, file = file.path(outputFolder, paste(currTime, "_countRaw.csv", sep ="")))
  write.csv(countClean, file = file.path(outputFolder, paste(currTime, "_countFinal.csv", sep ="")))
}

# Display some output
print(head(countClean,n=2))

```

```{r sampling, echo=FALSE, messages = FALSE, include=FALSE}
# Produce a randomly sampled set of numbers for fitting from the ranges in the countClean dataframe. 

nyears <- nrow(countClean)
numRows <- nyears*numSamples # For preallocation

countSample <- data.frame(year = numeric(numRows),diagnoses = numeric(numRows), newinfects = numeric(numRows), 
                          undiagnosed = numeric(numRows), diagnosed = numeric(numRows),  detectable = numeric(numRows),
                          undetectable = numeric(numRows))

countAverage <- data.frame(year = numeric(nyears),diagnoses = numeric(nyears), newinfects = numeric(nyears),
                           undiagnosed = numeric(nyears), diagnosed = numeric(nyears), detectable = numeric(nyears),
                           undetectable = numeric(nyears))

for (ii in 1:nyears){
  startIndex <- (ii-1)*numSamples+1
  endIndex <- ii*numSamples
  # Fixed data
  countSample[startIndex:endIndex,]$year <- countClean$year[ii]*rep(1,numSamples)
  countSample[startIndex:endIndex,]$diagnoses <- countClean$diagnoses[ii]*rep(1,numSamples)
  # Random sampling
  countSample[startIndex:endIndex,]$newinfects <- runif(numSamples,countClean$infectsmin[ii], countClean$infectsmax[ii])
  countSample[startIndex:endIndex,]$undiagnosed <- runif(numSamples,countClean$undiagmin[ii],countClean$undiagmax[ii])
  countSample[startIndex:endIndex,]$diagnosed <- runif(numSamples,countClean$diagnosedmin[ii],countClean$diagnosedmax[ii])
  countSample[startIndex:endIndex,]$detectable <- runif(numSamples,countClean$detectablemin[ii],countClean$detectablemax[ii])
  countSample[startIndex:endIndex,]$undetectable <- runif(numSamples,countClean$undetectablemin[ii],countClean$undetectablemax[ii]) 
  
  countAverage[ii,] <- colMeans(countSample[startIndex:endIndex,])
}

# Save count sample and avearge as csv files for later 
if (fullRun){
  write.csv(countSample, file = file.path(outputFolder, paste(currTime, "_countSample.csv", sep ="")))
  write.csv(countAverage, file = file.path(outputFolder, paste(currTime, "_countAverage.csv", sep ="")))
}

# Display some output
print(head(countSample))
print(countAverage)

```

```{r exploration, echo=FALSE, messages = FALSE, include=FALSE}
# Before we get serious lets have a look at the data and what we are trying to do

# Melt data into a plotting data frame
plotDataAve <- gather(countAverage,"indicator","estimate",4:7)

# Create a plot looking at the relationships
countplotAve <- ggplot(data=plotDataAve,aes(x=estimate,y=newinfects)) + geom_point() + 
  facet_wrap(~indicator,scales = "free_x") + theme_bw()

# Plot and save
windows(width=7,height=7)
print(countplotAve)
if (fullRun){
  ggsave(file.path(outputFolder, paste(currTime, "_CountPlot.png", sep ="")),width=7,height=7)
}

```

```{r analysis, echo=FALSE, messages = FALSE, include=FALSE}
# Now perform analysis trying to estimate beta values using a simple linear model

# Unadjusted analysis
#====================

# Try a standard linear regression first on everything without adjusting for known reductions when undetectable
# lm <- lm(diagnoses ~ 0 + undiagnosed + diagnosed + detectable + undetectable, data = countSample)
lm <- lm(newinfects ~ 0 + undiagnosed + diagnosed + detectable + undetectable, data = countSample)
print(lm)
coefUnadjustedOverall <- unname(coef(lm))

# Adjusted analysis
# ================

# Biogically we know undiagnosed people are more infectious due to acute infection or at least as infectious as diagnosed people. We also know undetectable PLHIV are 71 to 99% less infectious than diagnosed people. 

# Test forcing a constraint

countAdjust <- countSample # [5001:nrow(countSample)]
numRows <- nrow(countAdjust)
countAdjust$beta4 <- runif(numRows,0.01,0.29)
# countAdjust$beta4 <- 1-rtriangle(numSamples,0.71,0.99,0.96)
countAdjust$adjusted <- (countAdjust$diagnosed + countAdjust$beta4*countAdjust$undetectable)

# if(useDiagnoses){
#   lmAdjust <- lm(diagnoses ~ 0 + undiagnosed + adjusted + detectable, data = countAdjust)
# } else {  
  lmAdjust <- lm(newinfects ~ 0 + undiagnosed + adjusted + detectable, data = countAdjust)
# }
print(lmAdjust)
coefAdjustedOverall <- unname(coef(lmAdjust))

# Sample from coefficents to create uncertainty in the estimates.
confintTemp <- confint(lmAdjust)
coefLower <- c(confint(lmAdjust)[1,1],confint(lmAdjust)[2,1],confint(lmAdjust)[3,1])
coefUpper <- c(confint(lmAdjust)[1,2],confint(lmAdjust)[2,2],confint(lmAdjust)[3,2])

sampleUndiag <- runif(numRows,coefLower[1],coefUpper[1])
sampleDiag <- runif(numRows,coefLower[2],coefUpper[2])
sampleDetect <- runif(numRows,coefLower[3],coefUpper[3])
sampleUndetect <- countAdjust$beta4*sampleDiag

# Extra constraint
countAdjust$beta2 <- runif(numRows,0.5,1)
countAdjust$adjusted2 <- (countAdjust$diagnosed + countAdjust$beta2*countAdjust$detectable + countAdjust$beta4*countAdjust$undetectable)
lmAdjust2 <- lm(diagnoses ~ 0 + undiagnosed + adjusted2, data = countAdjust)
print(lmAdjust2)
coefAdjustedOverall2 <- unname(coef(lmAdjust2))
coefLower2 <- c(confint(lmAdjust2)[1,1],confint(lmAdjust2)[2,1])
coefUpper2 <- c(confint(lmAdjust2)[1,2],confint(lmAdjust2)[2,2])

sampleUndiag2 <- runif(numRows,coefLower2[1],coefUpper2[1])
sampleDiag2 <- runif(numRows,coefLower2[2],coefUpper2[2])
sampleDetect2 <- countAdjust$beta2*sampleDiag2
sampleUndetect2 <- countAdjust$beta4*sampleDiag2

```

```{r}
# Constrained constrain analysis
countConstrain <- countAdjust
countConstrain$z <- -countConstrain$adjusted
dat <- countConstrain #tail(dat, n = numSamples) 

min.RSS <- function(data,par){
  with(data,sum((par[1]*undiagnosed + par[2]*newinfects + par[3]*detectable - z)^2))
}

results <- list()
numInits <- 1000 #numSamples
values <- rep(numInits,0)

initpars <- matrix(c(runif(numInits,1,50),runif(numInits,-50,0),runif(numInits,0,1)),nrow=numInits,ncol = 3)
for (ii in 1:numInits) {
  results[[ii]] <- optim(par = initpars[ii,], min.RSS, data = dat,lower=c(1,-50,0),
                         upper=c(50,0,1),method="L-BFGS-B")
  values[ii] <- results[[ii]]$value
}

pars <- results[[which.min(values)]]$par
p2 <- -1/pars[2]
p3 <- p2*pars[3]
p1 <- p2*pars[1]

sampleUndiag3 <- runif(numRows,p1,p1)
sampleDiag3 <- runif(numRows,p2,p2)
sampleDetect3 <- runif(numRows,p3,p3)
sampleUndetect3 <- countConstrain$beta4*sampleDiag3
```


```{r constrain2}
# Constrained constrain analysis
dat <- countAverage #tail(dat, n = numSamples) 

min.RSS <- function(data,par){
  if((par[2] < par[1] || par[3] > par[2]) || par[4] > par[3]){
    output <- 1e10
  } else {
    output <- with(data,sum((par[1]*undiagnosed + par[2]*diagnosed + par[3]*detectable + par[4]*undetectable - newinfects)^2))
  }
 output
}

results <- list()

numInits <- 100 #numSamples
values <- rep(numInits,0)

initpars <- matrix(c(runif(numInits,0.8,1),runif(numInits,0.5,0.8),runif(numInits,0.4,0.5),runif(numInits,0,0.4)),nrow=numInits,ncol = 4)
for (ii in 1:numInits) {
  results[[ii]] <- optim(par = initpars[ii,], min.RSS, data = dat,lower=c(0,0,0,0),
                         upper=c(1,1,1,1),method="L-BFGS-B")
  values[ii] <- results[[ii]]$value
}

pars <- results[[which.min(values)]]$par



```

```{r}
# Extract results
adjustedCoefs <- matrix(c(sampleUndiag,sampleDiag,sampleDetect,sampleUndetect),nrow = numRows, ncol = 4)
aveCoeffs <- colMeans(adjustedCoefs)
print(aveCoeffs)
 
adjustedCoefs2 <- matrix(c(sampleUndiag2,sampleDiag2,sampleDetect2,sampleUndetect2),nrow = numRows, ncol = 4)
aveCoeffs2 <- colMeans(adjustedCoefs2)
print(aveCoeffs2)

adjustedCoefs3 <- matrix(c(sampleUndiag3,sampleDiag3,sampleDetect3,sampleUndetect3),nrow = numRows, ncol = 4)
aveCoeffs3 <- colMeans(adjustedCoefs3)
print(aveCoeffs3)

# Now estimate the uncertainty and proportion of infections caused by each stage
numUndiag <- sampleUndiag*countSample$undiagnosed
numDiag <- sampleDiag*countSample$diagnosed
numDetect <- sampleDetect*countSample$detectable
numUndetect <- sampleUndetect*countSample$undetectable     
numSum <- numUndiag + numDiag + numDetect + numUndetect
                                                                                                                                                                                                                                                                                                                                 
numUndiag2 <- sampleUndiag2*countSample$undiagnosed
numDiag2 <- sampleDiag2*countSample$diagnosed
numDetect2 <- sampleDetect2*countSample$detectable
numUndetect2 <- sampleUndetect2*countSample$undetectable
numSum2 <- numUndiag2 + numDiag2 + numDetect2 + numUndetect2

numUndiag3 <- sampleUndiag3*countSample$undiagnosed
numDiag3 <- sampleDiag3*countSample$diagnosed
numDetect3 <- sampleDetect3*countSample$detectable
numUndetect3 <- sampleUndetect3*countSample$undetectable
numSum3 <- numUndiag3 + numDiag3 + numDetect3 + numUndetect3

# Put things in a data frame so we can extract results
stageInfects <- data.frame(year = countAdjust$year, undiagnosed = numUndiag, diagnosed = numDiag, detectable = numDetect, undetectable = numUndetect)

propInfects <- data.frame(year = countAdjust$year, undiagnosed = numUndiag/numSum, diagnosed = numDiag/numSum, detectable = numDetect/numSum, undetectable = numUndetect/numSum)

stageInfects2 <- data.frame(year = countAdjust$year, undiagnosed = numUndiag2, diagnosed = numDiag2, detectable = numDetect2, undetectable = numUndetect2)

propInfects2 <- data.frame(year = countAdjust$year, undiagnosed = numUndiag2/numSum2, diagnosed = numDiag2/numSum2, detectable = numDetect2/numSum2, undetectable = numUndetect2/numSum2)

stageInfects3 <- data.frame(year = countAdjust$year, undiagnosed = numUndiag3, diagnosed = numDiag3, detectable = numDetect3, undetectable = numUndetect3)

propInfects3 <- data.frame(year = countAdjust$year, undiagnosed = numUndiag3/numSum3, diagnosed = numDiag3/numSum3, detectable = numDetect3/numSum3, undetectable = numUndetect3/numSum3)

```

```{r prettyplots, echo=FALSE, messages = FALSE, include=FALSE}
graphics.off()

pldhivFrame <- countSample[c(1,4:7)]  %>% dplyr::group_by(year) %>% summarise_each(funs(mean))
infectsFrame <- stageInfects2 %>% dplyr::group_by(year) %>% summarise_each(funs(mean)) 

# Melt data into right format 
plhivResults <- gather(pldhivFrame,"stage","number",2:5) %>%
                  dplyr::group_by(year) %>%
                    mutate(cumsum=cumsum(number))
infectsResults <- gather(infectsFrame,"stage","number",2:5) %>%
                    dplyr::group_by(year) %>%
                      mutate(cumsum=cumsum(number))

# Now create plots 

plhivPlotBase <- ggplot(data = plhivResults, aes(x=year,y=number, fill = stage)) +
  theme_bw() + xlab("Year") + labs(fill='Cascade stage') 
plhivPlot1 <- plhivPlotBase + geom_bar(stat="identity") + ylab("Number PLDHIV") 
plhivPlot2 <- plhivPlotBase + geom_bar(stat="identity",position="fill") + ylab("Proportion PLDHIV") 

infectsPlotBase <- ggplot(data = infectsResults, aes(x=year,y=number, fill = stage))+
  theme_bw() + xlab("Year") +  labs(fill='Cascade stage')
if(useDiagnoses){
  infectsPlot1 <- infectsPlotBase + geom_bar(stat="identity") + ylab("Number Diagnoses")
  infectsPlot2 <- infectsPlotBase + geom_bar(stat="identity",position="fill") + ylab("Proportion Diagnoses")
} else {
  infectsPlot1 <- infectsPlotBase + geom_bar(stat="identity") + ylab("Number Diagnoses")
  infectsPlot2 <- infectsPlotBase + geom_bar(stat="identity",position="fill") + ylab("Proportion Diagnoses") 
}

# Print plots
windows(width=12,height=5)
print(grid.arrange(plhivPlot1,infectsPlot1,plhivPlot2,infectsPlot2,ncol = 2))

```

```{r tidyup,echo = FALSE}
options(scipen=0)  # Set back to default
```
