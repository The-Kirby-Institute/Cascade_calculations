---
title: "Count HIV Cascade calculations"
author: "Richard T. Gray"
date: "Tuesday, April 21, 2015"
output: word_document
---

This Rmarkdown document describes an analysis of the HIV care and treatment cascade to estimate the proportion of new HIV infections in the overall population due to each stage of the cascade. The stages we are considering are people living with undiagnosed HIV (PLUHIV), people living with diagnosed HIV (PLDHIV), people receiving ART with detectable viral load, and people recieving ART with undetectable viral load. The analysis uses annual estimates for new infections and HIV notifications. 

The results are written in an abstract format at the end of the document for submission to ASHM.....


```{r initialization, echo = FALSE, messages = FALSE, include=FALSE}
# Clear workspace
rm(list=ls()) 
options(scipen=999)  # To get rid of scientific notation

# Load libraries used and that nice for data manipulation
require(ggplot2)
# require(reshape2)
# require(RColorBrewer)
require(readxl)
require(dplyr)
require(tidyr)
require(utils)
require(nnls) # For optimization
require(knitr)
require(gridExtra)

# Set workin directory
setwd("C:/Users/Rgray/Documents/Research/!Evaluation_Modelling/projects/Care_Cascade_Calculations/code")

```

```{r inputdetails, echo = FALSE, messages = FALSE, include=FALSE}
# Details of where to store outputs
dataFolder <- "../data/"
outputFolder <- "../output/"
inputFile <- "countdata2.xlsx"
currTime <- format(Sys.time(), "%Y-%m-%d(%H-%M)") # to append to files

# Options for running and saving things
fullRun <- TRUE # Everytime we do a run from scratch save everything 
folder <- paste("CountAbstractAnalysis_",currTime,sep="")
if(fullRun){
  dir.create(file.path(outputFolder,folder), showWarnings = FALSE)
  outputFolder <- file.path(outputFolder,folder)
}

```



```{r loaddata, echo=FALSE, messages = FALSE, include=FALSE}
# Load data from the countdata.xlsx file 
allData <- read_excel(paste(dataFolder,inputFile,sep =""), na = "NA")

# Subset for this analysis remove unnecesary columns
countData <- select(allData,-sex,-population,-region,-postcode)

```

```{r paramters, echo=FALSE, messages = FALSE, include=FALSE}
# Parameters used for estimating additional variables and missing values

countUndiagnosed <- c(0.3,0.25,0.2,0.2,0.18,0.15,0.15,0.14,0.12,0.1) # Temporary value should probably be a min and 
```

```{r fillmissing, echo=FALSE, messages = FALSE, include=FALSE}
#Using our input data and various assumptions fill in missing data

# Create a new dataframe for clean data
countClean <- countData[,c("year","diagnoses")]

# For this abstract we are going to do a simple analysis using the average values of diagnosed and treated 
# varaibles rather than sampling. So create approriate columns for diagnosed and treated.
countClean$diagnosed <- rowMeans(countData[,c("diagnosedmin","diagnosedmax")])
countClean$treated <- rowMeans(countData[,c("treatedmin","treatedmax")],na.rm = FALSE)
countClean$suppressed <- rowMeans(countData[,c("suppressedmin","suppressedmax")],na.rm = FALSE)

# First fill in missing treated values using the available data
propTreat <- mean(countClean$treated/countClean$diagnosed,na.rm = TRUE)
propSuppressed <- mean(countClean$suppressed/countClean$diagnosed,na.rm = TRUE)

countClean[is.na(countClean$treated),]$treated <- propTreat*countClean[is.na(countClean$treated),]$diagnosed
countClean[is.na(countClean$suppressed),]$suppressed <- propSuppressed*countClean[is.na(countClean$suppressed),]$diagnosed

```

```{r sampling, echo=FALSE, messages = FALSE, include=FALSE}

```

```{r addcolumns, echo=FALSE, messages = FALSE, include=FALSE}
# Using the input parameters add columns for number undiagnosed and number detectable and undetectable
countFinal <- countClean[,c("year","diagnoses")]

countFinal$undiagnosed <- countUndiagnosed*countClean$diagnosed
countFinal$diagnosed <- (1-countUndiagnosed)*countClean$diagnosed-countClean$treated
countFinal$undetectable <- countClean$suppressed
countFinal$detectable <- countClean$treated-countClean$suppressed

# Save count files as csv files for later 
if (fullRun){
  write.csv(countData, file = file.path(outputFolder, paste(currTime, "_countRaw.csv", sep ="")))
  write.csv(countClean, file = file.path(outputFolder, paste(currTime, "_countClean.csv", sep ="")))
  write.csv(countFinal, file = file.path(outputFolder, paste(currTime, "_countFinal.csv", sep ="")))
}

```

```{r exploration, echo=FALSE, messages = FALSE, include=FALSE}
# Before we get serious lets have a look at the data and what we are trying to do
# pairs(countFinal[,3:6])

# Melt data into a plotting data frame
plotData <- gather(countFinal,"indicator","estimate",3:6)

# Create a plot looking at the relationships
countplot <- ggplot(data=plotData,aes(x=estimate,y=diagnoses)) + geom_point() + 
  facet_wrap(~indicator,scales = "free_x") + theme_bw()

# Plot and save
windows(width=7,height=7)
print(countplot)
if (fullRun){
  ggsave(file.path(outputFolder, paste(currTime, "_CountPlot.png", sep ="")),width=7,height=7)
}

```

```{r analysis, echo=FALSE, messages = FALSE, include=FALSE}
# Now perform analysis trying to estimate beta values using a simple linear model

# Try a standard linear regression first
lm <- lm(diagnoses ~ 0 + undiagnosed + diagnosed + detectable + undetectable, data = countFinal)
print(lm)

# Use nnls package to force all coefficients to be positive
vars <- as.matrix(countFinal[,c("undiagnosed", "diagnosed","detectable","undetectable")])
nnlsDiags <- nnls(vars,countFinal$diagnoses)

coefDiags <- coef(nnlsDiags)
predDiags <- as.vector(coefDiags%*%t(vars))



# Incidence result data frames
pldhivFrame <- countFinal[,c("year","undiagnosed","diagnosed","undetectable","detectable")] # For plotting
infectsFrame <- pldhivFrame
infectsFrame$undiagnosed <- coefDiags[1]*countFinal$undiagnosed
infectsFrame$diagnosed <- coefDiags[2]*countFinal$diagnosed
infectsFrame$detectable <- coefDiags[3]*countFinal$detectable
infectsFrame$undetectable<- coefDiags[4]*countFinal$undetectable

# Normalise and calculate propvector
# for(ii in 1:numyears){ 
#   
#   
#   
# }

# Final year data
propInfects <- infectsFrame[infectsFrame$year == 2013,2:5]/countFinal$diagnoses

# Prepare to print out some results 
# propFrame <-data.frame(x=c("Undiagnosed","Diagnosed","On ART (detectable)","On ART (undetectable)"),y = 100*propInfects[1,])
# colnames(propFrame) <- c("Stage","Percentage")


```

```{r prettyplots, echo=FALSE, messages = FALSE, include=FALSE}
# Melt data into right format 
# plhivResults <- gather(pldhivFrame,"stage","number",2:5)
plhivResults <- gather(pldhivFrame,"stage","number",2:5) %>%
                  dplyr::group_by(year) %>%
                    mutate(cumsum=cumsum(number))
infectsResults <- gather(infectsFrame,"stage","number",2:5) %>%
                    dplyr::group_by(year) %>%
                      mutate(cumsum=cumsum(number))

# Now create plots 

plhivPlotBase <- ggplot(data = plhivResults, aes(x=year,y=number, fill = stage)) +
  theme_bw() + xlab("Year") + labs(fill='Cascade stage') 
plhivPlot1 <- plhivPlotBase + geom_bar(stat="identity") + ylab("Number PLDHIV") 
plhivPlot2 <- plhivPlotBase + geom_bar(stat="identity",position="fill") + ylab("Proportion PLDHIV") 

infectsPlotBase <- ggplot(data = infectsResults, aes(x=year,y=number, fill = stage))+
  theme_bw() + xlab("Year") +  labs(fill='Cascade stage')
infectsPlot1 <- infectsPlotBase + geom_bar(stat="identity") + ylab("Number Diagnoses")
infectsPlot2 <- infectsPlotBase + geom_bar(stat="identity",position="fill") + ylab("Proportion Diagnoses")

# Print plots
windows(width=12,height=5)
print(grid.arrange(plhivPlot1,infectsPlot1,plhivPlot2,infectsPlot2,ncol = 2))


```
