---
title: "HIV Cascades Calculations"
author: "Richard T. Gray"
date: Date - `r format(Sys.Date(), format="%B %d %Y")`
output: 
  word_document:
    reference_docx: mystyles.docx
---

This document describes and contains the code for producing the HIV care cascade estimates for Australia. It is written in dynamic format using R markdown v2 within Rstudio (version 0.98.1091 with R version`r substr(R.Version()$version.string,1,15)`) to produce a Word (.docx) document (see <http://rmarkdown.rstudio.com>). All the R code to clean the data and produce the figures and tables is contained in this file but suppressed in the final output document. 

```{r initialization, echo = FALSE, messages = FALSE, include=FALSE}
# Clear workspace
rm(list=ls()) 

# Libraries for data manipulation
require(readxl)
require(dplyr)
require(tidyr)
require(utils)

# Libraries for output
require(ggplot2)    
require(knitr)      
# require(gridExtra)  
require(RColorBrewer)

# Set working directory
setwd(file.path(path.expand("~"),"Research","!Evaluation_Modelling","project_care_cascades"))

# Base directory
basePath <- getwd()
dataFolder <- file.path(basePath,"data")

# Folder for plots 
outputFolder <- file.path(basePath,"output")

# Primary script parameters
currTime <- format(Sys.time(), "%y-%m-%d") # to append to files
analysisYear <- 2013
startYear <- 1990
# reclean <- FALSE  # Rerun data cleaning if true otherwise load already cleaned file.
# pop <- "all"  # Population exposure category
# region <- "all" # State for analysis

# TODO: Think about doing cumulative diagnoses for each state and population everytime

# Script options
plots <- FALSE # TRUE if we wnat to plot things
bindCascade <- FALSE # TRUE if we want to store all the cascade results in one data frame

```

## Estimate cumulative HIV notifications 

```{r startAnalysis}
# Load clean file
hivdata <- read.csv(file.path(dataFolder, paste("hivnotifications",
                    toString(analysisYear),".csv", sep ="")))

# Setup overarching analysis                   
years <- startYear:analysisYear # Years to calculate and plot 

# Setup extra columns for analysis
hivdata$yeardiagnosis <- as.numeric(substr(hivdata$datediagnosis,1,4))
hivdata$yeardeath <- as.numeric(substr(hivdata$datedeath,1,4))

allyears <- min(hivdata$yeardiagnosis):analysisYear # All years of data

# Quick checks that we are not doing analysis outside of the data.
if (max(hivdata$yeardiagnosis) < analysisYear) {
  stop("No data for specified for final year of analysis.")
}

if (min(hivdata$yeardiagnosis) > startYear) {
  stop("No data for specified for first year of analysis.")
}

# Setup our working data frame
hivset <- filter(hivdata,yeardiagnosis <= analysisYear)

# Initialize final results data frame
if (bindCascade) {
  hivcascade <- data.frame(stage = character(), 
                         year = double(),
                         population = character(),
                         estimate = double(),
                         lower = double(),
                         upper = double())
}


```

```{r plotcode, echo=FALSE,messages = FALSE,include=FALSE}
# Default plot specifications
graphics.off()

# Baseline theme for plot variables
opts <- theme(text = element_text(face = "bold",size=12,colour="black"),
  axis.text.x = element_text(face = "plain",size=10,colour="black"),
  axis.text.y = element_text(face = "plain",size=10,colour="black"),
  axis.line = element_line(colour="black"),
  axis.ticks = element_line(colour="black"),
  legend.position = "top",
  legend.background = element_rect(),
  legend.key = element_blank(),
  panel.grid.major = element_blank(), 
  panel.grid.minor = element_blank(), 
  panel.background = element_blank(), 
  axis.line = element_line(colour = "black"),
  plot.title=element_text(size=12, face="bold")
)

# Theme for pie chart
blank_theme <- theme_minimal()+
  theme(
  axis.title.x = element_blank(),
  axis.title.y = element_blank(),
  panel.border = element_blank(),
  panel.grid=element_blank(),
  axis.ticks = element_blank(),
  axis.text.y=element_blank(),
  plot.title=element_text(size=12, face="bold")
  )

# Setup colours
getPalette <- colorRampPalette(brewer.pal(12,"Set3"))
piecolours1 <- getPalette(12)
piecolours2 <- gray.colors(3)
piecolours <- c(piecolours2,piecolours1)
linecolours <- brewer.pal(4,"Set1")
```

Sort out diagnoses ...

```{r diagnoses}
# Setup dataframe for overall results by first extracting diagnoses details

# Overall annual results
hivresults <- hivset %>% 
  group_by(yeardiagnosis) %>% 
  summarise(notifications = n()) %>% 
  mutate(totalnotifications  = cumsum(notifications)) %>% 
  filter(yeardiagnosis <= analysisYear)   

# Calculate the proportion of diagnoses by exposure and population category by 
# state and nationally. Theses data frames are used for further calculations

hivstate <- hivset %>% group_by(state,yeardiagnosis) %>% 
  summarise(notifications = n()) %>% 
  mutate(totalnotifications = cumsum(notifications)) %>%
  ungroup() %>% 
  group_by(yeardiagnosis) %>% 
  mutate(propnotifications = notifications/sum(notifications)) %>%
  mutate(proptotalnotifications = totalnotifications/sum(totalnotifications)) %>% 
  filter(yeardiagnosis <= analysisYear)   

hivexpnat <- hivset %>% group_by(expgroup,yeardiagnosis) %>% 
  summarise(notifications = n()) %>% 
  mutate(totalnotifications = cumsum(notifications)) %>%
  ungroup() %>% 
  group_by(yeardiagnosis) %>% 
  mutate(propnotifications = notifications/sum(notifications)) %>%
  mutate(proptotalnotifications = totalnotifications/sum(totalnotifications)) %>% 
  filter(yeardiagnosis <= analysisYear)   

hivexpstate <- hivset %>% group_by(expgroup,state,yeardiagnosis) %>% 
  summarise(notifications = n()) %>% 
  mutate(totalnotifications = cumsum(notifications)) %>%
  ungroup() %>% 
  group_by(state,yeardiagnosis) %>% 
  mutate(propnotifications = notifications/sum(notifications)) %>%
  mutate(proptotalnotifications = totalnotifications/sum(totalnotifications)) %>% 
  filter(yeardiagnosis <= analysisYear)   

# TODO: Will have to do the same by population group
```

```{r functions}
# Load and define useful functions for analysis

# Load function to remove duplicates
source('~/Research/!Evaluation_Modelling/project_care_cascades/code/removeDuplicates.R', echo=TRUE)

# Load function to calculate number living with diagnosed HIV
source('~/Research/!Evaluation_Modelling/project_care_cascades/code/livingDiagnosed.R', echo=TRUE)

# Function to easily extract sub-populations of interest
subhivset <- function(hivdataframe, born = 'all', 
                      region = 'all', mode = 'all' ) {
  # Options
  # pop - all, seasia, ssafrica, indigenous, nonindigenous
  # state - nsw, vic, qld, wa, nt, tas, sa, act
  # expgroup - msm, pwid, hetero, other
  
  subframe <- hivdataframe
  #   if (born ~= 'all')
  #     subframe <- filter(subframe, state == born)
  if (region != 'all') {
    subframe <- filter(subframe, state == region)
  }

  if (mode != 'all') {
    subframe <- filter(subframe, expgroup == mode)            
  }

  # Return final subframe
  return(subframe)
}

# Function for removing duplicates annually
numUnique <- function(dobframe, years,ignore, file = NA) {
  # Loop through years and calculate cumulative number of unique cases 
  numcases <- rep(NA,length(years))
  for (ii in seq(along=years)) {
    dobvector <- filter(dobframe,yeardiagnosis <= years[ii])$dob
    if (length(dobvector) != 0) {
      # Make sure our dobvector isn't empty
      numcases[ii] <- removeDuplicates(dobvector,ignore)
    }
  }
  
  # If selected write final output to file
  if (!is.na(file)) {
    numcases[ii] <- removeDuplicates(dobvector,ignore, write = file)
  }
  
  # Return vector of unique cases
  return(numcases)
}

# Function to create file name for deduplicted output
deduplicateFile <- function(pop, state, mode, years) {
  filename <- paste(basePath, "/output/uniquehiv-", state, "_", mode, "_",
                    toString(tail(years,1)),sep="")
}

# Source function for filling in missing data
source('~/Research/!Evaluation_Modelling/project_care_cascades/code/fillMissing.R'
       , echo=TRUE)

```

Removal of duplicates .....

```{r removeduplicates}

# Days to ignore in duplicate calculations
ignore <- c(1,15) 

# Store number unique diagnoses cumulatively and annually. For annual unique 
# cases assume all the first years of disgnoses are unique. 

### Do calculations for all notifications first
doball <- select(hivset,dob,yeardiagnosis) # Overall
numberUniqueAll <- numUnique(doball, allyears, ignore)

# Store national results
hivresults$uniquecases <- numberUniqueAll

# Add variable for proportion unique - due to statistical calculations 
# proportion mybe slightly higher than one. In those cases round down to 1.
hivresults$propunique <- hivresults$uniquecases/hivresults$totalnotifications
hivresults[hivresults$propunique > 1,]$propunique <- 1

### Now do states and territories
states <- c("act","nsw","vic","qld","nt","wa","sa","tas")

hivstate$uniquecases <- rep(NA,nrow(hivstate))
hivstate$propunique <- rep(NA,nrow(hivstate))

for (ii in 1:length(states)) {
  # Dob vector
  dobtemp <- select(subhivset(hivset, region = states[ii]), dob, yeardiagnosis)
  
  # Calculate number unique
  numberUnique <- numUnique(dobtemp, unique(dobtemp$yeardiagnosis), ignore)
  
  # Store state results
  hivstate[hivstate$state == states[ii],]$uniquecases <- numberUnique
}

# Calculate proportion unique
hivstate$propunique <- hivstate$uniquecases/hivstate$totalnotifications
hivstate[hivstate$propunique > 1,]$propunique <- 1

### Now do mode of exposure
modes <- c("msm", "pwid", "hetero", "otherexp")

hivexpnat$uniquecases <- rep(NA,nrow(hivexpnat))
hivexpnat$propunique <- rep(NA,nrow(hivexpnat))

for (ii in 1:length(modes)) {
  # Dob vector
  dobtemp <- select(subhivset(hivset, mode = modes[ii]), dob, yeardiagnosis)
  
  # Calculate number unique
  numberUnique <- numUnique(dobtemp, unique(dobtemp$yeardiagnosis), ignore)
  
  # Store exposure results
  hivexpnat[hivexpnat$expgroup == modes[ii],]$uniquecases <- numberUnique
}

# Calculate proportion unique
hivexpnat$propunique <- hivexpnat$uniquecases/hivexpnat$totalnotifications
hivexpnat[hivexpnat$propunique > 1,]$propunique <- 1

# TODO: Country of births

```

```{r plotuniques}
graphics.off()

# Plot national notifications data raw and deduplicated
diagsplot1 <- ggplot(hivresults,aes(yeardiagnosis)) + theme_bw() +
  opts + xlim(c(startYear,analysisYear)) + ylim(c(0,NA)) + xlab(" Year") + 
  ylab("Number of notifications")
diagsplot1 <- diagsplot1 + geom_line(aes(y = totalnotifications,color="All notifications")) + 
  geom_line(aes(y = uniquecases,color="Unique notifications")) + 
  theme(legend.direction="vertical") + theme(legend.title=element_blank())

# diagsplot2 <- ggplot(hivexpnat,aes(yeardiagnosis,cumnotifications,fill = expgroup)) + theme_bw() + 
#   opts + xlim(c(startYear,analysisYear)) + ylim(c(0,NA)) + xlab(" Year") + 
#   ylab("Number of notifications") + geom_area()
# 
# diagsplot3 <- ggplot(hivstate,aes(yeardiagnosis,cumnotifications,fill = state)) + theme_bw() + 
#   opts + xlim(c(startYear,analysisYear)) + ylim(c(0,NA)) + xlab(" Year") + 
#   ylab("Number of notifications") + geom_area()
# 
# # Test by state
# test <- filter(hivexpstate,state == "nsw")
# 
# testplot <- ggplot(test,aes(yeardiagnosis,cumnotifications,fill = expgroup)) + theme_bw() + 
#   opts + xlim(c(startYear,analysisYear)) + ylim(c(0,NA)) + xlab(" Year") + 
#   ylab("Number of notifications") + geom_area()

# Print figures
windows(width=6,height=5)
print(diagsplot1)
dev.print(png,paste(outputFolder, "/figures/unique_diagnoses.png",sep =""))

```

Sort out deathrates

```{r deaths}
# To calculate the number of deaths each year we calculate a deathrate with 
# an uncertainty range. This is used to work out the number of people
# diagnosed with HIV. 

# The estimate of the death rate uses a number of methods. Firstly uses the 
# 2003 linkage results and the number of known deaths to estimate the
# deathrate up to 2003. It then uses AHOD mortality rates from 2003 to  

# Load all the data sets we use for this estimate - use the parameter column as 
# row names for easier subsetting
hivparams <- read.csv(file.path(dataFolder, "individualHIVparameters.csv", 
                                sep =""),as.is = 1)
hivparams <- select(hivparams,parameter,value)
for (ii in 1:nrow(hivparams)) {
  assign(hivparams$parameter[ii],hivparams$value[ii])
}

# Load backprojection estimates for comparison
bpdeaths <- read.csv(file.path(dataFolder, "projectedDeaths.csv", 
                                sep =""),as.is = 1)

# Extract number of known deaths and store in a central data frame
hivdeaths <- hivdata %>% 
  filter(! is.na(yeardeath)) %>%
  group_by(yeardeath) %>% 
  summarise(number_deaths = n()) %>% 
  filter(yeardeath <= analysisYear)  

# Calculate sensitivity of recorded deaths based on linkage results
linkageFactor <- (linkedDeaths+notifiedDeaths)/notifiedDeaths
linkageFactorLower <- linkageFactor*(1-linkageSensitivity)
linkageFactorUpper <- linkageFactor*(1+linkageSensitivity)  

#  We don't need to adjust deaths for number of unique diagnoses as
# different dates of death should result in different people

# Set up linked deaths
hivdeaths$inflated_deaths <- hivdeaths$number_deaths * linkageFactor
hivdeaths$inflated_deaths_lower <- hivdeaths$number_deaths * linkageFactorLower
hivdeaths$inflated_deaths_upper <- hivdeaths$number_deaths * linkageFactorUpper

# No deaths in 1980 and 1982 so add this data manually to ensure everything lines up
hivdeaths <- rbind(hivdeaths,c(1980,0,0,0,0))
hivdeaths <- rbind(hivdeaths,c(1982,0,0,0,0))
hivdeaths <- arrange(hivdeaths,yeardeath)

### Now calculate mortality rate for linkage data ------------------------
cumdiagnoses <- hivresults$totalnotifications
deaths <- hivdeaths$inflated_deaths
deaths_min <- hivdeaths$inflated_deaths_lower
deaths_max <- hivdeaths$inflated_deaths_upper
anndiags <- c(cumdiagnoses[1],diff(cumdiagnoses))  # Annual diagnoses

# Calculate number living each year 
numliving <- rep(NA,length(anndiags))
numliving_min <- rep(NA,length(anndiags))
numliving_max <- rep(NA,length(anndiags))

numliving[1] <- anndiags[1]
numliving_min[1] <- anndiags[1]
numliving_max[1] <- anndiags[1]

for (ii in 2:length(anndiags)) {
  numliving[ii] <- numliving[ii-1] + anndiags[ii] - deaths[ii-1] 
  numliving_min[ii] <- numliving_min[ii-1] + anndiags[ii] - deaths_max[ii-1] 
  numliving_max[ii] <- numliving_max[ii-1] + anndiags[ii] - deaths_min[ii-1] 
}

# Calculate mortality
linkageMortality <- deaths/numliving
linkageMortalityMin <- deaths_min/numliving_max
linkageMortalityMax <- deaths_max/numliving_min

### Append AHOD mortality

# First find index corresponding to year of linkage 
indexLinkage <- max(seq(along = min(hivresults$yeardiagnosis):linkageYear))

# Save in deathrate
deathrate <- rep(NA,length(allyears))
deathrate_min <- rep(NA,length(allyears))
deathrate_max <- rep(NA,length(allyears))

deathrate[1:indexLinkage] <- linkageMortality[1:indexLinkage]
deathrate[(indexLinkage+1):length(deathrate)] <- ahodMortality

deathrate_min[1:indexLinkage] <- linkageMortalityMin[1:indexLinkage]
deathrate_min[(indexLinkage+1):length(deathrate)] <- ahodMortalityLower

deathrate_max[1:indexLinkage] <- linkageMortalityMax[1:indexLinkage]
deathrate_max[(indexLinkage+1):length(deathrate)] <- ahodMortalityUpper

# Store final death rate
hivdeathrate <- data.frame(year = allyears, deathrate = deathrate, 
                           deathrate_min = deathrate_min, 
                           deathrate_max = deathrate_max)

```

Sort out population movement rates

```{r migration}
# This chunk converts the ABS overseas and interste migration data into 
# population movement rates

# Load all the data sets we need - the ABS data is stored in a different folder
absFolder <- file.path(path.expand("~"),"Research","!Evaluation_Modelling","data")
 
absMigration <- read.csv(file.path(absFolder, "ABS_migration_clean.csv", 
                                sep =""),as.is = 1)
absInterstate <- read.csv(file.path(absFolder, "ABS_interstate_clean.csv", 
                                sep =""),as.is = 1)

# Calculate migration rate overall and for each state
absMigration <- mutate(absMigration, migrate = departures/erp)

states <- c("nsw", "vic", "qld", "nt", "wa", "sa", "tas", "act", "all")
nstates <- length(states)

allPredicts <- data.frame(year = allyears)

for (ii in 1:nstates) {
  mrate <- filter(absMigration, state == states[ii])
  
  # Now we need to fit and extrapolate for other years
  lmrate <- lm(migrate ~ year, data = mrate)
  expmrate <- predict(lmrate, data.frame(year = allyears))
  
  # Store extrapolated rate
  allPredicts[[states[ii]]] <- expmrate
}

# Now work out mins and maxs and store in a final data frame.
# Use state min and max as range for national migration rates.
# Use the relative range of the national rates for each state rate
allmrateMin <- apply(select(allPredicts,-year), 1, min)
allmrateMax <- apply(select(allPredicts,-year), 1, max)

# Calculate relative rates
relmrateMin <- allmrateMin/allPredicts$all
relmrateMax <- allmrateMax/allPredicts$all

# Store everything in a dataframe
hivmigrate <- gather(allPredicts, "state", "rate", 2:10)

hivmigrate$lower <- NA
hivmigrate$upper <- NA

hivmigrate[hivmigrate$state == "all",]$lower <- allmrateMin
hivmigrate[hivmigrate$state == "all",]$upper <- allmrateMax

for (ii in 1:(nstates-1)) {
  temprate <- filter(hivmigrate, state == states[ii])$rate
  hivmigrate[hivmigrate$state == states[ii],]$lower <-  relmrateMin * temprate
  hivmigrate[hivmigrate$state == states[ii],]$upper <-  relmrateMax * temprate
}

### Calculate interstate rates

# First estimate erp for each state

allinterstate <- data.frame(year = allyears)

for (ii in 1:nstates) {
  lmerp <- lm(erp ~ year, data = filter(absMigration, state == states[ii]))
  erpstate <- predict(lmerp, data.frame(year = allyears))
  
  # Store extrapolated population
  allinterstate[[states[ii]]] <- erpstate
}

hivinterstate <- gather(allinterstate, "state", "erp", 2:10)

# Calculate interstate ERP simply overall population minus state population
allerp <- filter(hivinterstate, state == "all")$erp

hivinterstate <- hivinterstate %>% 
  group_by(state) %>%
  mutate(intererp = allerp-erp)

# Calculate departure rate
hivinterstate$departures <- NA

for (ii in 1:nstates) {
  lmdepart <- lm(departures ~ year, data = filter(absInterstate, state == states[ii]))
  departstate <- predict(lmdepart, data.frame(year = allyears))
  
  # Store extrapolated population
  hivinterstate[hivinterstate$state == states[ii],]$departures <- departstate
}

hivinterstate <- mutate(hivinterstate,departrate = departures/erp) 

# Calculate arrival rate
hivinterstate$arrivals <- NA

for (ii in 1:nstates) {
  lmarrive <- lm(arrivals ~ year, data = filter(absInterstate, state == states[ii]))
  arrivestate <- predict(lmarrive, data.frame(year = allyears))
  
  # Store extrapolated population
  hivinterstate[hivinterstate$state == states[ii],]$arrivals <- arrivestate
}

hivinterstate <- mutate(hivinterstate,arriverate = arrivals/intererp) 

# As intererp is zero national set arriverate to departure rate for "all"
# Gives indication of rate people move interstate nationally
hivinterstate[hivinterstate$state == "all",]$arriverate <- 
  hivinterstate[hivinterstate$state == "all",]$departrate

```

### Number living with diagnosed HIV

```{r livingdiags}
# This chuck now estimates the number of people living with diagnosed HIV. 

# Initialize final results data frame
hivdiagnosed <- data.frame(stage = character(), 
                         year = double(),
                         population = character(),
                         estimate = double(),
                         lower = double(),
                         upper = double())

### First calculate overall number

# Setup all our vectors - first by filling in missing cumulative diagnoses
filledDiagnoses <- fillMissing(allyears, hivresults$yeardiagnosis, 
                                 hivresults$uniquecases)

cumDiagnoses <- filledDiagnoses$value

# All death rates used for all  populations
deathRate <- hivdeathrate$deathrate
deathRateMin <- hivdeathrate$deathrate_min
deathRateMax <- hivdeathrate$deathrate_max

# National migration rates
migrationRate <- filter(hivmigrate, state == "all")$rate
migrationRateMin <- filter(hivmigrate, state == "all")$lower
migrationRateMax <- filter(hivmigrate, state == "all")$upper

# Calculate number living with diagnosed HIV and range
pldhivAll <- livingDiagnosed(cumDiagnoses, deathRate, migrationRate)

# Use max rates for min estimate because they are removal rates and vice versa
pldhivAllMin <- livingDiagnosed(cumDiagnoses, deathRateMax, migrationRateMax) 
pldhivAllMax <- livingDiagnosed(cumDiagnoses, deathRateMin, migrationRateMin) 

# Store results
nyears <- length(allyears)
hivdiagnosed <- rbind(hivdiagnosed,data_frame(stage = rep("pldhiv",nyears), 
                            year = allyears, 
                            population = rep("all", nyears), 
                            value = pldhivAll,
                            lower = pldhivAllMin,
                            upper = pldhivAllMax))

### Now do state based PLDHIV

for (ii in 1:(nstates-1)) {
  stateyears <- filter(hivstate, state == states[ii])$yeardiagnosis
  statediags <- filter(hivstate, state == states[ii])$uniquecases
    
  fillStateDiags <- fillMissing(allyears, stateyears, statediags)  
  cumStateDiags <- fillStateDiags$value
  
  # State migration rates
  migStateRate <- filter(hivmigrate, state == states[ii])$rate
  migStateRateMin <- filter(hivmigrate, state == states[ii])$lower
  migStateRateMax <- filter(hivmigrate, state == states[ii])$upper
  
  # State departures
  depStateRate <- filter(hivinterstate, state == states[ii])$departrate
  
  # State arrivals
  arrStateRate <- filter(hivinterstate, state == states[ii])$arriverate
  
  # Do the state calculation and range
  pldhivState <- livingDiagnosed(cumStateDiags, deathRate, migStateRate,
                                 arrStateRate, depStateRate, pldhivAll)
  
  pldhivStateMin <- livingDiagnosed(cumStateDiags, deathRateMax, migStateRateMax,
                                 arrStateRate, depStateRate, pldhivAll)
  
  pldhivStateMax <- livingDiagnosed(cumStateDiags, deathRateMin, migStateRateMin,
                                 arrStateRate, depStateRate, pldhivAll)
  
  # Store the state results
  hivdiagnosed <- rbind(hivdiagnosed, data_frame(stage = rep("pldhiv",nyears), 
                            year = allyears, 
                            population = rep(states[ii], nyears), 
                            value = pldhivState,
                            lower = pldhivStateMin,
                            upper = pldhivStateMax))
}

### Now do exposure based PLHIV

modes <- c("msm", "pwid", "hetero", "otherexp")
nmodes <- length(modes)

for (ii in 1:nmodes) {
  expyears <- filter(hivexpnat, expgroup == modes[ii])$yeardiagnosis
  expdiags <- filter(hivexpnat, expgroup == modes[ii])$uniquecases
    
  fillExpDiags <- fillMissing(allyears, expyears, expdiags)  
  cumExpDiags <- fillExpDiags$value
  
  # Exp migration rates, death rates, assumed to be same overall
  
  # Do the Exp calculation and range
  pldhivExp <- livingDiagnosed(cumExpDiags, deathRate, migrationRate)
  
  pldhivExpMin <- livingDiagnosed(cumExpDiags, deathRateMax, migrationRateMax)
  pldhivExpMax <- livingDiagnosed(cumExpDiags, deathRateMin, migrationRateMin)
  
  # Store the state results
  hivdiagnosed <- rbind(hivdiagnosed, data_frame(stage = rep("pldhiv",nyears), 
                            year = allyears, 
                            population = rep(modes[ii], nyears), 
                            value = pldhivExp,
                            lower = pldhivExpMin,
                            upper = pldhivExpMax))
}

# Finally bind to overall results
if (bindCascade) {
  hivcascade <- rbind(hivcascade,hivdiagnosed)
}

```

### Number undiagnosed

```{r undiagnosed}
# This chuck now estimates the number of people living with diagnosed HIV. 

# Initialize final results data frame
hivundiag <- data.frame(stage = character(), 
                         year = double(),
                         population = character(),
                         estimate = double(),
                         lower = double(),
                         upper = double())

# Read in back projected undiagnosed estimates
propUndiagnosed <- read.csv(file.path(dataFolder, "projectedUndiagnosed.csv"),as.is = 1)

# Only keep required years
propUndiagnosed <- filter(propUndiagnosed, year %in% allyears) 

# Estimate proportion MSM and non-MSM for weighting
propMSM <- filter(hivexpnat, expgroup == "msm")$proptotalnotifications
propHetero <- filter(hivexpnat, expgroup == "hetero")$proptotalnotifications
propPwid <- filter(hivexpnat, expgroup == "pwid")$proptotalnotifications
propOther <- filter(hivexpnat, expgroup == "otherexp")$proptotalnotifications

# Fill in missing data years - simply assume proportion is same previous year
propMSM <- fillMissing(allyears, filter(hivexpnat, expgroup == "msm")$yeardiagnosis, propMSM)
propHetero <- fillMissing(allyears, filter(hivexpnat, expgroup == "hetero")$yeardiagnosis, propHetero)
propPwid <- fillMissing(allyears, filter(hivexpnat, expgroup == "pwid")$yeardiagnosis, propPwid)
propOther <- fillMissing(allyears, filter(hivexpnat, expgroup == "otherexp")$yeardiagnosis, propOther)

# Estimate overall non-MSM undiagnosed proportion
propNonMSM <- 1 - propMSM$value

# Weighted undiagnosed proportion
undiagAll <- propMSM$value * propUndiagnosed$msm_best + 
            propNonMSM * propUndiagnosed$non_msm_best
undiagAllMin <- apply(rbind(propUndiagnosed$msm_lower, propUndiagnosed$non_msm_lower),2,min)                
undiagAllMax <- apply(rbind(propUndiagnosed$msm_upper, propUndiagnosed$non_msm_upper),2,max)

### Now estimate number of people living with HIV overall
pldhivTemp <- filter(hivcascade, stage == "pldhiv" & population == "all")
infectedAll <- pldhivTemp$value/(1 - undiagAll)
infectedAllMin <- pldhivTemp$lower/(1 - undiagAllMin)
infectedAllMax <- pldhivTemp$upper/(1 - undiagAllMax)

# Store overall results
hivundiag <- rbind(hivundiag, data_frame(stage = rep("infected",nyears), 
                            year = allyears, 
                            population = rep("all", nyears), 
                            value = infectedAll,
                            lower = infectedAllMin,
                            upper = infectedAllMax))

### Now calculate undiagnosed for each state
for (ii in 1:(nstates-1)) {
  pldhivTemp <- filter(hivcascade, stage == "pldhiv" & population == states[ii])
  infectedState <- pldhivTemp$value/(1 - undiagAll)
  infectedStateMin <- pldhivTemp$lower/(1 - undiagAllMin)
  infectedStateMax <- pldhivTemp$upper/(1 - undiagAllMax)
  
  # Store results 
  hivundiag <- rbind(hivundiag,data_frame(stage = rep("infected",nyears), 
                            year = allyears, 
                            population = rep(states[ii], nyears), 
                            value = infectedAll,
                            lower = infectedAllMin,
                            upper = infectedAllMax))
}

### Now calculate for each exposure group

for (ii in 1:nmodes) {
  pldhivTemp <- filter(hivcascade, stage == "pldhiv" & population == modes[ii])
  
  if (modes[ii] == "msm") {
    infectedExp <- pldhivTemp$value/(1 - propUndiagnosed$msm_best)
    infectedExpMin <- pldhivTemp$lower/(1 - propUndiagnosed$msm_lower)
    infectedExpMax <- pldhivTemp$upper/(1 - propUndiagnosed$msm_upper)
  } else {
    infectedExp <- pldhivTemp$value/(1 - propUndiagnosed$non_msm_best)
    infectedExpMin <- pldhivTemp$lower/(1 - propUndiagnosed$non_msm_lower)
    infectedExpMax <- pldhivTemp$upper/(1 - propUndiagnosed$non_msm_upper)
    
  }
  
  # Store results 
  hivundiag <- rbind(hivundiag,data_frame(stage = rep("infected",nyears), 
                                          year = allyears, 
                                          population = rep(modes[ii], nyears), 
                                          value = infectedAll,
                                          lower = infectedAllMin,
                                          upper = infectedAllMax))
}               

# Finally bind to overall results
if (bindCascade) {
  hivcascade <- rbind(hivcascade,hivundiag)
}

```

### Number linked to care

```{r linked}
# Now estimate the number living with diagnosesd HIV who have been linked 
# to care

# Initialize final results data frame
hivlinkcare <- data.frame(stage = character(), 
                         year = double(),
                         population = character(),
                         estimate = double(),
                         lower = double(),
                         upper = double())

### Overall annual results
hivlinkedAll <- hivset %>% 
  group_by(yeardiagnosis) %>% 
  filter(!is.na(cd4count)) %>%
  summarise(linked = n()) %>% 
  mutate(totallinked  = cumsum(linked)) %>% 
  filter(yeardiagnosis <= analysisYear) 

# Manually insert first two years as they are missing
hivlinkedAll <- rbind(hivlinkedAll, c(1980, 0, 0))
hivlinkedAll <- rbind(hivlinkedAll, c(1981, 0, 0))
hivlinkedAll <- arrange(hivlinkedAll, yeardiagnosis)

# Calculate number linked to care using national death rates and migration rates
cumLinked <- hivlinkedAll$totallinked
linkedAll <- livingDiagnosed(cumLinked, deathRate, migrationRate)
linkedAllMin <- livingDiagnosed(cumLinked, deathRateMax, migrationRateMax)
linkedAllMax <- livingDiagnosed(cumLinked, deathRateMin, migrationRateMin)

# ISSUE: Number linked to care with above methodology seems too low. An 
# An alternative is to look at the proportion linked each year.
uniqueDiags <- c(hivresults$uniquecases[1], diff(hivresults$uniquecases))
proplinked <- hivlinkedAll$linked/uniqueDiags
propl <- data.frame(year = allyears, proportion = proplinked)
lmlinked <- lm(proportion ~ year, data = filter(propl, year > 2000))
predictlinked <- predict(lmlinked, data.frame(year = allyears))

# Some basic tests
# livingDiagnosed(cumsum(uniqueDiags * predictlinked),deathRate, migrationRate)
# livingDiagnosed(cumsum(uniqueDiags * predictlinked),deathRate, rep(0,length(migrationRate)))

hivlinkcare <- rbind(hivlinkcare, data_frame(stage = rep("linked", nyears), 
                            year = allyears, 
                            population = rep("all", nyears), 
                            value = linkedAll,
                            lower = linkedAllMin,
                            upper = linkedAllMax))


# Create a plot to show the fitting of the proportion linked 
if (plots) {
  plotData <- data.frame(year = allyears, 
                       proportion = proplinked, 
                       prediction = predictlinked)
  
  plplot <- ggplot(data = plotData,aes(x = year, y = proportion)) + geom_line() + 
    geom_line(aes(y = predictlinked), color  = "blue") + 
    theme_bw() + opts + ylim(c(0,NA)) + xlab("Year") + 
    ylab("Proportion annual notifications linked")
    
  # Print figures
  windows(width=6,height=5)
  print(plplot)
  ggsave(paste(outputFolder, "/figures/prop_linked.png",sep =""), 
         width = 6, height=5, dpi = 300 )
}

### State calculations
hivlinkedState <- hivset %>% group_by(state,yeardiagnosis) %>% 
  filter(!is.na(cd4count)) %>%
  summarise(linked = n()) %>% 
  mutate(totallinked = cumsum(linked)) %>%
  filter(yeardiagnosis <= analysisYear) 

for (ii in 1:(nstates - 1)) {
  templinked <- filter(hivlinkedState, state == states[ii])
  templinked <- fillMissing(allyears, templinked$yeardiagnosis, templinked$totallinked)
  
  cumlinked <- templinked$value
  
  # State migration rates
  migStateRate <- filter(hivmigrate, state == states[ii])$rate
  migStateRateMin <- filter(hivmigrate, state == states[ii])$lower
  migStateRateMax <- filter(hivmigrate, state == states[ii])$upper
  
  # State departures
  depStateRate <- filter(hivinterstate, state == states[ii])$departrate
  
  # State arrivals
  arrStateRate <- filter(hivinterstate, state == states[ii])$arriverate
  
  # Do the state calculation and range
  linkedState <- livingDiagnosed(cumlinked, deathRate, migStateRate,
                                 arrStateRate, depStateRate, pldhivAll)
  
  linkedStateMin <- livingDiagnosed(cumlinked, deathRateMax, migStateRateMax,
                                 arrStateRate, depStateRate, pldhivAll)
  
  linkedStateMax <- livingDiagnosed(cumlinked, deathRateMin, migStateRateMin,
                                 arrStateRate, depStateRate, pldhivAll)  
  
  # Store state results 
  hivlinkcare <- rbind(hivlinkcare, data_frame(stage = rep("linked", nyears), 
                            year = allyears, 
                            population = rep(states[ii], nyears), 
                            value = linkedState,
                            lower = linkedStateMin,
                            upper = linkedStateMax))
  
}

### Exposure mode calculations  
hivlinkedExp <- hivset %>% group_by(expgroup,yeardiagnosis) %>% 
  filter(!is.na(cd4count)) %>%
  summarise(linked = n()) %>% 
  mutate(totallinked = cumsum(linked)) %>%
  filter(yeardiagnosis <= analysisYear) 


for (ii in 1:nmodes) {
  templinked <- filter(hivlinkedExp, expgroup == modes[ii])
  templinked <- fillMissing(allyears, templinked$yeardiagnosis, templinked$totallinked)
  
  cumlinked <- templinked$value
  
  # Exp migration rates, death rates, assumed to be same overall
  
  # Do the Exp calculation and range
  linkedExp <- livingDiagnosed(cumlinked, deathRate, migrationRate)
  
  linkedExpMin <- livingDiagnosed(cumlinked, deathRateMax, migrationRateMax)
  linkedExpMax <- livingDiagnosed(cumlinked, deathRateMin, migrationRateMin)
  
  # Store the state results
  hivlinkcare <- rbind(hivlinkcare, data_frame(stage = rep("linked",nyears), 
                            year = allyears, 
                            population = rep(modes[ii], nyears), 
                            value = linkedExp,
                            lower = linkedExpMin,
                            upper = linkedExpMax))
}

# Finally bind to overall results
if (bindCascade) {
  hivcascade <- rbind(hivcascade,hivundiag)
}

```

### Number taking ART

```{r treatment}



```

