---
title: "HIV Cascades Calculations"
author: "Richard T. Gray"
date: Date - `r format(Sys.Date(), format="%B %d %Y")`
output: 
  word_document:
    reference_docx: mystyles.docx
---

This document describes and contains the code for producing the HIV care cascade estimates for Australia. It is written in dynamic format using R markdown v2 within Rstudio (version 0.98.1091 with R version`r substr(R.Version()$version.string,1,15)`) to produce a Word (.docx) document (see <http://rmarkdown.rstudio.com>). All the R code to clean the data and produce the figures and tables is contained in this file but suppressed in the final output document. 

```{r initialization, echo = FALSE, messages = FALSE, include=FALSE}
# Clear workspace
rm(list=ls()) 

# Setup directories
basePath <- file.path(path.expand("~"), "Research", 
                      "!Evaluation_Modelling", "project_care_cascades")
Rcode <- file.path(basePath, "code") 
dataFolder <- file.path(basePath,"data") 
outputFolder <- file.path(basePath,"output") 

# Set working directory
setwd(basePath)

# Load libraries ------------------------------------------------------
source(file.path(Rcode, "LoadLibrary.R"), echo=TRUE)
source(file.path(Rcode, "DataLibraries.R"), echo=TRUE)
source(file.path(Rcode, "PlotOptions.R"), echo=TRUE)

# Primary script parameters
currTime <- format(Sys.time(), "%y-%m-%d") # to append to files
analysisYear <- 2014
startYear <- 1990

# Script options ------------------------------------------------------

plots <- FALSE      # TRUE if we want to plot things
bindCascade <- TRUE # TRUE if we want to store all the cascade results 
                    # one data frame

saveCascade <- FALSE       # save final cascade dataframe
saveNotifications <- FALSE # save cleaned notifications set
saveResults <- FALSE       # save information national annual notifications

nationalUniques <- TRUE # use proportion from National estimates for 
                        # sub-population de-duplication

indigKnown <- TRUE # only use notifications with indigenous classification 
                   # for indigenous estimates

permDeparts <- TRUE # Use national permant departures for 
                    # overseas migration

useCD4 <- FALSE # Use CD4 AHOD and testing data for retained in care

# Given issues with undiagnosed estimates use hardcoded estimates from 
# 2013 ASR
useOldpropundiagnosed <- TRUE 

```

```{r functions}
# Load and define useful functions for analysis

# Load function to remove duplicates
source(file.path(basePath, "code","RemoveDuplicates.R"), echo=TRUE)

# Load function to calculate number living with diagnosed HIV
source(file.path(basePath, "code","LivingDiagnosed.R"), echo=TRUE)

# Source function for filling in missing data
source(file.path(basePath, "code", "FillMissing.R"), echo=TRUE)

# Function to easily extract sub-populations of interest
subhivset <- function(hivdataframe, born = 'all', 
                      region = 'all', mode = 'all' ) {
  # Options
  # pop - all, seasia, ssafrica, indigenous, nonindigenous
  # state - nsw, vic, qld, wa, nt, tas, sa, act
  # expgroup - msm, pwid, hetero, other
  
  subframe <- hivdataframe
  #   if (born ~= 'all')
  #     subframe <- filter(subframe, state == born)
  if (region != 'all') {
    subframe <- filter(subframe, state == region)
  }

  if (mode != 'all') {
    subframe <- filter(subframe, expgroup == mode)            
  }

  # Return final subframe
  return(subframe)
}

# Function for removing duplicates annually
numUnique <- function(dobframe, years,ignore, file = NA) {
  # Loop through years and calculate cumulative number of unique cases 
  numcases <- rep(NA,length(years))
  for (ii in seq(along=years)) {
    dobvector <- filter(dobframe,yeardiagnosis <= years[ii])$dob
    if (length(dobvector) != 0) {
      # Make sure our dobvector isn't empty
      numcases[ii] <- RemoveDuplicates(dobvector,ignore)
    }
  }
  
  # If selected write final output to file
  if (!is.na(file)) {
    numcases[ii] <- RemoveDuplicates(dobvector,ignore, write = file)
  }
  
  # Return vector of unique cases
  return(numcases)
}

# Function to create file name for deduplicted output
deduplicateFile <- function(pop, state, mode, years) {
  filename <- paste(basePath, "/output/uniquehiv-", state, "_", mode, "_",
                    toString(tail(years,1)),sep="")
}

```

```{r plotcode, echo=FALSE,messages = FALSE,include=FALSE}
# Default plot specifications
graphics.off()

# 
# Baseline theme for plot variables
opts <- theme_bw() + theme(text = element_text(face = "bold",size=12,colour="black"),
  axis.text.x = element_text(face = "plain",size=10,colour="black"),
  axis.text.y = element_text(face = "plain",size=10,colour="black"),
  axis.line = element_line(colour="black"),
  axis.ticks = element_line(colour="black"),
  legend.position = "top",
  legend.background = element_rect(),
  legend.key = element_blank(),
  panel.grid.major = element_blank(), 
  panel.grid.minor = element_blank(), 
  panel.background = element_blank(), 
  axis.line = element_line(colour = "black"),
  plot.title=element_text(size=12, face="bold")
)

# Setup colours
# getPalette <- colorRampPalette(brewer.pal(12,"Set3"))
# piecolours1 <- getPalette(12)
# piecolours2 <- gray.colors(3)
# piecolours <- c(piecolours2,piecolours1)
# linecolours <- brewer.pal(4,"Set1")

```

## Estimate cumulative HIV notifications 

```{r startAnalysis}
# Load clean file
hivdata <- read.csv(file.path(dataFolder, paste("hivnotifications",
                    toString(analysisYear),".csv", sep =""))) #, 
#                     as.is = c(1:3, 6, 9, 11, 16:18))

# Setup overarching analysis                   
years <- startYear:analysisYear # Years to calculate and plot 

# Setup extra columns for analysis
hivdata$yeardiagnosis <- as.numeric(substr(hivdata$datediagnosis,1,4))
hivdata$yeardeath <- as.numeric(substr(hivdata$datedeath,1,4))

allyears <- min(hivdata$yeardiagnosis):analysisYear # All years of data

# Quick checks that we are not doing analysis outside of the data.
if (max(hivdata$yeardiagnosis) < analysisYear) {
  stop("No data specified for final year of analysis.")
}

if (min(hivdata$yeardiagnosis) > startYear) {
  stop("No data specified for first year of analysis.")
}

# Setup our working data frame
hivset <- filter(hivdata,yeardiagnosis <= analysisYear)

if (saveNotifications) {
  # Directory and file name
  saveString <- file.path(outputFolder, paste("HIVset-", 
                                              toString(analysisYear), sep = ""))
  
  # Write to csv
  write.csv(hivset, file = paste(saveString, ".csv", sep =""), 
            row.names = FALSE)

  # Save as R object
  save(hivset, file = paste(saveString, ".rda", sep =""))  
  
}

# Initialize final results data frame
if (bindCascade) {
  hivcascade <- data.frame(stage = character(), 
                         year = double(),
                         population = character(),
                         estimate = double(),
                         lower = double(),
                         upper = double())
}

```

Sort out diagnoses ...

```{r diagnoses}
# Setup dataframe for overall results by first extracting diagnoses details

### Overall annual results
hivresults <- hivset %>% 
  group_by(yeardiagnosis) %>% 
  summarise(notifications = n()) %>% 
  mutate(totalnotifications  = cumsum(notifications)) %>% 
  filter(yeardiagnosis <= analysisYear)   

### Annual results by state and exposure category

# Calculate the proportion of diagnoses by exposure and population category by 
# state and nationally. Theses data frames are used for further calculations

hivstate <- hivset %>% group_by(state,yeardiagnosis) %>% 
  summarise(notifications = n()) %>% 
  ungroup() %>% 
  group_by(state) %>%
  mutate(totalnotifications = cumsum(notifications)) %>%
  ungroup() %>% 
  group_by(yeardiagnosis) %>% 
  mutate(propnotifications = notifications/sum(notifications)) %>%
  mutate(proptotalnotifications = totalnotifications/sum(totalnotifications)) %>% 
  filter(yeardiagnosis <= analysisYear)   

hivexpnat <- hivset %>% group_by(expgroup,yeardiagnosis) %>% 
  summarise(notifications = n()) %>% 
  ungroup() %>% 
  group_by(expgroup) %>% 
  mutate(totalnotifications = cumsum(notifications)) %>%
  ungroup() %>% 
  group_by(yeardiagnosis) %>% 
  mutate(propnotifications = notifications/sum(notifications)) %>%
  mutate(proptotalnotifications = totalnotifications/sum(totalnotifications)) %>% 
  filter(yeardiagnosis <= analysisYear)   

hivexpstate <- hivset %>% group_by(expgroup,state,yeardiagnosis) %>% 
  summarise(notifications = n()) %>% 
  ungroup() %>% 
  group_by(state,expgroup) %>%
  mutate(totalnotifications = cumsum(notifications)) %>%
  ungroup() %>% 
  group_by(state,yeardiagnosis) %>% 
  mutate(propnotifications = notifications/sum(notifications)) %>%
  mutate(proptotalnotifications = totalnotifications/sum(totalnotifications)) %>% 
  filter(yeardiagnosis <= analysisYear)   

### Annual results by population group

# Calculate the proportion of diagnoses by country of birth and indigenous 
# status. These are used for further calculations and estimates for the number
# of people living with diagnosed HIV in specific groups. 

# There is a large number of notifications with missing country of birth and
# indigenous status. Calculate overall proportion and known proportion.

hivcob <- hivset %>%
  group_by(yeardiagnosis, countrygroup) %>%
  summarise(notifications = n()) %>%
  ungroup() %>% 
  group_by(countrygroup) %>% 
  mutate(totalnotifications = cumsum(notifications)) %>%
  ungroup() %>%
  group_by(yeardiagnosis) %>% 
  mutate(propnotifications = notifications/sum(notifications)) %>%
  mutate(proptotalnotifications = totalnotifications/sum(totalnotifications)) %>% 
  filter(yeardiagnosis <= analysisYear)

# Now add known proportions
hivcobknown <- hivcob %>% 
  filter(!is.na(countrygroup)) %>%
  select(yeardiagnosis, countrygroup, notifications, totalnotifications) %>%
  group_by(yeardiagnosis) %>%
  mutate(propnotifications = notifications/sum(notifications)) %>%
  mutate(proptotalnotifications = totalnotifications/sum(totalnotifications)) 
  
hivcob$propknown <- NA
hivcob[!is.na(hivcob$countrygroup),]$propknown <- hivcobknown$propnotifications
hivcob[is.na(hivcob$countrygroup),]$propknown <- 0
hivcob$proptotalknown <- NA
hivcob[!is.na(hivcob$countrygroup),]$proptotalknown  <- hivcobknown$proptotalnotifications
hivcob[is.na(hivcob$countrygroup),]$proptotalknown <- 0

# Indigenous status
hivaborig <- hivset %>%
  group_by(yeardiagnosis, aboriggroup) %>%
  summarise(notifications = n()) %>%
  ungroup() %>% 
  group_by(aboriggroup) %>% 
  mutate(totalnotifications = cumsum(notifications)) %>%
  ungroup() %>%
  group_by(yeardiagnosis) %>% 
  mutate(propnotifications = notifications/sum(notifications)) %>%
  mutate(proptotalnotifications = totalnotifications/sum(totalnotifications)) %>% 
  filter(yeardiagnosis <= analysisYear)

# Now add known proportions
hivaborigknown <- hivaborig %>% 
  filter(!is.na(aboriggroup) & aboriggroup != "othercob") %>%
  select(yeardiagnosis, aboriggroup, notifications, totalnotifications) %>%
  group_by(yeardiagnosis) %>%
  mutate(propnotifications = notifications/sum(notifications))%>%
  mutate(proptotalnotifications = totalnotifications/sum(totalnotifications)) 

hivaborig$propknown <- NA
hivaborig[!is.na(hivaborig$aboriggroup) & hivaborig$aboriggroup != "othercob",]$propknown <- hivaborigknown$propnotifications
hivaborig[is.na(hivaborig$aboriggroup) | hivaborig$aboriggroup == "othercob",]$propknown <- 0
hivaborig$proptotalknown <- NA
hivaborig[!is.na(hivaborig$aboriggroup) & hivaborig$aboriggroup != "othercob",]$proptotalknown  <- hivaborigknown$proptotalnotifications
hivaborig[is.na(hivaborig$aboriggroup) | hivaborig$aboriggroup == "othercob",]$proptotalknown <- 0

### Overall annual results by gender
hivgender <- hivset %>% 
  group_by(yeardiagnosis, sex) %>% 
  summarise(notifications = n()) %>% 
  ungroup() %>% 
  group_by(sex) %>%
  mutate(totalnotifications  = cumsum(notifications)) %>% 
  filter(yeardiagnosis <= analysisYear)

# Create some useful diagnoses data plots
if (plots) {
  graphics.off()
  
  ### All notifications
  plotdiags1 <- ggplot(data = hivresults, 
                        aes(x = yeardiagnosis, y = notifications)) + 
    geom_line(size = 1.5) + ylab("Annual notifications") + xlab("Year") + theme_bw() + opts
  
  plotdiags2 <- ggplot(data = hivresults, 
                        aes(x = yeardiagnosis, y = totalnotifications)) + 
    geom_line(size = 1.5) + ylab("Cumulative notifications") + xlab("Year") + theme_bw() + opts
  
  # Save to file 
  png(paste(outputFolder, "/figures/all_notifications.png",sep =""), 
      width = 10, height = 5, units = "in", res = 300)
  grid.arrange(plotdiags1, plotdiags2, ncol = 2)
  dev.off()
  
  
  # States
  plotstates1 <- ggplot(data = hivstate, 
                        aes(x = yeardiagnosis, y = notifications, fill = state)) + 
    geom_area() + ylab("Annual notifications") + xlab("Year") + theme_bw() + opts
  plotstates2 <- ggplot(data = hivstate, 
                        aes(x = yeardiagnosis, y = propnotifications, fill = state)) + 
    geom_area() + ylab("Proportion annual notifications") + xlab("Year") + theme_bw() + opts
  
  # Save to file 
  png(paste(outputFolder, "/figures/state_notifications.png",sep =""), 
      width = 10, height = 5, units = "in", res = 300)
  grid.arrange(plotstates1, plotstates2, ncol = 2)
  dev.off()
  
  # Exposure
  plotexp1 <- ggplot(data = hivexpnat, 
                     aes(x = yeardiagnosis, y = notifications, fill = expgroup)) + 
    geom_area() + ylab("Annual notifications") + xlab("Year") + theme_bw() + opts
  plotexp2 <- ggplot(data = hivexpnat, 
                     aes(x = yeardiagnosis, y = propnotifications, fill = expgroup)) + 
    geom_area() + ylab("Proportion annual notifications") + xlab("Year") + theme_bw() + opts
  
  # Save to file
  png(paste(outputFolder, "/figures/exp_notifications.png",sep =""), 
      width = 10, height = 5, units = "in", res = 300)
  grid.arrange(plotexp1, plotexp2, ncol = 2)
  dev.off()
  
  # Country of birth
  plotcob1 <-ggplot(data = hivcob, 
                    aes(x = yeardiagnosis, y = notifications, fill = countrygroup)) + 
    geom_area() + ylab("Annual notifications") + xlab("Year") + theme_bw() + opts
  plotcob2 <-ggplot(data = hivcob, 
                    aes(x = yeardiagnosis, y = propknown, fill = countrygroup)) + 
    geom_area() + ylab("Proportion annual notifications") + xlab("Year") + theme_bw() + opts
  
  # Save to file
  png(paste(outputFolder, "/figures/cob_notifications.png",sep =""), 
      width = 10, height = 5, units = "in", res = 300)
  grid.arrange(plotcob1, plotcob2, ncol = 2)
  dev.off()
  
  # Indigenous status
  plotindig1 <- ggplot(data = hivaborig, 
                       aes(x = yeardiagnosis, y = notifications, fill = aboriggroup)) + 
    geom_area() + ylab("Annual notifications") + xlab("Year") + theme_bw() + opts
  plotindig2 <- ggplot(data = filter(hivaborig, aboriggroup == "indigenous"), 
         aes(x = yeardiagnosis, y = propknown)) + 
    geom_line() + ylim(c(0,0.2)) + ylab("Proportion notifications indigenous") + 
    xlab("Year") + theme_bw() + opts
  
  # Save to file
  png(paste(outputFolder, "/figures/indig_notifications.png",sep =""), 
      width = 10, height = 5, units = "in", res = 300)
  grid.arrange(plotindig1, plotindig2, ncol = 2)
  dev.off()
} 

```

Potentially impute country of birth and indigeous status

```{r imputation}
# 

# temp <- select(hivset, state, sex, cob, exposure, partnercob, 
#                previ_diag_overseas, country_prev_diag, yearhiv, 
#                aborig, countrygroup)
# 
# impcob <- lm(countrygroup ~ state + sex + cob + exposure + partnercob + 
#      previ_diag_overseas + country_prev_diag + yearhiv + aborig, 
#       data = temp)
# 
# predcob <- predict(impcob, temp)

```

Removal of duplicates .....

```{r removeduplicates}

# Days to ignore in duplicate calculations
ignore <- c(1,15) 

# Store number unique diagnoses cumulatively and annually. For annual unique 
# cases assume all the first years of disgnoses are unique. 

### Do calculations for all notifications first
doball <- select(hivset,dob,yeardiagnosis) # Overall
numberUniqueAll <- numUnique(doball, allyears, ignore)

# Store national results
hivresults$uniquecases <- numberUniqueAll

# Add variable for proportion unique - due to statistical calculations 
# proportion mybe slightly higher than one. In those cases round down to 1.
hivresults$propunique <- hivresults$uniquecases/hivresults$totalnotifications
hivresults[hivresults$propunique > 1,]$propunique <- 1

### Now do states and territories
states <- c("act","nsw","vic","qld","nt","wa","sa","tas")

hivstate$uniquecases <- rep(NA,nrow(hivstate))
hivstate$propunique <- rep(NA,nrow(hivstate))

for (ii in 1:length(states)) {
  # Dob vector
  dobtemp <- select(subhivset(hivset, region = states[ii]), dob, yeardiagnosis)
  
  # Calculate number unique
  numberUnique <- numUnique(dobtemp, unique(dobtemp$yeardiagnosis), ignore)
  
  # Store state results
  hivstate[hivstate$state == states[ii],]$uniquecases <- numberUnique
  
  # Replace proportion unique if using national estimates
  if (nationalUniques) {
    stateyears <- hivstate[hivstate$state == states[ii],]$yeardiagnosis
    hivstate[hivstate$state == states[ii],]$propunique <- 
      filter(hivresults, yeardiagnosis %in% stateyears)$propunique
  } 
}

# Calculate proportion unique if not doing national estimates
if (!nationalUniques) {
  hivstate$propunique <- hivstate$uniquecases/hivstate$totalnotifications
  hivstate[hivstate$propunique > 1,]$propunique <- 1
}

### Now do mode of exposure
modes <- c("msm", "pwid", "hetero", "otherexp", "unknown")

hivexpnat$uniquecases <- rep(NA,nrow(hivexpnat))
hivexpnat$propunique <- rep(NA,nrow(hivexpnat))

for (ii in 1:length(modes)) {
  # Dob vector
  dobtemp <- select(subhivset(hivset, mode = modes[ii]), dob, yeardiagnosis)
  dobtemp <- arrange(dobtemp, yeardiagnosis)
  
  # Calculate number unique
  numberUnique <- numUnique(dobtemp, unique(dobtemp$yeardiagnosis), ignore)
  
  # Store exposure results
  hivexpnat[hivexpnat$expgroup == modes[ii],]$uniquecases <- numberUnique
  
  # Replace proportion unique if using national estimates
  if (nationalUniques) {
    expyears <- hivexpnat[hivexpnat$expgroup == modes[ii],]$yeardiagnosis
    hivexpnat[hivexpnat$expgroup == modes[ii],]$propunique <- 
      filter(hivresults, yeardiagnosis %in% expyears)$propunique
  } 
}

# Calculate proportion unique if not doing national estimates
if (!nationalUniques) {
  hivexpnat$propunique <- hivexpnat$uniquecases/hivexpnat$totalnotifications
  hivexpnat[hivexpnat$propunique > 1,]$propunique <- 1
}

# We don't do this for country of birth or indigenous just using the proportions of
# notifications

### Now do genders
genders <- c("male", "female", "transgender", "unknown")
hivgender$propunique <- rep(NA,nrow(hivgender))

for (ii in 1:length(genders)) {
  # Use national estimates
  genyears <- hivgender[hivgender$sex == genders[ii],]$yeardiagnosis
  hivgender[hivgender$sex == genders[ii],]$propunique <- 
    filter(hivresults, yeardiagnosis %in% genyears)$propunique
  
}

# Plot if required

if (plots) {
  graphics.off()
  
  # State de-duplication by state
  uniqueState <- hivstate %>% group_by(yeardiagnosis) %>% summarise(total = sum(uniquecases))
  
  # Plot national notifications data raw and deduplicated
  uniqueplot1 <- ggplot(hivresults,aes(yeardiagnosis)) + theme_bw() +
    opts + xlim(c(startYear,analysisYear)) + ylim(c(0,NA)) + xlab(" Year") + 
    ylab("Number of notifications")
  uniqueplot1 <- uniqueplot1 + geom_line(aes(y = totalnotifications,color="All notifications")) + 
    geom_line(aes(y = uniquecases, color="Unique notifications")) + 
    theme(legend.direction="vertical") + theme(legend.title=element_blank())
  uniqueplot1 <- uniqueplot1 + geom_line(data = uniqueState, 
                                         aes(y = total, color="State notifications"))
  
  # Save to file
  png(paste(outputFolder, "/figures/unique_diagnoses.png",sep =""), 
      width = 5, height = 5, units = "in", res = 300)
  print(uniqueplot1)
  dev.off()
#   ggsave(png,paste(outputFolder, "/figures/unique_diagnoses.png",sep =""), 
#          width = 6*300, height = 5*300, res =300)
}

```

Sort out population movement rates

```{r migration}
# This chunk converts the ABS overseas and interste migration data into 
# population movement rates

# Load all the data sets we need - the ABS data is stored in a different folder
absFolder <- file.path(path.expand("~"), "Research","!Evaluation_Modelling","data")
 
absMigration <- read.csv(file.path(absFolder, "ABS_migration_clean.csv", 
                                sep =""),as.is = 1)
absDeparts <- read.csv(file.path(absFolder, "ABS_departures_clean.csv", 
                                sep =""),as.is = 1)
absInterstate <- read.csv(file.path(absFolder, "ABS_interstate_clean.csv", 
                                sep =""),as.is = 1)

### Depending on data used calculate departure rate for each state 

states <- c("nsw", "vic", "qld", "nt", "wa", "sa", "tas", "act", "all")
nstates <- length(states)
  
allPredicts <- data.frame(year = numeric(), 
                          state = character(),
                          rate = numeric(),
                          lower = numeric(),
                          upper = numeric())

if (permDeparts) {
  ### Use permanent departures
  absDeparts <- mutate(absDeparts, migrate = departures/erp)
  mrate <- absDeparts$migrate
  
  # mrate is missing a value for 1980 assume same value as 1981
  mrate <- c(mrate[1], mrate)
  
  # Fill in the state values
  
  for (ii in 1:nstates) {
    allPredicts <- rbind(allPredicts, data.frame(year = allyears, 
                                                 state = states[ii],
                                                 rate = mrate/2, 
                                                 lower = 0, 
                                                 upper = mrate))
  }
  
  # Store results in final data frame
  hivmigrate <- allPredicts
  
} else {
  ### Use state based NOM departures
  
  # Calculate migration rate overall and for each state
  absMigration <- mutate(absMigration, migrate = departures/erp)
  
  for (ii in 1:nstates) {
    mrate <- filter(absMigration, state == states[ii])
    
    # Now we need to fit and extrapolate for other years
    lmrate <- lm(migrate ~ year, data = mrate)
    expmrate <- predict(lmrate, data.frame(year = allyears),
                        level = 0.9, interval = "confidence")
    
    # Store extrapolated rate
    allPredicts <- rbind(allPredicts, data.frame(year = allyears, 
                                                 state = states[ii],
                                                 rate = expmrate[, 3]/2, #expmrate[, 1]
                                                 lower = 0, #expmrate[, 2],
                                                 upper = expmrate[, 3]))
    }
  
  # Store results in final data frame
  hivmigrate <- allPredicts
  
  # Plot what we have done if required
  if (plots) {
    graphics.off()
    
    # Plot the overseas migration data for each state
    mplot1 <- ggplot(data = absMigration, aes(x = year, y = migrate, colour = state)) +
      geom_line(size = 2) + ylim(c(0,0.02)) + 
      xlab("Year") + ylab("Overseas migration rate") + theme_bw() +
      opts
    
    # Plot fitted overseas migration data for each state
    mplot2 <- ggplot(data = hivmigrate, aes(x = year, y = rate, colour = state)) + 
      geom_line(data = absMigration, aes(y = migrate), size = 0.5, linetype = "dashed") + 
      geom_point(data = absMigration, aes(y = migrate), size = 3, shape = 18) + 
      geom_line(size = 1.2) + ylim(c(0,0.02)) +
      xlab("Year") + ylab("Overseas migration rate") + 
      ggtitle("Fitted annual migration rate") + theme_bw() +
      opts
    
    # Plot national overseas migration rate with uncertainty
    mplot3 <- ggplot(data = filter(hivmigrate, state == "all"), aes(x = year, y = rate)) +
      geom_line(color = "red") + 
      geom_line(aes(y = lower), linetype = "dashed", color = "blue") + 
      geom_line(aes(y = upper), linetype = "dashed", color = "blue") + 
      geom_point(data = filter(absMigration, state == "all"), 
                 aes(y = migrate), size = 2, color = "black") +
      ylim(c(0,0.02)) + xlab("Year") + ylab("Overseas migration rate") + 
      ggtitle("Fitted annual migration rate") + theme_bw() +
      opts
    
    # Save to file 
    png(paste(outputFolder, "/figures/prop_migrate.png",sep =""), 
        width = 15, height = 5, units = "in", res = 300)
    grid.arrange(mplot1, mplot2, mplot3, ncol = 3)
    dev.off()  
    }
  
}

### Calculate interstate rates - At this stage just calculate the best fit.
# Don't worry about upper and lower bounds.

# First estimate erp for each state

allinterstate <- data.frame(year = allyears)

for (ii in 1:nstates) {
  lmerp <- lm(erp ~ year, data = filter(absMigration, state == states[ii]))
  erpstate <- predict(lmerp, data.frame(year = allyears))
  
  # Store extrapolated population
  allinterstate[[states[ii]]] <- erpstate
}

hivinterstate <- gather(allinterstate, "state", "erp", 2:10)

# Calculate interstate ERP simply overall population minus state population
allerp <- filter(hivinterstate, state == "all")$erp

hivinterstate <- hivinterstate %>% 
  group_by(state) %>%
  mutate(intererp = allerp-erp)

# Calculate departure rate
hivinterstate$departures <- NA

for (ii in 1:nstates) {
  lmdepart <- lm(departures ~ year, data = filter(absInterstate, state == states[ii]))
  departstate <- predict(lmdepart, data.frame(year = allyears))
  
  # Store extrapolated population
  hivinterstate[hivinterstate$state == states[ii],]$departures <- departstate
}

hivinterstate <- mutate(hivinterstate,departrate = departures/erp) 

# Calculate arrival rate
hivinterstate$arrivals <- NA

for (ii in 1:nstates) {
  lmarrive <- lm(arrivals ~ year, data = filter(absInterstate, state == states[ii]))
  arrivestate <- predict(lmarrive, data.frame(year = allyears))
  
  # Store extrapolated population
  hivinterstate[hivinterstate$state == states[ii],]$arrivals <- arrivestate
}

hivinterstate <- mutate(hivinterstate,arriverate = arrivals/intererp) 

# As intererp is zero national set arriverate to departure rate for "all"
# Gives indication of rate people move interstate nationally
hivinterstate[hivinterstate$state == "all",]$arriverate <- 
  hivinterstate[hivinterstate$state == "all",]$departrate

```

Sort out deathrates

```{r deaths}
# To calculate the number of deaths each year we calculate an overall 
# deathrate with an uncertainty range. This is used to work out the number 
# of people diagnosed with HIV. 

# The estimate of the death rate uses a number of methods. Firstly uses the 
# 2003 linkage results and the number of known deaths to estimate the
# deathrate up to 2003. It then uses AHOD mortality rates from 2003.

# Load all the data sets we use for this estimate - use the parameter column as 
# row names for easier subsetting
hivparams <- read.csv(file.path(dataFolder, "individualHIVparameters.csv", 
                                sep =""),as.is = 1)
hivparams <- select(hivparams,parameter,value)
for (ii in 1:nrow(hivparams)) {
  assign(hivparams$parameter[ii],hivparams$value[ii])
}

# Load AHOD data to calculate mortality and do some simple cleaning
ahodData <- read.csv(file.path(dataFolder, 
                               paste("ahod", toString(analysisYear), 
                                     ".csv", sep = "")))

# Load backprojection estimates for comparison
# bpdeaths <- read.csv(file.path(dataFolder, "projectedDeaths.csv", 
#                                 sep =""),as.is = 1)

# Extract number of known deaths and store in a central data frame
hivdeaths <- hivdata %>% 
  filter(! is.na(yeardeath)) %>%
  group_by(yeardeath) %>% 
  summarise(number_deaths = n()) %>% 
  filter(yeardeath <= analysisYear)  

# Calculate sensitivity of recorded deaths based on linkage results
linkageFactor <- (linkedDeaths+notifiedDeaths)/notifiedDeaths
linkageFactorLower <- linkageFactor*(1-linkageSensitivity)
linkageFactorUpper <- linkageFactor*(1+linkageSensitivity)  

#  We don't need to adjust deaths for number of unique diagnoses as
# different dates of death should result in different people

# Set up linked deaths
hivdeaths$inflated_deaths <- hivdeaths$number_deaths * linkageFactor
hivdeaths$inflated_deaths_lower <- hivdeaths$number_deaths * linkageFactorLower
hivdeaths$inflated_deaths_upper <- hivdeaths$number_deaths * linkageFactorUpper

# No deaths in 1980 and 1982 so add this data manually to ensure everything lines up
hivdeaths <- rbind(hivdeaths,c(1980,0,0,0,0))
hivdeaths <- rbind(hivdeaths,c(1982,0,0,0,0))
hivdeaths <- arrange(hivdeaths,yeardeath)

# Now calculate mortality rate for linkage data ------------------------
cumdiagnoses <- hivresults$uniquecases #totalnotifications #uniquecases
deaths <- hivdeaths$inflated_deaths
deaths_min <- hivdeaths$inflated_deaths_lower
deaths_max <- hivdeaths$inflated_deaths_upper
anndiags <- c(cumdiagnoses[1],diff(cumdiagnoses))  # Annual diagnoses

# Calculate number living each year 
numliving <- rep(NA,length(anndiags))
numliving_min <- rep(NA,length(anndiags))
numliving_max <- rep(NA,length(anndiags))

numliving[1] <- anndiags[1]
numliving_min[1] <- anndiags[1]
numliving_max[1] <- anndiags[1]

allmigrate <- filter(hivmigrate, state == "all") # Overall migration rate for deaths estimate

for (ii in 2:length(anndiags)) {
  numliving[ii] <- numliving[ii-1] + anndiags[ii] - deaths[ii-1] 
   - numliving[ii-1] * allmigrate$rate[ii-1]
  numliving_min[ii] <- numliving_min[ii-1] + anndiags[ii] - deaths_max[ii-1]
   - numliving_min[ii-1] * allmigrate$upper[ii-1]
  numliving_max[ii] <- numliving_max[ii-1] + anndiags[ii] - deaths_min[ii-1]
   - numliving_max[ii-1] * allmigrate$lower[ii-1]
}

# Calculate mortality
linkageMortality <- deaths/numliving
linkageMortalityMin <- deaths_min/numliving_max
linkageMortalityMax <- deaths_max/numliving_min

#Append AHOD mortality ---------------------------------------

# Calculate crude death rate for each state and year - use 95% CI as the upper and lower bound

ahodDeaths <- ahodData %>% 
  group_by(state, year) %>%
  summarise(n = sum(n_id), 
            deaths = sum(n_death), 
            deathrate = unname(prop.test(sum(n_death), sum(n_id))$estimate), 
            lower = unname(prop.test(sum(n_death), sum(n_id))$conf.int[1]),
            upper = unname(prop.test(sum(n_death), sum(n_id))$conf.int[2])) %>%
  filter(year > 2003)


# First find index corresponding to year of linkage 
indexLinkage <- max(seq(along = min(hivresults$yeardiagnosis):linkageYear))

# Save in deathrate
deathrate <- rep(NA,length(allyears))
deathrate_min <- rep(NA,length(allyears))
deathrate_max <- rep(NA,length(allyears))

# ahodMortality

deathrate[1:indexLinkage] <- linkageMortality[1:indexLinkage]
deathrate[(indexLinkage+1):length(deathrate)] <- filter(ahodDeaths, 
                                                        state == "all")$deathrate # 
# ahodMortalityLower

deathrate_min[1:indexLinkage] <- linkageMortalityMin[1:indexLinkage]
deathrate_min[(indexLinkage+1):length(deathrate)] <- filter(ahodDeaths, 
                                                        state == "all")$lower # 
# ahodMortalityUpper

deathrate_max[1:indexLinkage] <- linkageMortalityMax[1:indexLinkage]
deathrate_max[(indexLinkage+1):length(deathrate)] <- filter(ahodDeaths, 
                                                        state == "all")$upper # 

# Store final death rate
hivdeathrate <- data.frame(year = allyears, deathrate = deathrate, 
                           deathrate_min = deathrate_min, 
                           deathrate_max = deathrate_max)

# Store national results
hivresults$osrate <- allmigrate$rate
hivresults$oslower <- allmigrate$lower
hivresults$osupper <- allmigrate$upper

hivresults$deathslinked <- deaths
hivresults$deathslower <- deaths_min
hivresults$deathsupper <- deaths_max

hivresults$deathrate <- deathrate
hivresults$drlower <- deathrate_min
hivresults$drupper <- deathrate_max

# Create a HIV deaths dataframe if we are saving results for other calculations
if (saveResults) {
  # Directory and file name
  saveString <- file.path(outputFolder, paste("HIVresults-", 
                                              toString(analysisYear), sep = ""))
  
  # Write to csv
  write.csv(hivresults, file = paste(saveString, ".csv", sep =""), 
            row.names = FALSE)

  # Save as R object
  save(hivresults, file = paste(saveString, ".rda", sep =""))
}


# Plot what we have done if required
if (plots) {
  graphics.off()
  
  # Plot the deathrate
  dplot1 <- ggplot(data = hivdeathrate, aes(x = year, y = deathrate)) +
    geom_line(size = 1.25, color = "blue") + ylim(0,NA) + 
    xlab("Year") + ylab("Annual death rate") + theme_bw() +
    opts
  
  dplot2 <- ggplot(data = hivdeathrate, aes(x = year, y = deathrate)) +
    geom_line(size = 1.25, color = "blue") + ylim(0,0.025) + xlim(2000, NA) +
    geom_line(aes(y = deathrate_min), size = 1.25, color = "red") + 
    geom_line(aes(y = deathrate_max), size = 1.25, color = "red") +
    xlab("Year") + ylab("Annual death rate") + theme_bw() +
    opts
  
  # Save to file 
  png(paste(outputFolder, "/figures/death_rate.png",sep =""), 
      width = 15, height = 5, units = "in", res = 300)
  grid.arrange(dplot1, dplot2, ncol = 2)
  dev.off() 
}

```


## Number living with diagnosed HIV

```{r livingdiags}
# This chuck now estimates the number of people living with diagnosed HIV. 

# Initialize final results data frame
hivdiagnosed <- data.frame(stage = character(), 
                         year = double(),
                         population = character(),
                         estimate = double(),
                         lower = double(),
                         upper = double())

### First calculate overall number

# Setup all our vectors - first by filling in missing cumulative diagnoses
filledDiagnoses <- FillMissing(allyears, hivresults$yeardiagnosis, 
                                 hivresults$uniquecases)

cumDiagnoses <- filledDiagnoses$value

# All death rates used for all  populations
deathRate <- hivdeathrate$deathrate
deathRateMin <- hivdeathrate$deathrate_min
deathRateMax <- hivdeathrate$deathrate_max

# National migration rates
migrationRate <- filter(hivmigrate, state == "all")$rate
migrationRateMin <- filter(hivmigrate, state == "all")$lower
migrationRateMax <- filter(hivmigrate, state == "all")$upper

# Calculate number living with diagnosed HIV and range
pldhivAll <- LivingDiagnosed(cumDiagnoses, deathRate, migrationRate)

# Use max rates for min estimate because they are removal rates and vice versa
pldhivAllMin <- LivingDiagnosed(cumDiagnoses, deathRateMax, migrationRateMax) 
pldhivAllMax <- LivingDiagnosed(cumDiagnoses, deathRateMin, migrationRateMin) 

# Store results
nyears <- length(allyears)
hivdiagnosed <- rbind(hivdiagnosed,data_frame(stage = "pldhiv", 
                            year = allyears, 
                            population = "all", 
                            value = pldhivAll,
                            lower = pldhivAllMin,
                            upper = pldhivAllMax))

### Now do state based PLDHIV

for (ii in 1:(nstates-1)) {
  stateyears <- filter(hivstate, state == states[ii])$yeardiagnosis
  
  if (nationalUniques) {
    statediags <- filter(hivstate, state == states[ii])$totalnotifications *
      filter(hivstate, state == states[ii])$propunique
  } else {
    statediags <- filter(hivstate, state == states[ii])$uniquecases
  }
    
  fillStateDiags <- FillMissing(allyears, stateyears, statediags)  
  cumStateDiags <- fillStateDiags$value
  
  # State migration rates
  migStateRate <- filter(hivmigrate, state == states[ii])$rate
  migStateRateMin <- filter(hivmigrate, state == states[ii])$lower
  migStateRateMax <- filter(hivmigrate, state == states[ii])$upper
  
  # State departures
  depStateRate <- filter(hivinterstate, state == states[ii])$departrate
  
  # State arrivals
  arrStateRate <- filter(hivinterstate, state == states[ii])$arriverate
  
  # Do the state calculation and range
  pldhivState <- LivingDiagnosed(cumStateDiags, deathRate, migStateRate,
                                 arrStateRate, depStateRate, pldhivAll)
  
  pldhivStateMin <- LivingDiagnosed(cumStateDiags, deathRateMax, migStateRateMax,
                                 arrStateRate, depStateRate, pldhivAll)
  
  pldhivStateMax <- LivingDiagnosed(cumStateDiags, deathRateMin, migStateRateMin,
                                 arrStateRate, depStateRate, pldhivAll)
  
  # Store the state results
  hivdiagnosed <- rbind(hivdiagnosed, data_frame(stage = "pldhiv", 
                            year = allyears, 
                            population = states[ii], 
                            value = pldhivState,
                            lower = pldhivStateMin,
                            upper = pldhivStateMax))
}

### Now do exposure based PLHIV

modes <- c("msm", "pwid", "hetero", "otherexp", "unknown")
nmodes <- length(modes)

for (ii in 1:nmodes) {
  expyears <- filter(hivexpnat, expgroup == modes[ii])$yeardiagnosis
  
  if (nationalUniques) {
    expdiags <- filter(hivexpnat, expgroup == modes[ii])$totalnotifications *
      filter(hivexpnat, expgroup == modes[ii])$propunique
  } else {
    expdiags <- filter(hivexpnat, expgroup == modes[ii])$uniquecases
  }
    
  fillExpDiags <- FillMissing(allyears, expyears, expdiags)  
  cumExpDiags <- fillExpDiags$value
  
  # Exp migration rates, death rates, assumed to be same overall
  
  # Do the Exp calculation and range
  pldhivExp <- LivingDiagnosed(cumExpDiags, deathRate, migrationRate)
  
  pldhivExpMin <- LivingDiagnosed(cumExpDiags, deathRateMax, migrationRateMax)
  pldhivExpMax <- LivingDiagnosed(cumExpDiags, deathRateMin, migrationRateMin)
  
  # Store the state results
  hivdiagnosed <- rbind(hivdiagnosed, data_frame(stage = "pldhiv", 
                            year = allyears, 
                            population = modes[ii], 
                            value = pldhivExp,
                            lower = pldhivExpMin,
                            upper = pldhivExpMax))
}

### Remove unknowns by redistributing to known exposure groups in proportion
keygroups <- c("msm", "pwid", "hetero", "otherexp")

# Calculate proportion known in each category
propExpDiags <- hivdiagnosed %>% 
  filter(population %in% keygroups) %>%
  group_by(year) %>%
  mutate(totalval = sum(value), 
         propval = value/totalval) %>%
  select(-stage, -totalval)

# Calculate the number unknown and the proportional increase
numUnknown <- hivdiagnosed %>% 
  filter(population == "unknown") %>%
  select(year, value)

numUnknown$msm <- filter(propExpDiags, population == "msm")$propval * numUnknown$value
numUnknown$pwid <- filter(propExpDiags, population == "pwid")$propval * numUnknown$value 
numUnknown$hetero <- filter(propExpDiags, population == "hetero")$propval * numUnknown$value 
numUnknown$otherexp <- filter(propExpDiags, population == "otherexp")$propval * numUnknown$value 

# Make into long format
numUnknown <- numUnknown %>%
  select(-value) %>%
  gather("mode", "number", 2:5)


# Update hivdiagnosed
for (ii in seq(along = keygroups)) {
     tempdf <- filter(hivdiagnosed, population == keygroups[ii])
     proplwr <- tempdf$lower/tempdf$value
     propupr <- tempdf$upper/tempdf$value
     
     hivdiagnosed[hivdiagnosed$population == keygroups[ii],]$value <- 
       hivdiagnosed[hivdiagnosed$population == keygroups[ii],]$value + 
       filter(numUnknown, mode == keygroups[ii])$number
     
     hivdiagnosed[hivdiagnosed$population == keygroups[ii],]$lower <- 
       hivdiagnosed[hivdiagnosed$population == keygroups[ii],]$value * proplwr
      
     hivdiagnosed[hivdiagnosed$population == keygroups[ii],]$upper <- 
       hivdiagnosed[hivdiagnosed$population == keygroups[ii],]$value * propupr
}    
   
# Remove unknown & fix up modes
hivdiagnosed <- filter(hivdiagnosed, population != "unknown")
modes <- keygroups
nmodes <- length(modes)
  
### Now do population based PLDHIV
pops <- c("non-indigenous", "indigenous", "bornssa", "bornsea","othercob")
npops <- length(pops)

for (ii in 1:npops) {
  # Set up cumDiags for each population use the overall cumdiagnoses 
  # For Australian born we have to also consider indigenous status
  if (pops[ii] == "non-indigenous") {
    # Non-indigenous estimates
    popdiags <- filter(hivcob, countrygroup == "australia")$proptotalknown
    popyears <- filter(hivcob, countrygroup == "australia")$yeardiagnosis
    fillPopDiags <- FillMissing(allyears, popyears, popdiags)
  
    if (indigKnown) {
      # If just using known subtract from australian born diagnoses
      aborigdiags <- filter(hivaborig, aboriggroup == "indigenous")$totalnotifications
      aborigyears <- filter(hivaborig, aboriggroup == "indigenous")$yeardiagnosis
      
      fillAborigDiags <- FillMissing(allyears, aborigyears, aborigdiags)
      cumPopDiags <- cumDiagnoses * fillPopDiags$value - fillAborigDiags$value
    } else {
      # Use proportional estimate
      aborigdiags <- filter(hivaborig, aboriggroup == "non-indigenous")$proptotalknown
      aborigyears <- filter(hivaborig, aboriggroup == "non-indigenous")$yeardiagnosis
      
      fillAborigDiags <- FillMissing(allyears, aborigyears, aborigdiags)
      cumPopDiags <- cumDiagnoses * fillPopDiags$value * fillAborigDiags$value
    }
      
  } else if (pops[ii] == "indigenous") {
    # Indigenous estimates
    if (indigKnown) {
      # Use known indigenous diagnoses
      aborigdiags <- filter(hivaborig, aboriggroup == "indigenous")$totalnotifications
      aborigyears <- filter(hivaborig, aboriggroup == "indigenous")$yeardiagnosis
      
      fillAborigDiags <- FillMissing(allyears, aborigyears, aborigdiags)
      cumPopDiags <- fillAborigDiags$value
      
    } else {
      # Use proportionally known diagnoses
      popdiags <- filter(hivcob, countrygroup == "australia")$proptotalknown
      popyears <- filter(hivcob, countrygroup == "australia")$yeardiagnosis
      
      aborigdiags <- filter(hivaborig, aboriggroup == "indigenous")$proptotalknown
      aborigyears <- filter(hivaborig, aboriggroup == "indigenous")$yeardiagnosis
      
      fillPopDiags <- FillMissing(allyears, popyears, popdiags)
      fillAborigDiags <- FillMissing(allyears, aborigyears, aborigdiags)
      
      cumPopDiags <- cumDiagnoses * fillPopDiags$value * fillAborigDiags$value
    }
    
  } else {
    popdiags <- filter(hivcob, countrygroup == pops[ii])$proptotalknown
    popyears <- filter(hivcob, countrygroup == pops[ii])$yeardiagnosis
    
    fillPopDiags <- FillMissing(allyears, popyears, popdiags)
    cumPopDiags <- cumDiagnoses * fillPopDiags$value
  }
  
  # Exp migration rates, death rates, assumed to be same overall
  
  # Do the Pop calculation and range - if indigenous adjust mortality rate 
  # appropriately
  mortalityMultiplier <- ifelse(pops[ii] == "indigenous", aborigMortality, 1)
  mortalityMultiplierMin <- ifelse(pops[ii] == "indigenous", aborigMortalityMin, 1)
  mortalityMultiplierMax <- ifelse(pops[ii] == "indigenous", aborigMortalityMax, 1)
  
  # If non-Indigenous then no need to adjust dethar 
  pldhivPop <- LivingDiagnosed(cumPopDiags, mortalityMultiplier * deathRate, migrationRate)
  
  pldhivPopMin <- LivingDiagnosed(cumPopDiags, mortalityMultiplierMin * deathRateMax, migrationRateMax)
  pldhivPopMax <- LivingDiagnosed(cumPopDiags, mortalityMultiplierMax * deathRateMin, migrationRateMin)
  
  
  # Store the population results
  hivdiagnosed <- rbind(hivdiagnosed, data_frame(stage = "pldhiv", 
                            year = allyears, 
                            population = pops[ii], 
                            value = pldhivPop,
                            lower = pldhivPopMin,
                            upper = pldhivPopMax))
}

### Now do gender based PLDHIV
# Quick and dirty at the moment for a separate calculation
hivDiagGender <- data.frame(stage = character(), 
                         year = double(),
                         population = character(),
                         estimate = double(),
                         lower = double(),
                         upper = double())

genders <- c("male", "female", "transgender", "unknown")
ngenders <- length(genders)

for (ii in 1:ngenders) {
  genyears <- filter(hivgender, sex == genders[ii])$yeardiagnosis
  gendiags <- filter(hivgender, sex == genders[ii])$totalnotifications * 
    filter(hivgender, sex == genders[ii])$propunique
    
  fillGenDiags <- FillMissing(allyears, genyears, gendiags)  
  cumGenDiags <- fillGenDiags$value
  
  # Exp migration rates, death rates, assumed to be same overall
  
  # Do the Exp calculation and range
  pldhivGen <- LivingDiagnosed(cumGenDiags, deathRate, migrationRate)
  
  pldhivGenMin <- LivingDiagnosed(cumGenDiags, deathRateMax, migrationRateMax)
  pldhivGenMax <- LivingDiagnosed(cumGenDiags, deathRateMin, migrationRateMin)
  
  # Store the state results
  hivDiagGender <- rbind(hivDiagGender, data_frame(stage = "pldhiv", 
                            year = allyears, 
                            population = genders[ii], 
                            value = pldhivGen,
                            lower = pldhivGenMin,
                            upper = pldhivGenMax))
}

### Finally bind to overall results
if (bindCascade) {
  hivcascade <- rbind(hivcascade,hivdiagnosed)
}

```

## Number undiagnosed

```{r undiagnosed}
# This chuck now estimates the number of people living with diagnosed HIV. 

# Initialize final results data frame
hivundiag <- data.frame(stage = character(), 
                         year = double(),
                         population = character(),
                         estimate = double(),
                         lower = double(),
                         upper = double())

# Read in back projected undiagnosed estimates
propUndiagnosed <- read.csv(file.path(dataFolder, 
                                      paste("projectedUndiagnosed", 
                                            toString(analysisYear), 
                                            ".csv", sep = "")),as.is = 1)

# Only keep required years
propUndiagnosed <- filter(propUndiagnosed, year %in% allyears) 

if (useOldpropundiagnosed) {
  # Replace 2013 & 2014 estimates with COUNT and 2014 ASR supplement non-MSM estimates
  # COUNT: 8.9% (95% CI: 5.8-13.5%)
  # Non-MSM: 20% (range 12-23%) across states
  hardcodeYears <- analysisYear - 2013 + 1
  hardcode <- c(0.09, 0.06, 0.14, 0.2, 0.15, 0.25)
 
  propUndiagnosed[propUndiagnosed$year >= 2013,2:7] <-  matrix(hardcode, 
    nrow = hardcodeYears, ncol = length(hardcode), byrow = TRUE)
}

# Estimate proportion MSM and non-MSM for weighting
propMSM <- filter(hivexpnat, expgroup == "msm")$proptotalnotifications
propHetero <- filter(hivexpnat, expgroup == "hetero")$proptotalnotifications
propPwid <- filter(hivexpnat, expgroup == "pwid")$proptotalnotifications
propOther <- filter(hivexpnat, expgroup == "otherexp")$proptotalnotifications

# Fill in missing data years - simply assume proportion is same previous year
propMSM <- FillMissing(allyears, filter(hivexpnat, expgroup == "msm")$yeardiagnosis, propMSM)
propHetero <- FillMissing(allyears, filter(hivexpnat, expgroup == "hetero")$yeardiagnosis, propHetero)
propPwid <- FillMissing(allyears, filter(hivexpnat, expgroup == "pwid")$yeardiagnosis, propPwid)
propOther <- FillMissing(allyears, filter(hivexpnat, expgroup == "otherexp")$yeardiagnosis, propOther)

# Estimate overall non-MSM undiagnosed proportion
propNonMSM <- 1 - propMSM$value

# Weighted undiagnosed proportion
undiagAll <- propMSM$value * propUndiagnosed$msm_best + 
            propNonMSM * propUndiagnosed$non_msm_best
# undiagAllMin <- apply(rbind(propUndiagnosed$msm_lower, propUndiagnosed$non_msm_lower),2,min)                
# undiagAllMax <- apply(rbind(propUndiagnosed$msm_upper, propUndiagnosed$non_msm_upper),2,max)
undiagAllMin <- propMSM$value * propUndiagnosed$msm_lower + 
            propNonMSM * propUndiagnosed$non_msm_lower
undiagAllMax <- propMSM$value * propUndiagnosed$msm_upper + 
            propNonMSM * propUndiagnosed$non_msm_upper

### Now estimate number of people living with HIV overall
pldhivTemp <- filter(hivdiagnosed, stage == "pldhiv" & population == "all")
infectedAll <- pldhivTemp$value/(1 - undiagAll)
infectedAllMin <- pldhivTemp$lower/(1 - undiagAllMin)
infectedAllMax <- pldhivTemp$upper/(1 - undiagAllMax)

# Store overall results
hivundiag <- rbind(hivundiag, data_frame(stage = "infected", 
                            year = allyears, 
                            population = "all", 
                            value = infectedAll,
                            lower = infectedAllMin,
                            upper = infectedAllMax))

### Now calculate undiagnosed for each state
for (ii in 1:(nstates-1)) {
  pldhivTemp <- filter(hivdiagnosed, stage == "pldhiv" & population == states[ii])
  infectedState <- pldhivTemp$value/(1 - undiagAll)
  infectedStateMin <- pldhivTemp$lower/(1 - undiagAllMin)
  infectedStateMax <- pldhivTemp$upper/(1 - undiagAllMax)
  
  # Store results 
  hivundiag <- rbind(hivundiag,data_frame(stage = "infected", 
                            year = allyears, 
                            population = states[ii], 
                            value = infectedState,
                            lower = infectedStateMin,
                            upper = infectedStateMax))
}

### Now calculate for each exposure group

for (ii in 1:nmodes) {
  pldhivTemp <- filter(hivdiagnosed, stage == "pldhiv" & population == modes[ii])
  
  if (modes[ii] == "msm") {
    infectedExp <- pldhivTemp$value/(1 - propUndiagnosed$msm_best)
    infectedExpMin <- pldhivTemp$lower/(1 - propUndiagnosed$msm_lower)
    infectedExpMax <- pldhivTemp$upper/(1 - propUndiagnosed$msm_upper)
  } else {
    infectedExp <- pldhivTemp$value/(1 - propUndiagnosed$non_msm_best)
    infectedExpMin <- pldhivTemp$lower/(1 - propUndiagnosed$non_msm_lower)
    infectedExpMax <- pldhivTemp$upper/(1 - propUndiagnosed$non_msm_upper)
    
  }
  
  # Store results 
  hivundiag <- rbind(hivundiag,data_frame(stage = "infected", 
                                          year = allyears, 
                                          population = modes[ii],  
                                          value = infectedExp,
                                          lower = infectedExpMin,
                                          upper = infectedExpMax))
}               

### Now calculate for each population group
for (ii in 1:npops) {
  pldhivTemp <- filter(hivdiagnosed, stage == "pldhiv" & population == pops[ii])
  
  # Use overall undiagnosed proportion for non-indigenous and other cob. 
  # For indigenous, bornssa, born sea use non_msm undiagnosed proportion
  if (pops[ii] == "non-indigenous" | pops[ii] == "othercob") {
    infectedPop <- pldhivTemp$value/(1 - undiagAll)
    infectedPopMin <- pldhivTemp$lower/(1 - undiagAllMin)
    infectedPopMax <- pldhivTemp$upper/(1 - undiagAllMax)
  } else {
    infectedPop <- pldhivTemp$value/(1 - propUndiagnosed$non_msm_best)
    infectedPopMin <- pldhivTemp$lower/(1 - propUndiagnosed$non_msm_lower)
    infectedPopMax <- pldhivTemp$upper/(1 - propUndiagnosed$non_msm_upper)
  }
  
  # Store results 
  hivundiag <- rbind(hivundiag,data_frame(stage = "infected", 
                                          year = allyears, 
                                          population = pops[ii], 
                                          value = infectedPop,
                                          lower = infectedPopMin,
                                          upper = infectedPopMax))
}

### Now calculate for each gender
hivGenUndiag <- data.frame(stage = character(), 
                         year = double(),
                         population = character(),
                         estimate = double(),
                         lower = double(),
                         upper = double())

for (ii in 1:ngenders) {
  pldhivTemp <- filter(hivDiagGender, stage == "pldhiv" & population == genders[ii])
  
  # Use overall undiagnosed proportion for non-indigenous and other cob. 
  # For indigenous, bornssa, born sea use non_msm undiagnosed proportion
#   if (genders[ii] == "male") {
    infectedPop <- pldhivTemp$value/(1 - undiagAll)
    infectedPopMin <- pldhivTemp$lower/(1 - undiagAllMin)
    infectedPopMax <- pldhivTemp$upper/(1 - undiagAllMax)
#   } else {
#     infectedPop <- pldhivTemp$value/(1 - propUndiagnosed$non_msm_best)
#     infectedPopMin <- pldhivTemp$lower/(1 - propUndiagnosed$non_msm_lower)
#     infectedPopMax <- pldhivTemp$upper/(1 - propUndiagnosed$non_msm_upper)
#   }
  
  # Store results 
  hivGenUndiag <- rbind(hivGenUndiag, data_frame(stage = "infected", 
                                          year = allyears, 
                                          population = genders[ii], 
                                          value = infectedPop,
                                          lower = infectedPopMin,
                                          upper = infectedPopMax))
}

# Merged with gender PLDHIV and extract 2014 results
genderTemp <- rbind(hivGenUndiag,hivDiagGender)
genderTemp <- filter(genderTemp, year == 2014)

# Write to file for Skye



### Finally bind to overall results
if (bindCascade) {
  hivcascade <- rbind(hivcascade,hivundiag)
}

```


## Number linked to care

```{r linked}
# Now estimate the number living with diagnosesd HIV who have been linked 
# to care

# Initialize final results data frame
hivlinkcare <- data.frame(stage = character(), 
                         year = double(),
                         population = character(),
                         estimate = double(),
                         lower = double(),
                         upper = double())

### Overall annual results
hivlinkedAll <- hivset %>% 
  group_by(yeardiagnosis) %>% 
  filter(linked == "yes") %>%
  summarise(linked = n()) %>% 
  mutate(totallinked  = cumsum(linked)) %>% 
  filter(yeardiagnosis <= analysisYear) 

# Manually insert first two years as they are missing
hivlinkedAll <- rbind(hivlinkedAll, c(1980, 0, 0))
hivlinkedAll <- rbind(hivlinkedAll, c(1981, 0, 0))
hivlinkedAll <- arrange(hivlinkedAll, yeardiagnosis)

# Calculate number linked to care using national death rates and migration rates
cumLinked <- hivlinkedAll$totallinked
linkedAll <- LivingDiagnosed(cumLinked, deathRate, migrationRate)
linkedAllMin <- LivingDiagnosed(cumLinked, deathRateMax, migrationRateMax)
linkedAllMax <- LivingDiagnosed(cumLinked, deathRateMin, migrationRateMin)

# ISSUE: Number linked to care with above methodology seems too low. An 
# An alternative is to look at the proportion linked each year.
uniqueDiags <- c(hivresults$uniquecases[1], diff(hivresults$uniquecases))
proplinked <- hivlinkedAll$linked/uniqueDiags
propl <- data.frame(year = allyears, proportion = proplinked)
lmlinked <- lm(proportion ~ year, data = filter(propl, year > 2000))
predictlinked <- predict(lmlinked, data.frame(year = allyears))

# Some basic tests
# LivingDiagnosed(cumsum(uniqueDiags * predictlinked),deathRate, migrationRate)
# LivingDiagnosed(cumsum(uniqueDiags * predictlinked),deathRate, rep(0,length(migrationRate)))

hivlinkcare <- rbind(hivlinkcare, data_frame(stage = "linked", 
                            year = allyears, 
                            population = "all", 
                            value = linkedAll,
                            lower = linkedAllMin,
                            upper = linkedAllMax))


# Create a plot to show the fitting of the proportion linked 
if (plots) {
  plotData <- data.frame(year = allyears, 
                       proportion = proplinked, 
                       prediction = predictlinked)
  
  plplot <- ggplot(data = plotData,aes(x = year, y = proportion)) + geom_line() + 
    geom_line(aes(y = predictlinked), color  = "blue") + 
    theme_bw() + opts + ylim(c(0,NA)) + xlab("Year") + 
    ylab("Proportion annual notifications linked")
    
  # Print figures  
  png(paste(outputFolder, "/figures/prop_linked.png",sep =""), 
      width = 5, height = 5, units = "in", res = 300)
  print(plplot)
  dev.off()
}

### State calculations
hivlinkedState <- hivset %>% group_by(state,yeardiagnosis) %>% 
  filter(linked == "yes") %>%
  summarise(linked = n()) %>% 
  mutate(totallinked = cumsum(linked)) %>%
  filter(yeardiagnosis <= analysisYear) 

for (ii in 1:(nstates - 1)) {
  templinked <- filter(hivlinkedState, state == states[ii])
  templinked <- FillMissing(allyears, templinked$yeardiagnosis, templinked$totallinked)
  
  cumlinked <- templinked$value
  
  # State migration rates
  migStateRate <- filter(hivmigrate, state == states[ii])$rate
  migStateRateMin <- filter(hivmigrate, state == states[ii])$lower
  migStateRateMax <- filter(hivmigrate, state == states[ii])$upper
  
  # State departures
  depStateRate <- filter(hivinterstate, state == states[ii])$departrate
  
  # State arrivals
  arrStateRate <- filter(hivinterstate, state == states[ii])$arriverate
  
  # Do the state calculation and range
  linkedState <- LivingDiagnosed(cumlinked, deathRate, migStateRate,
                                 arrStateRate, depStateRate, pldhivAll)
  
  linkedStateMin <- LivingDiagnosed(cumlinked, deathRateMax, migStateRateMax,
                                 arrStateRate, depStateRate, pldhivAll)
  
  linkedStateMax <- LivingDiagnosed(cumlinked, deathRateMin, migStateRateMin,
                                 arrStateRate, depStateRate, pldhivAll)  
  
  # Store state results 
  hivlinkcare <- rbind(hivlinkcare, data_frame(stage = "linked", 
                            year = allyears, 
                            population = states[ii], 
                            value = linkedState,
                            lower = linkedStateMin,
                            upper = linkedStateMax))
  
}

### Exposure mode calculations  
hivlinkedExp <- hivset %>% group_by(expgroup,yeardiagnosis) %>% 
  filter(!is.na(cd4count)) %>%
  summarise(linked = n()) %>% 
  mutate(totallinked = cumsum(linked)) %>%
  filter(yeardiagnosis <= analysisYear) 


for (ii in 1:nmodes) {
  templinked <- filter(hivlinkedExp, expgroup == modes[ii])
  templinked <- FillMissing(allyears, templinked$yeardiagnosis, templinked$totallinked)
  
  cumlinked <- templinked$value
  
  # Exp migration rates, death rates, assumed to be same overall
  
  # Do the Exp calculation and range
  linkedExp <- LivingDiagnosed(cumlinked, deathRate, migrationRate)
  
  linkedExpMin <- LivingDiagnosed(cumlinked, deathRateMax, migrationRateMax)
  linkedExpMax <- LivingDiagnosed(cumlinked, deathRateMin, migrationRateMin)
  
  # Store the state results
  hivlinkcare <- rbind(hivlinkcare, data_frame(stage = "linked", 
                            year = allyears, 
                            population = modes[ii], 
                            value = linkedExp,
                            lower = linkedExpMin,
                            upper = linkedExpMax))
}

# Finally bind to overall results
if (bindCascade) {
  hivcascade <- rbind(hivcascade, hivlinkcare)
}

```

## Number taking ART

```{r treatment}
# Calculate the number taking ART during the year. This uses a mixture of 
# data sets as the Prospection data is only available for 2013-2014. Unlike
# the stages based on the number living with diagnosed HIV we only estimate 
# the number on treatment in the last 10 years due to a lack of data. 
# (maybe should do this for all or have analysis start year???) 

# Load all the data we need
# s100data <- read.csv(file.path(dataFolder, "s100_treatment_costs.csv"))
ahodART <- read.csv(file.path(dataFolder, "AHOD_ART_estimates.csv"))
prospectionData <- read.csv(file.path(dataFolder, paste("pharmdash_HIVpatients", 
                                      toString(analysisYear), 
                                      ".csv", sep = "")), as.is = c(1,2))

# Use the AHOD ART data to estimate a trend for back projection

# First simplify column names
colnames(ahodART) <- c("year", "numART")

# Create new varaible showing the relative change in ART numbers versus 2013. 
artBase <- filter(ahodART, year == 2013)$numART
ahodART$relative <- ahodART$numART/artBase

# Hardcoded uncertainty for the time being
# hivtreated$lower <- 0.95 * hivtreated$value
# hivtreated$upper <- 1.05 * hivtreated$value

# Sort out years for analysis
firstYear <- 2003
treatyears <- firstYear:2013
treatTrend <- filter(ahodART, year %in% treatyears)$relative

# Tidy up the prospection data
hivtreated <- prospectionData %>%
  filter(gender == "all") %>%
  select(-gender) 

yearNames <- strsplit(toString(2013:analysisYear), ", ")[[1]]

colnames(hivtreated) <- c("population",yearNames)
hivtreated <- gather(hivtreated,"year","value", 2:ncol(hivtreated))
hivtreated$year <- as.numeric(as.character(hivtreated$year))

# Uncertainty for Prospection data. 
hivtreated$lower <- 0.9 * hivtreated$value
hivtreated$upper <- 1.1 * hivtreated$value

### Now use the relative rates to calculate number on treatment

states <- c("nsw", "vic", "qld", "nt",  "wa",  "sa",  "tas", "act", "all")
nstates <- length(states)

# Add stage column
hivtreated$stage <- "numART"

# Loop through all the states and populations and calculate number on treatment
# since 2003
for (ii in 1:nstates) {
  # Extract 2013 data 
  treat2013 <- filter(hivtreated, year == 2013 & population == states[ii])
  
  # Calculate estimates and ranges
  tempfit <- treatTrend * treat2013$value
  templwr <- treat2013$lower * treatTrend
  tempupr <- treat2013$upper * treatTrend
  
  # Create a data frame 
  tempdf <- data_frame(population = states[ii], year = treatyears,
                       value = tempfit, lower = templwr, upper = tempupr, 
                       stage = "numART")
  
  # Append data prior to 2013
  hivtreated <- rbind(hivtreated, filter(tempdf, year < 2013))
}

# Order by state and year
hivtreated <- arrange(hivtreated, population, year)

# If analysis year is before current year
hivtreated <- filter(hivtreated, year <= analysisYear)

# Finally bind to overall results
if (bindCascade) {
  hivcascade <- rbind(hivcascade, hivtreated)
}

# Do some plots if required
if (plots) {
  tplot1 <- ggplot(data = relTreat, aes(x = year, y = fit)) + 
    geom_point(data = s100data, aes(x = year, y =  relative), color = "black", size = 4) + 
    geom_line(color = "red") +
    geom_line(aes(y = lwr), color = "blue", linetype = "dashed") +
    geom_line(aes(y = upr), color = "blue", linetype = "dashed") +
    scale_x_continuous(breaks = seq(2005, analysisYear, by =2)) +
    ylim(c(0,1.5)) +  
    ylab("Relative number on treatment") + xlab("Year") + 
    ggtitle("Fitted number on ART relative to 2012 (based on s100 spending)") + 
    opts
  
  tplot2 <- ggplot(data = filter(hivtreated, population == "all"), aes(x = year, y = value)) +
    geom_line(color = "red") + 
    geom_line(aes(y = lower), color = "blue", linetype = "dashed") + 
    geom_line(aes(y = upper), color = "blue", linetype = "dashed") + 
    geom_point(data = filter(hivtreated, population == "all" & year >= 2013), 
               color = "black", size = 4) +
    scale_x_continuous(breaks = seq(2005, analysisYear, by =2)) +
    ylim(0,NA) + 
    ylab("Number on treatment") + xlab("Year") + 
    ggtitle("National number on ART") + 
    opts
  
  # Save to file 
  png(paste(outputFolder, "/figures/treatment_rate.png",sep =""), 
      width = 15, height = 5, units = "in", res = 300)
  grid.arrange(tplot1, tplot2, ncol = 2)
  dev.off() 
  
}

```

## Number retained in care

```{r retained}
# Calculate the number retained in care during the year. This uses a mixture of 
# data sets from MBS and AHOD plus the number of people recieving treatment. 

# Initialize final results data frame using hivtreated
hivretained <- data.frame(stage = character(), 
                         year = double(),
                         population = character(),
                         value = double(),
                         lower = double(),
                         upper = double())

# Load all the data we need
mbsFolder <- file.path(path.expand("~"), "Research", "!Evaluation_Modelling","data")

cd4data <- read.csv(file.path(mbsFolder, "MBS_Data_71139-clean.csv"))
vlnoARTdata <- read.csv(file.path(mbsFolder, "MBS_Data_69378-clean.csv"))
vlARTdata <- read.csv(file.path(mbsFolder, "MBS_Data_69381-clean.csv"))

# Reload ahodData
ahodData <- read.csv(file.path(dataFolder, 
                               paste("ahod", toString(analysisYear), 
                                     ".csv", sep = "")))

# Filter, select and gather the data we need
cd4data <- cd4data %>%
  filter(sex == "all" & age == "all") %>%
  select(-sex, -age) %>%
  gather("state", "n", 2:10) %>%
  filter(year <= analysisYear)

vlnoARTdata <- vlnoARTdata %>%
  filter(sex == "all" & age == "all") %>%
  select(-sex, -age) %>%
  gather("state", "n", 2:10) %>%
  filter(year <= analysisYear)

vlARTdata <- vlARTdata %>%
  filter(sex == "all" & age == "all") %>%
  select(-sex, -age) %>%
  gather("state", "n", 2:10) %>%
  filter(year <= analysisYear)

# Clean up the AHOD data on number of tests 

# Some of the people of unknown modes have missing data
replaceVars <- c("medCd4_noRx", "meanCd4_noRx", "medVL_noRx", "meanVL_noRx", "meanCd4_Rx")
for (ii in 1:nrow(ahodData)) {
  if (is.na(ahodData$medCd4_noRx[ii])) {
    ahodData$medCd4_noRx[ii] <- filter(ahodData, year == ahodData$year[ii] &
                                         state == "all" & 
                                         mode == ahodData$mode[ii])$medCd4_noRx
    ahodData$meanCd4_noRx[ii] <- filter(ahodData, year == ahodData$year[ii] & 
                                          state == "all" &
                                          mode == ahodData$mode[ii])$meanCd4_noRx
    ahodData$medVL_noRx[ii] <- filter(ahodData, year == ahodData$year[ii] & 
                                        state == "all" &
                                        mode == ahodData$mode[ii])$medVL_noRx
    ahodData$meanVL_noRx[ii] <- filter(ahodData, year == ahodData$year[ii] & 
                                         state == "all" &
                                         mode == ahodData$mode[ii])$meanVL_noRx
    ahodData$meanCd4_Rx[ii] <- filter(ahodData, year == ahodData$year[ii] & 
                                        state == "all" &
                                        mode == ahodData$mode[ii])$meanCd4_Rx
  }
}

# Calculate averages across populations

# ahodTests <- ahodData %>% 
#   group_by(year, state) %>%
#   summarise(npeople = sum(n_id),
#             nvltests = sum(meanVL_noRx * n_id),
#             avevltests = nvltests/npeople,
#             ncd4Rxtests = sum(meanCd4_Rx * n_id),
#             avecd4Rxtests = ncd4Rxtests/npeople,
#             ncd4tests = sum(meanCd4_noRx * n_id),
#             avecd4tests = ncd4tests/npeople) %>%
#   filter(year <= analysisYear)

ahodTests <- ahodData %>%
  filter(mode == "all") %>%
  select(-mode) %>%
  filter(year <= analysisYear)

### Do the calculations for all
treatYears <- filter(hivtreated, population == "all")$year
treatValue <- filter(hivtreated, population == "all")$value
treatLower <- filter(hivtreated, population == "all")$lower
treatUpper <- filter(hivtreated, population == "all")$upper

if (useCD4) {
  # Using CD4 data
  numTreated <- filter(hivtreated, population == "all" & 
                         year %in% treatYears)$value
  aveCd4_Rx <- filter(ahodTests, state == "all" & 
                        year %in% treatYears)$meanCd4_Rx
  aveCd4_noRx <- filter(ahodTests, state == "all" & 
                          year %in% treatYears)$meanCd4_noRx
  numCd4Tests <- filter(cd4data, state == "all" & year %in% treatYears)$n

  receivedCare <- (numCd4Tests - numTreated * aveCd4_Rx)/aveCd4_noRx
  
} else {
  # Use VL estimates
  avevlTests <- filter(ahodTests, state == "all" & 
                         year %in% treatYears)$meanVL_noRx
  numvlTests <- filter(vlnoARTdata, state == "all" & year %in% treatYears)$n
  
  receivedCare <- (numvlTests/avevlTests)
}


# Bind to hivretained
hivretained <- rbind(hivretained, data.frame(stage = "retained", 
                         year = treatYears,
                         population = "all",
                         value = receivedCare + treatValue,
                         lower = receivedCare + treatLower,
                         upper = receivedCare + treatUpper))


### Do the calculations for each state
# Loop through states and calculate number suppressed. 
states <- c("act", "nsw", "vic", "qld", "nt", "wa", "sa", "tas")
nstates <- length(states)
availableStates <- c("all", "nsw", "vic", "qld")

for (ii in 1:nstates) {
  
  treatValue <- filter(hivtreated, population == states[ii])$value
  treatLower <- filter(hivtreated, population == states[ii])$lower
  treatUpper <- filter(hivtreated, population == states[ii])$upper
  
  numTreated <- filter(hivtreated, population == states[ii] & 
                         year %in% treatYears)$value
  numCd4Tests <- filter(cd4data, state == states[ii] & 
                          year %in% treatYears)$n
  
  if (useCD4) { 
    # Use CD4 results - warning produces negative numbers for some states 
    # due to number of tests calculations
    if (states[ii] %in% availableStates) {
      
      aveCd4_Rx <- filter(ahodTests, state == states[ii] & 
                            year %in% treatYears)$meanCd4_Rx
      if (any(is.na(aveCd4_Rx))){
        naindex <- is.na(aveCd4_Rx)
        temp <- filter(ahodTests, state == "all" & 
                         year %in% treatYears)$meanCd4_Rx
        aveCd4_Rx[naindex] <- temp[naindex]
      }
      
      aveCd4_noRx <- filter(ahodTests, state == states[ii] & 
                              year %in% treatYears)$meanCd4_noRx
      if (any(is.na(aveCd4_noRx))){
        naindex <- is.na(aveCd4_noRx)
        temp <- filter(ahodTests, state == "all" & 
                         year %in% treatYears)$meanCd4_noRx
        aveCd4_noRx[naindex] <- temp[naindex]
      }
      
    } else {  
      # Not available so use all data
      aveCd4_Rx <- filter(ahodTests, state == "all" & 
                            year %in% treatYears)$meanCd4_Rx
      aveCd4_noRx <- filter(ahodTests, state == "all" & 
                              year %in% treatYears)$meanCd4_noRx
    }
  
    receivedCare <- (numCd4Tests - numTreated * aveCd4_Rx)/aveCd4_noRx
    
  } else {
    # Use VL testing data 
    numvlTests <- filter(vlnoARTdata, state == states[ii] & 
                           year %in% treatYears)$n
  
    # Work out average VL tests for each state if available and non-NA
    if (states[ii] %in% availableStates) {
      avevlTests <- filter(ahodTests, state == states[ii] & 
                             year %in% treatYears)$meanVL_noRx
      if (any(is.na(avevlTests))){
        naindex <- is.na(avevlTests)
        tempTests <- filter(ahodTests, state == "all" & 
                              year %in% treatYears)$meanVL_noRx
        avevlTests[naindex] <- tempTests[naindex]
      }     
    } else {
      # Not available so use all data
      avevlTests <- filter(ahodTests, state == "all" & 
                             year %in% treatYears)$meanVL_noRx
    }
  
    receivedCare <- (numvlTests/avevlTests)
  }
  # Bind to hivretained
  hivretained <- rbind(hivretained, data.frame(stage = "retained", 
                         year = treatYears,
                         population = states[ii],
                         value = receivedCare + treatValue,
                         lower = receivedCare + treatLower,
                         upper = receivedCare + treatUpper))
  
}

# TODO: calculate by mode of exposure and country of birth

# Finally bind to overall results
if (bindCascade) {
  hivcascade <- rbind(hivcascade, hivretained)
}

```

### Number with suppressed virus

```{r suppressed}
# Calculate the number on ART with suppressed virus during the year. This uses 
# data from AHOD data and the number of people recieving treatment. 

# Initialize final results data frame
hivsuppressed <- data.frame(stage = character(), 
                         year = double(),
                         population = character(),
                         value = double(),
                         lower = double(),
                         upper = double())

# Load all the data we need
ahodData <- read.csv(file.path(dataFolder, 
                               paste("ahod", toString(analysisYear), 
                                     ".csv", sep = "")))

# Extract the viral suppression data
propSuppressed <- ahodData %>%
#   filter(state == "all") %>%
  select(one_of(c("year", "state", "mode", "n_id")), 
         starts_with("n_rx"), -n_rx) %>% 
  group_by(year, state) %>%
  summarise(n = sum(n_id),
            n50 = sum(n_rx50), 
            n400 = sum(n_rx400),
            n1000 = sum(n_rx1000)) %>%
  mutate(prop50 = n50/n, 
         prop400 = n400/n,
         prop1000 = n1000/n) %>%
  filter(year <= analysisYear)

# TODO: by exposure mode
# propSuppressedMode <- ahodData %>%
#   select(one_of(c("year", "state", "mode", "n_id")), 
#          starts_with("n_rx"), -n_rx) %>% 
#   group_by(year, mode)

# Loop through states and calculate number suppressed. 
states <- c("act", "nsw", "vic", "qld", "nt", "wa", "sa", "tas", "all")
availableStates <- c("all", "nsw", "vic", "qld")

for (ii in seq(along = states)) {
  # Proportion suppressed
  if(states[ii] %in% availableStates) {
    tempDf <- filter(propSuppressed, state == states[ii])
  } else {
    tempDf <- filter(propSuppressed, state == "all")
  }
  
  tempProp <- tempDf$prop400
  tempPropMin <- tempDf$prop50
  tempPropMax <- tempDf$prop1000
  
  # Number treated 
  tempTreat <- filter(hivtreated, population == states[ii])$value
  tempTreatMin <- filter(hivtreated, population == states[ii])$lower
  tempTreatMax <- filter(hivtreated, population == states[ii])$upper
  
  nyears <- length(tempDf$year)
  
  # Number suppressed
  hivsuppressed <- rbind(hivsuppressed, data.frame(stage = "suppressed",  
                         year = tempDf$year,
                         population = states[ii],
                         value = tempTreat * tempProp,
                         lower = tempTreatMin * tempPropMin,
                         upper = tempTreatMax * tempPropMax)) 
}

### TODO: number suppressed by exposure and country of birth. Once we work out
# how to do it

# Finally bind to overall results
if (bindCascade) {
  hivcascade <- rbind(hivcascade, hivsuppressed)
}

```

```{r cleanup}
# Save final HIV cascades data frame
if (saveCascade) {
  # Directory and file name
  saveString <- file.path(outputFolder, paste("HIVcascadeEstimates-", 
                                              toString(analysisYear), sep = ""))
  
  # Write to csv
  write.csv(hivcascade, file = paste(saveString, ".csv", sep =""), row.names = FALSE)

  # Save as R object
  save(hivcascade,file = paste(saveString, ".rda", sep =""))
}

```
