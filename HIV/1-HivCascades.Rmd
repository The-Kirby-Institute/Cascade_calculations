HIV Cascades Calculations
=========================

Author: Richard T. Gray

This script describes and contains the code for producing the HIV care 
cascade estimates for Australia. It is written in dynamic format using R 
markdown v2 within Rstudio (version 0.98.1091 with R version`r 
substr(R.Version()$version.string,1,15)`) (see 
<http://rmarkdown.rstudio.com>). 

```{r initialization}
# Clear workspace
rm(list=ls()) 

# Setup directories
basePath <- dirname(getwd())

Rcode <- file.path(dirname(getwd()), "code") 
dataFolder <- file.path(basePath, "HIV", "data")
outputFolder <- file.path(basePath, "HIV", "output")
figuresFolder <- file.path(basePath, "output","figures")

# Set working directory
#setwd(basePath)

# Load standard libraries and options ----------------------------------
source(file.path(Rcode, "LoadLibrary.R"), echo=TRUE)
source(file.path(Rcode, "DataLibraries.R"), echo=TRUE)
source(file.path(Rcode, "PlotOptions.R"), echo=TRUE)

# Primary script parameters
currTime <- format(Sys.time(), "%y-%m-%d") # to append to files
analysisYear <- 2016
startYear <- 1990

# Script options ------------------------------------------------------

plots <- FALSE       # TRUE if we want to plot things
bindCascade <- FALSE  # TRUE if we want to store all the cascade results 
                     # one data frame

saveCascade <- FALSE       # save final cascade dataframe
saveNotifications <- FALSE # save cleaned notifications set
saveResults <- FALSE       # save information national annual notifications
savePldhiv <- FALSE        # save PLDHIV estimates separately

# set hivSet function parameters
targetGender <- 'all' #M or F, Null both, add code for including/excluding NA's or missings 
targetAge <- 'all' #groups 0, 1, 2, 3, 4...
targetCob <- 'non-australia' #all=including n/a, Thailand, etc.
targetExposure <- 'all'
targetAtsi <- 'non-australia' #0 or 1
targetState <- 'all' #NSW, VIC, etc
targetLocalRegion <- 'all' #tbd
targetGlobalRegion <- 'all' #South-east Asia, Oceania, South American, etc.

# PLDHIV 
nationalUniques <- TRUE # use proportion from National estimates for 
                        # sub-population de-duplication

indigKnown <- FALSE  #TRUE # only use notifications with indigenous classification 
                   # for indigenous estimates

permDeparts <- TRUE # use national permant departures for 
                    # overseas migration

cascadeImpact <- FALSE # save PLHIV estimates with deathrate fixed to value
                      # from 10 years ago
# PLHIV
# Given issues with undiagnosed estimates use hardcoded estimates from 
# 2013 ASR
useOldPropUndiagnosed <- TRUE

# Linked
includeLinked <- FALSE # include linked to care in cascade

# Retained
useClinic <- TRUE # use McMahon et al clinic data  for retained in care
useCD4 <- FALSE # use CD4 AHOD and testing data for retained in care if
                # we don't use McMahon data

# Treated
addTempRes <- TRUE # Add estimates for temporary residents on ART

# Overall
replaceValues <- TRUE # Replace with specific estimates

```

```{r functions}
# Load and define useful functions for analysis

# Load function to remove duplicates
source(file.path(Rcode,"RemoveDuplicates.R"), echo=TRUE)

# Load function to calculate number living with diagnosed HIV
source(file.path(Rcode,"LivingDiagnosed.R"), echo=TRUE)

# Source function for filling in missing data
source(file.path(Rcode, "FillMissing.R"), echo=TRUE)

# Function to easily extract sub-populations of interest
subhivset <- function(hivdataframe, fAge, fExposure, fCob, fAtsi, fLocalRegion, fGlobalRegion){
  
  subframe <- hivdataframe
  
  if(fAge!='all'){
    #to be filled later
  }
  if(fExposure!='all'){
    subframe <- filter(subframe, exposure == fExposure)
  }
  if(fCob!='all'){
    if(fCob=='non-australia'){
      subframe <- filter(subframe, cob!='Not Reported') #remove all missings
      subframe <- filter(subframe, !is.na(cob)) #remove all missings
      subframe <- filter(subframe, cob != 'Australia') #get only non-Australians
    }#else if(fCob=='non-australia all'){
      #missingframe <- filter(subframe, cob=='Not Reported') #get subset of all missing cobs
      #nonmissingframe <- filter(subframe, cob!='Not Reported') #remove all missings
      #subframe <- filter(nonmissingframe, cob != 'Australia') #get only non-Australians
      #get proportion of non-australians from missings by applying proportion of non-australians from non-missings; get only those who are non-atsi
      #proportion <- nrow(subframe)/nrow(nonmissingframe)
      #missingframe <- filter(missingframe, indigenous != 'Aboriginal')
      #proportionExtract <- floor(proportion*nrow(missingframe))
      #missingframe <- missingframe[1:proportionExtract,]
      #append a subset of missingframe to subframe
      #subframe <- rbind(missingframe, subframe)
    #}
    else{
      subframe <- filter(subframe, cob == fCob)
    }
  }
  if(fAtsi!='all'){
    if(fAtsi=='non-australia'){
      #subframe <- filter(subframe, aboriggroup == 'othercob')
    }else{
      if(fAtsi=='non-atsi'){
        subframe <- filter(subframe, aboriggroup == 'non-indigenous') 
      }else if(fAtsi=='atsi'){
        subframe <- filter(subframe, aboriggroup == 'indigenous') 
      }
    }
    #what to do with NA's?
  }
  if(fLocalRegion!='all'){
    subframe <- filter(subframe, localregion == fLocalRegion)
  }
  if(fGlobalRegion!='all'){
    subframe <- filter(subframe, globalregion == fGlobalRegion)
  }

  return(subframe)
}

# Function for removing duplicates annually
numUnique <- function(dobframe, years,ignore, file = NA) {
  # Loop through years and calculate cumulative number of unique cases 
  numcases <- rep(NA,length(years))
  for (ii in seq(along=years)) {
    dobvector <- filter(dobframe,yeardiagnosis <= years[ii])$dob
    if (length(dobvector) != 0) {
      # Make sure our dobvector isn't empty
      numcases[ii] <- RemoveDuplicates(dobvector,ignore)
    }
  }
  
  # If selected write final output to file
  if (!is.na(file)) {
    numcases[ii] <- RemoveDuplicates(dobvector,ignore, write = file)
  }
  
  # Return vector of unique cases
  return(numcases)
}

# Function to create file name for deduplicted output
deduplicateFile <- function(pop, state, mode, years) {
  filename <- paste(basePath, "/output/uniquehiv-", state, "_", mode, 
                    "_", toString(tail(years,1)),sep="")
}

# Function is replace current estimates with estimates for 
# specific populations obtained separately for a specific time period. 
# These values are read in from a csv file. 

replaceEstimates <- function(cascade, hardcode) {  
  # Replace with updated values
  for (ii in 1:nrow(hardcode)) {
    cascade <- cascade %>%
      mutate(value = ifelse(population == hardcode$population[ii] &
                              year == hardcode$year[ii] &
                              stage == hardcode$stage[ii], 
                            hardcode$value[ii],
                            value),
             lower = ifelse(population == hardcode$population[ii] &
                              year == hardcode$year[ii] &
                              stage == hardcode$stage[ii], 
                            hardCodeValues$lower[ii],
                            lower),
             upper = ifelse(population == hardcode$population[ii] &
                              year == hardcode$year[ii] &
                              stage == hardcode$stage[ii], 
                            hardcode$upper[ii],
                            upper))
  }
  
  return(cascade)
}

```

## Estimate cumulative HIV notifications 

```{r startAnalysis}
# Load clean file
hivData <- read.csv(file.path(dataFolder, paste("hivnotifications",
                    toString(analysisYear), ".csv", sep = ""))) #, 
#                     as.is = c(1:3, 6, 9, 11, 16:18))

if (replaceValues) {
  # Replace with hard coded estimates where necessary
  
  # Load hard coded estimates
  hardCodeValues <- read.csv(file.path(dataFolder,
                                       "Hard_coded_estimates.csv"))
}

# Setup overarching analysis                   
years <- startYear:analysisYear # Years to calculate and plot 

# Setup extra columns for analysis
hivData$yeardiagnosis <- as.numeric(substr(hivData$datediagnosis, 1, 4))
hivData$yeardeath <- as.numeric(substr(hivData$datedeath, 1, 4))

allYears <- min(hivData$yeardiagnosis):analysisYear # All years of data

# transfer cob to cobCode
hivData$cobcode <- hivData$cob

# load cob and region codes
crCodes <- read.csv(file.path(dataFolder, "countryRegionCodes.csv"))

# if cob is not in crCodes/NA, change to Not Reported 
hivData$cob[!(hivData$cobcode %in% crCodes$COUNTRY_CODE)] <- "Not Reported"

# change cob from code to String
hivData$cob <- crCodes$COUNTRY_NAME[match(hivData$cobcode, crCodes$COUNTRY_CODE)]

#add region
hivData$globalregion <- crCodes$REGION[match(hivData$cobcode, crCodes$COUNTRY_CODE)]
  
#clean aboriggroup
hivData$aboriggroup <- rep(NA,nrow(hivData))

if (analysisYear < 2015) {
  hivData$aboriggroup[hivData$cob!=1100|hivData$rob!=7] <- "othercob"
  hivData$aboriggroup[hivData$cob==0] <- NA
  hivData$aboriggroup[hivData$cob == 1100 & hivData$indigenous == "Aboriginal"] <- "indigenous"
  hivData$aboriggroup[hivData$cob == 1100 & hivData$indigenous == "Non indigenous"] <- "non-indigenous" 
} else {
  hivData$aboriggroup[hivData$cob!=1100|hivData$rob!=7] <- "othercob"
  hivData$aboriggroup[hivData$cob==0] <- NA
  hivData$aboriggroup[hivData$cob == 1100 & hivData$indigenous == "Aboriginal"] <- "indigenous"
  hivData$aboriggroup[hivData$cob == 1100 & hivData$indigenous == "Non indigenous"] <- "non-indigenous" 
}

# Quick checks that we are not doing analysis outside of the data.
if (max(hivData$yeardiagnosis) < analysisYear) {
  stop("No data specified for final year of analysis.")
}

if (min(hivData$yeardiagnosis) > startYear) {
  stop("No data specified for first year of analysis.")
}

# Setup our working data frame
#### hivSet <- filter(hivData, yeardiagnosis <= analysisYear)
#### replace this with a function to get hivSet based on input parameters
hivSet <- filter(hivData, yeardiagnosis <= analysisYear)
hivSetOrig <- filter(hivData, yeardiagnosis <= analysisYear)
hivSet <- subhivset(hivData, targetAge, targetExposure, targetCob, targetAtsi, targetLocalRegion, targetGlobalRegion)

##get set of Au cob and unknowns to distribute proportion
hivSetKnown <- filter(hivData, yeardiagnosis <= analysisYear)
hivSetKnown <- subset(hivSetKnown, cob!="Not Reported")
hivSetKnown <- subset(hivSetKnown, !is.na(cob))

hivSetUnknown <- filter(hivData, yeardiagnosis <= analysisYear)
hivSetUnknown <- subset(hivSetUnknown, is.na(cob) | cob=="Not Reported")


if (saveNotifications) {
  # Directory and file name
  saveString <- file.path(outputFolder, paste("HIVset-", 
    toString(analysisYear), sep = ""))
  
  # Write to csv
  write.csv(hivSet, file = paste(saveString, ".csv", sep = ""), 
            row.names = FALSE)

  # Save as R object
  save(hivSet, file = paste(saveString, ".rda", sep = ""))  
  
}

# Initialize final results data frame
if (bindCascade) {
  hivCascade <- data.frame(stage = character(), 
                         year = double(),
                         population = character(),
                         estimate = double(),
                         lower = double(),
                         upper = double())
}

```

Sort out diagnoses ...

```{r diagnoses}
# Setup dataframe for overall results by first extracting diagnoses details

# Overall annual results --------------------------------------------------
origHivSet <- hivSetOrig %>%
  group_by(yeardiagnosis) %>% 
  summarise(notifications = n()) %>% 
  mutate(totalnotifications  = cumsum(notifications)) %>% 
  filter(yeardiagnosis <= analysisYear)   

hivResults <- hivSet %>% 
  group_by(yeardiagnosis) %>% 
  summarise(notifications = n()) %>% 
  mutate(totalnotifications  = cumsum(notifications)) %>% 
  filter(yeardiagnosis <= analysisYear)   

hivResultsKnown <- hivSetKnown %>% 
  group_by(yeardiagnosis) %>% 
  summarise(notifications = n()) %>% 
  mutate(totalnotifications  = cumsum(notifications)) %>% 
  filter(yeardiagnosis <= analysisYear)   

hivResultsUnknown <- hivSetUnknown %>% 
  group_by(yeardiagnosis) %>% 
  summarise(notifications = n()) %>% 
  mutate(totalnotifications  = cumsum(notifications)) %>% 
  filter(yeardiagnosis <= analysisYear)   

#Fill up missing years
fillMissing <- as.data.frame(allYears) 
colnames(fillMissing) <- c("yeardiagnosis")
hivResults <- merge(fillMissing, hivResults, by="yeardiagnosis", all.x=TRUE)
hivResults[is.na(hivResults)] <- 0
hivResultsKnown <- merge(fillMissing, hivResultsKnown, by="yeardiagnosis", all.x=TRUE)
hivResultsKnown[is.na(hivResultsKnown)] <- 0
hivResultsUnknown <- merge(fillMissing, hivResultsUnknown, by="yeardiagnosis", all.x=TRUE)
hivResultsUnknown[is.na(hivResultsUnknown)] <- 0

#Get proportion of unknown 
proportion <- as.data.frame(allYears) 
colnames(proportion) <- c("yeardiagnosis")
proportion$proportion <- hivResults$notifications/hivResultsKnown$notifications
proportion$proportion[is.na(proportion$proportion)] <- 0
hivResults$notifications <- hivResults$notifications + floor(proportion$proportion*hivResultsUnknown$notifications)
#hivResults$notifications <- hivResults$notifications + hivResultsUnknown$notifications
hivResults$totalnotifications <- cumsum(hivResults$notifications)

# Create some useful diagnoses data plots ---------------------------------
if (plots) {
  graphics.off()
  
  # All notifications
  plotDiags1 <- ggplot(data = hivResults, 
    aes(x = yeardiagnosis, y = notifications)) + 
    geom_line(size = 1.5) + ylab("Annual notifications") + xlab("Year") + 
    theme_bw() + plotOpts
  
  plotDiags2 <- ggplot(data = hivResults, 
    aes(x = yeardiagnosis, y = totalnotifications)) + 
    geom_line(size = 1.5) + ylab("Cumulative notifications") + 
    xlab("Year") + theme_bw() + plotOpts
  
  plotDiags <- grid.arrange(plotDiags1, plotDiags2, ncol = 2)
  ggsave(file.path(figuresFolder, "all_notifications.png"), 
    plot = plotDiags, width = 10, height = 5, units = "in")
  
} 

```

Potentially impute country of birth and indigeous status 

```{r imputation}
# 

# temp <- select(hivset, state, sex, cob, exposure, partnercob, 
#                previ_diag_overseas, country_prev_diag, yearhiv, 
#                aborig, countrygroup)
# 
# impcob <- lm(countrygroup ~ state + sex + cob + exposure + partnercob + 
#      previ_diag_overseas + country_prev_diag + yearhiv + aborig, 
#       data = temp)
# 
# predcob <- predict(impcob, temp)

```

Removal of duplicates .....

```{r removeduplicates}

# Days to ignore in duplicate calculations
ignore <- c(1,15) 

# Store number unique diagnoses cumulatively and annually. For annual 
# unique cases assume all the first years of disgnoses are unique. 

# Do calculations for all notifications first-----------------------------

dobAll <- select(hivSetOrig, dob, yeardiagnosis) # Overall
numberUniqueAll <- numUnique(dobAll, allYears, ignore)
numberUniqueAll[is.na(numberUniqueAll)] <- 0

# Add variable for proportion unique - due to statistical calculations 
# proportion mybe slightly higher than one. In those cases round down to
# 1.
hivResults$propunique <- 
  numberUniqueAll / origHivSet$totalnotifications
  hivResults$propunique[is.na(hivResults$propunique)] <- 0
  hivResults$propunique[hivResults$propunique > 1] <- 1

# Store set unique cases
hivResults$uniquecases <- hivResults$totalnotifications*hivResults$propunique
  
```

Sort out population movement rates

```{r migration}
# This chunk converts the ABS overseas and interste migration data into 
# population movement rates

# Load all the data sets we need - the ABS data is stored in a different 
# folder
#absFolder <- file.path(path.expand("~"), 
#                       "Research", "!Evaluation_Modelling", "data")
 
# absFolder <- file.path(dataFolder)
# absMigration <- read.csv(file.path(absFolder, 

# Load all the data sets we need - the ABS data is stored in the main 
# Cascade_calculations respository data/ directory

mainDataFolder <- file.path(dirname(getwd()), "data")
 
absMigration <- read.csv(file.path(mainDataFolder, 
  paste0("ABS_migration_clean-", toString(analysisYear), ".csv")), 
  as.is = 1)
absDeparts <- read.csv(file.path(mainDataFolder, 
  paste0("ABS_departures_clean-", toString(analysisYear), ".csv")),
  as.is = 1)

absInterstate <- read.csv(file.path(mainDataFolder, 
  paste0("ABS_interstate_clean-", toString(analysisYear), ".csv")), 
  as.is = 1)

# Depending on data used calculate departure rate for each state ---------

states <- c("nsw", "vic", "qld", "nt", "wa", "sa", "tas", "act", "all")
# nstates <- length(states)
  
allPredicts <- data.frame(year = numeric(), 
                          state = character(),
                          rate = numeric(),
                          lower = numeric(),
                          upper = numeric())

if (permDeparts) {
  # Use permanent departures nationally
  absDeparts <- mutate(absDeparts, migrate = permanent / erp)
  mrate <- absDeparts$migrate
  
  if (analysisYear <= 2014) {
    # Keep methdology for 2014 cascade for replication purposes
    
    # mrate is missing a value for 1980 assume same value as 1981
    mrate <- c(mrate[1], mrate)
    lmrate <- 0
    umrate <- mrate
    mrate <-  mrate / 2
    
  } else{
    # Change in methodlogy for migration rates from 2015.
    
    # Hard coded adjustment factor to account for age > 15 years and 
    # sex. These harded coded estimates for 1981-2015 are determined in 
    # the file project_care_cascades/data/Migration_options-2016-10-12.xlsx
    relativeRate <- c(1.2499, 1.2499,	1.2499,	1.240169381, 1.235807895,
                      1.235391781, 1.236048319,	1.236375068, 1.236578904,
                      1.235863902, 1.23556672, 1.235166515,	1.234926588,
                      1.234456001, 1.234217118, 1.233938271, 1.233473343,
                      1.232885687, 1.23528249, 1.234803523, 1.234243908,
                      1.231400608, 1.231146313, 1.230567577, 1.22257888,
                      1.211940692, 1.20153294, 1.191640652, 1.180852205,
                      1.170562151, 1.160456052,	1.150374872, 1.140323439,
                      1.130276173, 1.12031362, 1.12031362)
    
    mrate <- relativeRate * mrate
    
    # mrate is missing a value for 1980 assume same value as 1981
    mrate <- c(mrate[1], mrate)
    lmrate <- 0
    umrate <- 2 * mrate
  }
  
  # Fill in the state values - produce states based estimates 
  # using NOM departure rates to adjust the national rate
  absMigration <- mutate(absMigration, migrate = departures / erp)
  
  nonmrateAll <- filter(absMigration, state == "all")
  lmrateAll <- lm(migrate ~ year, data = nonmrateAll)
  expmrateAll <- predict(lmrateAll, data.frame(year = allYears),
                        level = 0.9, interval = "confidence")
    
  for (region in states) {
    # Adjust national rate to reflect difference at state level using 
    # national NOM departures data
    
    nonmrate <- filter(absMigration, state == region)
    
    # Now we need to fit and extrapolate for other years
    lmrate <- lm(migrate ~ year, data = nonmrate)
    expmrate <- predict(lmrate, data.frame(year = allYears),
                        level = 0.9, interval = "confidence")
    
    relexpmrate <- expmrate[, 1] / expmrateAll[, 1]
    
    
    allPredicts <- rbind(allPredicts, data.frame(year = allYears, 
                                      state = region,
                                      rate = mrate * relexpmrate, 
                                      lower = 0, 
                                      upper = 2 * mrate * relexpmrate))
  }
  
  # Store results in final data frame
  hivMigrate <- allPredicts
  
} else {
  # Use state based NOM departures
  
  # Calculate migration rate overall and for each state
  absMigration <- mutate(absMigration, migrate = departures / erp)
  
  for (region in states) {
    mrate <- filter(absMigration, state == region)
    
    # Now we need to fit and extrapolate for other years
    lmrate <- lm(migrate ~ year, data = mrate)
    expmrate <- predict(lmrate, data.frame(year = allYears),
                        level = 0.9, interval = "confidence")
    
    # Store extrapolated rate
    allPredicts <- rbind(allPredicts, data.frame(year = allYears, 
                                                 state = region,
                                                 rate = expmrate[, 3]/2, 
                                                 lower = 0, 
                                                 upper = expmrate[, 3]))
  }
  
  # Store results in final data frame
  hivMigrate <- allPredicts
  
  # Plot what we have done if required ------------------------------------
  if (plots) {
    graphics.off()
    
    # Plot the overseas migration data for each state
    if (permDeparts) {
      mplot1 <- ggplot(data = absDeparts, 
                       aes(x = year, y = migrate)) +
        geom_line(size = 2) + ylim(c(0,0.02)) + 
        xlab("Year") + ylab("Overseas migration rate") + theme_bw() +
        plotOpts
    } else {
      mplot1 <- ggplot(data = absMigration, 
                       aes(x = year, y = migrate, colour = state)) +
        geom_line(size = 2) + ylim(c(0,0.02)) + 
        xlab("Year") + ylab("Overseas migration rate") + theme_bw() +
        plotOpts
    }
    
    # Plot fitted overseas migration data for each state
    mplot2 <- ggplot(data = hivMigrate, 
                     aes(x = year, y = rate, colour = state)) + 
      geom_line(data = absMigration, 
                aes(y = migrate), size = 0.5, linetype = "dashed") + 
      geom_point(data = absMigration, 
                 aes(y = migrate), size = 3, shape = 18) + 
      geom_line(size = 1.2) + ylim(c(0,0.02)) +
      xlab("Year") + ylab("Overseas migration rate") + 
      ggtitle("Fitted annual migration rate") + theme_bw() +
      plotOpts
    
    # Plot national overseas migration rate with uncertainty
    mplot3 <- ggplot(data = filter(hivMigrate, state == "all"), 
                     aes(x = year, y = rate)) +
      geom_line(color = "red") + 
      geom_line(aes(y = lower), linetype = "dashed", color = "blue") + 
      geom_line(aes(y = upper), linetype = "dashed", color = "blue") + 
      geom_point(data = filter(absMigration, state == "all"), 
                 aes(y = migrate), size = 2, color = "black") +
      ylim(c(0,0.02)) + xlab("Year") + ylab("Overseas migration rate") + 
      ggtitle("Fitted annual migration rate") + theme_bw() +
      plotOpts
    
    # Save to file 
    migratePlot <- grid.arrange(mplot1, mplot2, mplot3, ncol = 3)
    ggsave(file.path(figuresFolder, "prop_migrate.png"),
           plot = migratePlot, width = 15, height = 5)
    }
}


```

Sort out deathrates

```{r deaths}
# To calculate the number of deaths each year we calculate an overall 
# deathrate with an uncertainty range. This is used to work out the number
# of people diagnosed with HIV. The estimate of the death rate uses a
# number of methods. Firstly uses the 
# 2003 linkage results and the number of known deaths to estimate the
# deathrate up to 2003. It then uses AHOD mortality rates from 2003.

# Load all the data sets we use for this estimate - use the parameter 
# column as row names for easier subsetting
hivParams <- read.csv(file.path(dataFolder,
                                "individualHIVparameters.csv"), 
                      as.is = 1)
hivParams <- select(hivParams, parameter, value)

for (ii in 1:nrow(hivParams)) {
  assign(hivParams$parameter[ii], hivParams$value[ii])
}

# Load AHOD data to calculate mortality and do some simple cleaning
ahodData <- read.csv(file.path(dataFolder, 
                               paste("ahod", toString(analysisYear), 
                                     ".csv", sep = "")))

# Extract number of known deaths and store in a central data frame
#hivDeaths <- hivData %>% 
#  filter(! is.na(yeardeath)) %>%
#  group_by(yeardeath) %>% 
#  summarise(number_deaths = n()) %>% 
#  filter(yeardeath <= analysisYear)  
hivDeaths <- hivSet %>% 
  filter(! is.na(yeardeath)) %>%
  group_by(yeardeath) %>% 
  summarise(number_deaths = n()) %>% 
  filter(yeardeath <= analysisYear) 

#Fill up missing years
fillMissing <- as.data.frame(allYears) 
colnames(fillMissing) <- c("yeardeath")
hivDeaths <- merge(fillMissing, hivDeaths, by="yeardeath", all.x=TRUE)
hivDeaths[is.na(hivDeaths)] <- 0

# Calculate sensitivity of recorded deaths based on linkage results
linkageFactor <- (linkedDeaths + notifiedDeaths) / notifiedDeaths
linkageFactorLower <- linkageFactor * (1 - linkageSensitivity)
linkageFactorUpper <- linkageFactor * (1 + linkageSensitivity)  

#  We don't need to adjust deaths for number of unique diagnoses as
# different dates of death should result in different people

# Set up linked deaths
hivDeaths$inflated_deaths <- hivDeaths$number_deaths * linkageFactor
hivDeaths$inflated_deaths_lower <- hivDeaths$number_deaths * 
  linkageFactorLower
hivDeaths$inflated_deaths_upper <- hivDeaths$number_deaths * 
  linkageFactorUpper

# No deaths in 1980 and 1982 so add this data manually to ensure 
# everything lines up
#hivDeaths <- rbind(hivDeaths, c(1980, 0, 0, 0, 0))
#hivDeaths <- rbind(hivDeaths, c(1982, 0, 0, 0, 0))
hivDeaths <- arrange(hivDeaths, yeardeath)

# Now calculate mortality rate for linkage data --------------------------
cumDiagnoses <- hivResults$uniquecases # totalnotifications #uniquecases
deaths <- hivDeaths$inflated_deaths
deaths_min <- hivDeaths$inflated_deaths_lower
deaths_max <- hivDeaths$inflated_deaths_upper
annDiags <- c(cumDiagnoses[1], diff(cumDiagnoses))  # annual diagnoses

# Calculate number living each year 
numLiving <- rep(NA, length(annDiags))
numLiving_min <- rep(NA, length(annDiags))
numLiving_max <- rep(NA, length(annDiags))

numLiving[1] <- annDiags[1]
numLiving_min[1] <- annDiags[1]
numLiving_max[1] <- annDiags[1]

# Overall migration rate for deaths estimate
allMigrate <- filter(hivMigrate, state == "all") 

for (ii in 2:length(annDiags)) {
  numLiving[ii] <- numLiving[ii-1] + annDiags[ii] - deaths[ii-1] 
   - numLiving[ii-1] * allMigrate$rate[ii-1]
  numLiving_min[ii] <- numLiving_min[ii-1] + annDiags[ii] -
    deaths_max[ii-1] - numLiving_min[ii-1] * allMigrate$upper[ii-1]
  numLiving_max[ii] <- numLiving_max[ii-1] + annDiags[ii] -
    deaths_min[ii-1] - numLiving_max[ii-1] * allMigrate$lower[ii-1]
}

# Calculate mortality
linkageMortality <- deaths / numLiving
linkageMortalityMin <- deaths_min/numLiving_max
linkageMortalityMax <- deaths_max/numLiving_min

#Append AHOD mortality ---------------------------------------

# Calculate crude death rate for each state and year - use 95% CI as the upper and lower bound

ahodDeaths <- ahodData %>% 
  filter(population == "ALL") %>%
  group_by(state, year) %>%
  summarise(n = sum(n_id), 
    deaths = sum(n_death), 
    deathrate = unname(prop.test(sum(n_death), 
      sum(n_id))$estimate), 
    lower = unname(prop.test(sum(n_death), sum(n_id))$conf.int[1]),
    upper = unname(prop.test(sum(n_death), sum(n_id))$conf.int[2])) %>%
  filter(year > 2003)

# First find index corresponding to year of linkage 
indexLinkage <- max(seq(along = min(hivResults$yeardiagnosis):linkageYear))

# Save in deathrate
deathRate <- rep(NA, length(allYears))
deathRate_min <- rep(NA, length(allYears))
deathRate_max <- rep(NA, length(allYears))

deathRate[1:indexLinkage] <- linkageMortality[1:indexLinkage]
deathRate[(indexLinkage + 1):length(deathRate)] <- filter(ahodDeaths, 
  state == "all")$deathrate # 

deathRate_min[1:indexLinkage] <- linkageMortalityMin[1:indexLinkage]
deathRate_min[(indexLinkage + 1):length(deathRate)] <- filter(ahodDeaths, 
  state == "all")$lower # 

deathRate_max[1:indexLinkage] <- linkageMortalityMax[1:indexLinkage]
deathRate_max[(indexLinkage+1):length(deathRate)] <- filter(ahodDeaths, 
  state == "all")$upper # 

deathRate[is.na(deathRate)] <- 0
deathRate_min[is.na(deathRate_min)] <- 0
deathRate_max[is.na(deathRate_max)] <- 0

# Fix last 10 years if we are doing cascade impact calculations
if(cascadeImpact) {
  end <-length(deathRate)
  start <- end - 10 + 1
  
  deathRateFix <- deathRate
  deathRateFix[start:end] <- max(deathRate[start:end])
  
  deathRateFix_min <- deathRate_min
  deathRateFix_min[start:end] <- max(deathRate_min[start:end])
  
  deathRateFix_max <- deathRate_max
  deathRateFix_max[start:end] <- max(deathRate_max[start:end])
  
  # Store final death rate
  hivDeathRate <- data.frame(year = allYears,
                             deathrate = deathRate,
                             deathrate_min = deathRate_min,
                             deathrate_max = deathRate_max)
} 

# Store national results
hivResults$osrate <- allMigrate$rate
hivResults$oslower <- allMigrate$lower
hivResults$osupper <- allMigrate$upper

hivResults$deathslinked <- deaths
hivResults$deathslower <- deaths_min
hivResults$deathsupper <- deaths_max

hivResults$deathrate <- deathRate
hivResults$drlower <- deathRate_min
hivResults$drupper <- deathRate_max


# Plot what we have done if required --------------------------------------
if (plots) {
  graphics.off()
  
  # Plot the deathrate
  deathPlot1 <- ggplot(data = hivResults, 
                       aes(x = yeardiagnosis, y = deathrate)) +
    geom_line(size = 1.25, color = "blue") + ylim(0,NA) + 
    xlab("Year") + ylab("Annual death rate") + theme_bw() +
    plotOpts
  
  deathPlot2 <- ggplot(data = hivResults, 
                       aes(x = yeardiagnosis, y = deathrate)) +
    geom_line(size = 1.25, color = "blue") + 
    ylim(0,0.025) + xlim(2000, NA) +
    geom_line(aes(y = drlower), size = 1.25, color = "red") + 
    geom_line(aes(y = drupper), size = 1.25, color = "red") +
    xlab("Year") + ylab("Annual death rate") + theme_bw() +
    plotOpts
  
  # Save to file 
  deathPlot <- grid.arrange(deathPlot1, deathPlot2, ncol = 2)
  ggsave(file.path(figuresFolder, "death_rate.png"),
         plot = deathPlot, width = 15, height = 5)
}

```

## Number living with diagnosed HIV

```{r livingdiags}
# This chunk now estimates the number of people living with diagnosed HIV. 

# Hard coded initial migration values based on NSW data post-diagnosis
if (analysisYear <= 2014) {
  propStay <- 1
  propStayLower <- 1
  propStayUpper <- 1
} else {
  propStay <- 0.98
  propStayLower <- 0.96
  propStayUpper <- 1
} 
# Initialize final results data frame
hivDiagnosed <- data.frame(stage = character(), 
                           year = double(),
                           population = character(),
                           estimate = double(),
                           lower = double(),
                           upper = double())

# First calculate overall number -----------------------------------------

# Setup all our vectors - first by filling in missing cumulative diagnoses
filledDiagnoses <- FillMissing(allYears, hivResults$yeardiagnosis, 
                                 hivResults$uniquecases)

cumDiagnoses <- filledDiagnoses$value

# All death rates used for all  populations
deathRate <- hivResults$deathrate
deathRateMin <- hivResults$drlower
deathRateMax <- hivResults$drupper

# National migration rates
migrationRate <- filter(hivMigrate, state == "all")$rate
migrationRateMin <- filter(hivMigrate, state == "all")$lower
migrationRateMax <- filter(hivMigrate, state == "all")$upper

# Calculate number living with diagnosed HIV and range
pldhivAll <- LivingDiagnosed(cumDiagnoses, deathRate,
                             migrationRate, propStay)

# Use max rates for min estimate because they are removal rates 
# and vice versa
pldhivAllMin <- LivingDiagnosed(cumDiagnoses,
                                deathRateMax,
                                migrationRateMax,
                                propStayLower) 
pldhivAllMax <- LivingDiagnosed(cumDiagnoses,
                                deathRateMin,
                                migrationRateMin,
                                propStayUpper) 

# If doing Cascade impact
if(cascadeImpact) {
  
  pldhivFix <- LivingDiagnosed(cumDiagnoses, deathRateFix,
                               migrationRate, propStay)
  pldhivFixMin <- LivingDiagnosed(propStayLower, cumDiagnoses,
                                  deathRateFix_max,
                                  migrationRateMax,
                                  propStayLower)
  
  pldhivFixMax <- LivingDiagnosed(cumDiagnoses,
                                  deathRateFix_min,
                                  migrationRateMin,
                                  propStayUpper)
}

# Store results
nyears <- length(allYears)
hivDiagnosed <- rbind(hivDiagnosed, 
                      data_frame(stage = "pldhiv", 
                            year = allYears, 
                            population = "all", 
                            value = pldhivAll,
                            lower = pldhivAllMin,
                            upper = pldhivAllMax))


# Finally bind to overall results -----------------------------------------
if (bindCascade) {
  hivCascade <- rbind(hivCascade, hivDiagnosed)
}

# Replace values with hard coded if necessary
if (replaceValues) {
  tempHardCode <- filter(hardCodeValues, stage == "pldhiv")
  if (nrow(tempHardCode) > 0) {
    hivCascade <- replaceEstimates(hivCascade, tempHardCode)
  }
}

```

## Number undiagnosed

```{r undiagnosed}
# This chuck now estimates the number of people living with diagnosed HIV. 

# Initialize final results data frame
hivUndiag <- data.frame(stage = character(), 
                         year = double(),
                         population = character(),
                         estimate = double(),
                         lower = double(),
                         upper = double())

# Sort out proportion undiagnosed -----------------------------------------

# Read in back projected undiagnosed estimates from ECDC HIV Modelling Tool
propUndiagnosed <- read_excel(file.path(dataFolder, 
  paste0("ecdc_undiagnosed_percentage-", toString(analysisYear),
         ".xlsx")))

# Only keep required years
propUndiagnosed <- filter(propUndiagnosed, year %in% allYears) 

# Convert percentages to proportions
propUndiagnosed[, 4:6] <- propUndiagnosed[, 4:6] / 100

# Estimate proportion MSM and non-MSM for indigenous population
aborigMSM <- hivSet %>%
  filter(aboriggroup == "indigenous") %>%
  group_by(yeardiagnosis, expgroup) %>%
  summarise(notifications = n()) %>%
  ungroup() %>% 
  group_by(expgroup) %>% 
  mutate(totalnotifications = cumsum(notifications)) %>%
  ungroup() %>%
  group_by(yeardiagnosis) %>% 
  mutate(propnotifications = notifications / sum(notifications)) %>%
  mutate(proptotalnotifications = 
           totalnotifications / sum(totalnotifications)) %>% 
  filter(yeardiagnosis <= analysisYear) %>%
  select(yeardiagnosis, expgroup, proptotalnotifications)

propAborigMSM <- filter(aborigMSM, 
                        expgroup == "msm")$proptotalnotifications

propAborigMSM <- c(0, 0, 0, 0, propAborigMSM) # add zeros for 1980-83

# Calculate best and range for undiagnosed -- best is the midpoint between 
# estimates when previoulsly diagnosed overseas notifications are included
# or excluded

undiagAll <- filter(propUndiagnosed, group == "all", 
                     overseas_included == "yes")$estimate 

undiagAllMin <- filter(propUndiagnosed, group == "all", 
                       overseas_included == "yes")$lower

undiagAllMax <- filter(propUndiagnosed, group == "all", 
                       overseas_included == "yes")$upper

# MSM
undiagMSM <- filter(propUndiagnosed, group == "msm", 
                     overseas_included == "yes")$estimate

undiagMSMMin <- filter(propUndiagnosed, group == "msm", 
                       overseas_included == "yes")$lower

undiagMSMMax <- filter(propUndiagnosed, group == "msm", 
                       overseas_included == "yes")$upper

# Hetero
undiagHetero <- filter(propUndiagnosed, group == "hetero", 
                     overseas_included == "yes")$estimate 

undiagHeteroMin <- filter(propUndiagnosed, group == "hetero", 
                       overseas_included == "yes")$lower

undiagHeteroMax <- filter(propUndiagnosed, group == "hetero", 
                       overseas_included == "yes")$upper

# PWID
undiagPWID <- filter(propUndiagnosed, group == "pwid", 
                     overseas_included == "yes")$estimate 

undiagPwidMin <- filter(propUndiagnosed, group == "pwid", 
                       overseas_included == "yes")$lower

undiagPwidMax <- filter(propUndiagnosed, group == "pwid", 
                       overseas_included == "yes")$upper

# Non-MSM
undiagNonMSM <- filter(propUndiagnosed, group == "non-msm", 
                     overseas_included == "yes")$estimate 

undiagNonMsmMin <- filter(propUndiagnosed, group == "non-msm", 
                       overseas_included == "yes")$lower

undiagNonMsmMax <- filter(propUndiagnosed, group == "non-msm", 
                       overseas_included == "yes")$upper

# Estimate number of people living with HIV overall -----------------------

pldhivTemp <- filter(hivDiagnosed, stage == "pldhiv", population == "all")
infectedAll <- pldhivTemp$value / (1 - undiagAll)
infectedAllMin <- pldhivTemp$lower / (1 - undiagAllMin)
infectedAllMax <- pldhivTemp$upper / (1 - undiagAllMax)

# Caculate PLHIV for fixed deathrate and save
if(cascadeImpact) {
  infectedFix <- pldhivFix  / (1 - undiagAll)
  infectedFixMin <- pldhivFixMin / (1 - undiagAllMin)
  infectedFixMax <- pldhivFixMax / (1 - undiagAllMax)
  
  # Save results
  fixedResults <- data.frame(year = allYears,
                             plhiv = infectedFix,
                             lower = infectedFixMin,
                             upper = infectedFixMax)
  
  # Save dataframe as an R data file
  saveString <- file.path(outputFolder, paste("plhivFixedDr-", 
    toString(analysisYear), sep = ""))
  
  save(fixedResults, file = paste(saveString, ".rda", sep =""))
}

# Store overall results
hivUndiag <- rbind(hivUndiag, data_frame(stage = "infected", 
                            year = allYears, 
                            population = "all", 
                            value = infectedAll,
                            lower = infectedAllMin,
                            upper = infectedAllMax))

# Calculate undiagnosed for each state -----------------------------------
statesUndiag <- head(states, -1)

for (region in statesUndiag) {
  pldhivTemp <- filter(hivDiagnosed, stage == "pldhiv", 
                       population == region)
  infectedState <- pldhivTemp$value / (1 - undiagAll)
  infectedStateMin <- pldhivTemp$lower / (1 - undiagAllMin)
  infectedStateMax <- pldhivTemp$upper / (1 - undiagAllMax)
  
  # Store results 
  hivUndiag <- rbind(hivUndiag, data_frame(stage = "infected", 
                                           year = allYears, 
                                           population = region, 
                                           value = infectedState,
                                           lower = infectedStateMin,
                                           upper = infectedStateMax))
}

# Calculate undiagnosed for each exposure group --------------------------

for (mode in modes) {
  pldhivTemp <- filter(hivDiagnosed, stage == "pldhiv", 
                       population == mode)
  
  if (mode == "msm") {
    infectedExp <- pldhivTemp$value / (1 - undiagMSM)
    infectedExpMin <- pldhivTemp$lower / (1 - undiagMSMMin)
    infectedExpMax <- pldhivTemp$upper / (1 - undiagMSMMax)
  } else if (mode == "pwid") {
    infectedExp <- pldhivTemp$value / (1 - undiagPWID)
    infectedExpMin <- pldhivTemp$lower / (1 - undiagPwidMin)
    infectedExpMax <- pldhivTemp$upper / (1 - undiagPwidMax)
  } else if (mode == "hetero") {
    infectedExp <- pldhivTemp$value / (1 - undiagHetero)
    infectedExpMin <- pldhivTemp$lower / (1 - undiagHeteroMin)
    infectedExpMax <- pldhivTemp$upper / (1 - undiagHeteroMax)
  } else {
    # Other exposure -- assume same as all
    infectedExp <- pldhivTemp$value / (1 - undiagAll)
    infectedExpMin <- pldhivTemp$lower / (1 - undiagAllMin)
    infectedExpMax <- pldhivTemp$upper / (1 - undiagAllMax)
  }  
  
  # Store results 
  hivUndiag <- rbind(hivUndiag, data_frame(stage = "infected", 
                                           year = allYears, 
                                           population = mode,  
                                           value = infectedExp,
                                           lower = infectedExpMin,
                                           upper = infectedExpMax))
}               

# Calculate undiagnosed for each population group -------------------------
for (pop in pops) {
  pldhivTemp <- filter(hivDiagnosed, stage == "pldhiv", 
                       population == pop)
  
  # Use overall undiagnosed proportion for non-indigenous and other cob. 
  # For indigenous, bornssa, born sea use non_msm undiagnosed proportion
  if (pop == "non-indigenous" | pop == "othercob" | pop == "bornsea") {
    infectedPop <- pldhivTemp$value / (1 - undiagAll)
    infectedPopMin <- pldhivTemp$lower / (1 - undiagAllMin)
    infectedPopMax <- pldhivTemp$upper / (1 - undiagAllMax)
  } else if (pop == "bornssa"){
    infectedPop <- pldhivTemp$value / (1 - undiagHetero)
    infectedPopMin <- pldhivTemp$lower / (1 - undiagHeteroMin)
    infectedPopMax <- pldhivTemp$upper / (1 - undiagHeteroMax)
  } else {
    # Indigenous and need to do a weighted calculation
    undiagIndig <- propAborigMSM * undiagMSM + 
      (1 - propAborigMSM) * undiagNonMSM
    undiagIndigMin <- propAborigMSM * undiagMSMMin + 
      (1 - propAborigMSM) * undiagNonMsmMin
    undiagIndigMax <- propAborigMSM * undiagMSMMax + 
      (1 - propAborigMSM) * undiagNonMsmMax
    
    infectedPop <- pldhivTemp$value / (1 - undiagIndig)
    infectedPopMin <- pldhivTemp$lower / (1 - undiagIndigMin)
    infectedPopMax <- pldhivTemp$upper / (1 - undiagIndigMax)
  }
  
  # Store results 
  hivUndiag <- rbind(hivUndiag, data_frame(stage = "infected", 
                                           year = allYears, 
                                           population = pop, 
                                           value = infectedPop,
                                           lower = infectedPopMin,
                                           upper = infectedPopMax))
}

# Calculate undiagnosed for each gender ----------------------------------
hivGenUndiag <- data.frame(stage = character(), 
                           year = double(),
                           population = character(),
                           estimate = double(),
                           lower = double(),
                           upper = double())

for (gender in genders) {
  pldhivTemp <- filter(hivDiagGender, stage == "pldhiv", 
                       population == gender)
  
  if (gender == "male") {
    infectedPop <- pldhivTemp$value / (1 - undiagMSM)
    infectedPopMin <- pldhivTemp$lower / (1 - undiagMSMMin)
    infectedPopMax <- pldhivTemp$upper / (1 - undiagMSMMax)
  } else if (gender == "female") {
    infectedPop <- pldhivTemp$value / (1 - undiagNonMSM)
    infectedPopMin <- pldhivTemp$lower / (1 - undiagNonMsmMin)
    infectedPopMax <- pldhivTemp$upper / (1 - undiagNonMsmMax)
  } else {
    infectedPop <- pldhivTemp$value / (1 - undiagAll)
    infectedPopMin <- pldhivTemp$lower / (1 - undiagAllMin)
    infectedPopMax <- pldhivTemp$upper / (1 - undiagAllMax)
  }
  
  # Store results 
  hivGenUndiag <- rbind(hivGenUndiag, data_frame(stage = "infected", 
                                          year = allYears, 
                                          population = gender, 
                                          value = infectedPop,
                                          lower = infectedPopMin,
                                          upper = infectedPopMax))
}

# Merged with gender PLDHIV and extract 2014 results
genderTemp <- rbind(hivGenUndiag, hivDiagGender)
genderTemp <- filter(genderTemp, year == 2014)

# Store gender results 
hivUndiag <- rbind(hivUndiag, hivGenUndiag)

# Write to file for Skye

# Finally bind to overall results ----------------------------------------
if (bindCascade) {
  hivCascade <- rbind(hivCascade, hivUndiag)
}

# Replace values with hard coded if necessary
if (replaceValues) {
  tempHardCode <- filter(hardCodeValues, stage == "infected")
  if (nrow(tempHardCode) > 0) {
    hivCascade <- replaceEstimates(hivCascade, tempHardCode)
  }
}

```

## Number linked to care

```{r linked}
# Now estimate the number living with diagnosesd HIV who have been linked 
# to care 

# Overall annual results ------------------------------------------------
hivLinkedAll <- hivSet %>% 
  group_by(yeardiagnosis) %>% 
  filter(linked == "yes") %>%
  summarise(linked = n()) %>% 
  mutate(totallinked  = cumsum(linked)) %>% 
  filter(yeardiagnosis <= analysisYear) 

# Manually insert first two years as they are missing
hivLinkedAll <- rbind(hivLinkedAll, c(1980, 0, 0))
hivLinkedAll <- rbind(hivLinkedAll, c(1981, 0, 0))
hivLinkedAll <- arrange(hivLinkedAll, yeardiagnosis)

# Calculate number linked to care using national death rates and migration rates
cumLinked <- hivLinkedAll$totallinked
linkedAll <- LivingDiagnosed(cumLinked, deathRate, migrationRate)
linkedAllMin <- LivingDiagnosed(cumLinked, deathRateMax, migrationRateMax)
linkedAllMax <- LivingDiagnosed(cumLinked, deathRateMin, migrationRateMin)

# ISSUE: Number linked to care with above methodology seems too low. An 
# An alternative is to look at the proportion linked each year.
uniqueDiags <- c(hivResults$uniquecases[1], diff(hivResults$uniquecases))
propLinked <- hivLinkedAll$linked / uniqueDiags

# Look at the trend since 2000
propl <- data.frame(year = allYears, proportion = propLinked)
lmlinked <- lm(proportion ~ year, data = filter(propl, year > 2000))
predictlinked <- predict(lmlinked, data.frame(year = allYears))

# Some basic tests
# LivingDiagnosed(cumsum(uniqueDiags * predictlinked),deathRate, 
# migrationRate)
# LivingDiagnosed(cumsum(uniqueDiags * predictlinked),deathRate, 
# rep(0,length(migrationRate)))

# Add results to hivResults 
hivResults$numlinked <- hivLinkedAll$linked
hivResults$proplinked <- propLinked

# Create a plot to show the fitting of the proportion linked 
if (plots) {
  plotData <- data.frame(year = allYears, 
                       proportion = proplinked, 
                       prediction = predictlinked)
  
  plotLinked <- ggplot(data = plotData, aes(x = year, y = proportion)) + 
    geom_line() + 
    geom_line(aes(y = predictlinked), color  = "blue") + 
    theme_bw() + plotOpts + ylim(c(0,NA)) + xlab("Year") + 
    ylab("Proportion annual notifications linked")
    
  # Print figures  
  ggsave(file.folder(figuresFolder, "prop_linked.png"),
  plot = plotLinked, width = 5, height = 5)
}

# Add linked to cascade ---------------------------------------------------

if (includeLinked) {
  
  # Start final results data frame
  hivLinkCare <- data.frame(stage = "linked", 
                            year = allYears, 
                            population = "all", 
                            value = linkedAll,
                            lower = linkedAllMin,
                            upper = linkedAllMax)
  
  
  # State calculations ---------------------------------------------------
  hivLinkedState <- hivSet %>% group_by(state, yeardiagnosis) %>% 
    filter(linked == "yes") %>%
    summarise(linked = n()) %>% 
    mutate(totallinked = cumsum(linked)) %>%
    filter(yeardiagnosis <= analysisYear) 
  
  for (region in states) {
    tempLinked <- filter(hivLinkedState, state == region)
    tempLinked <- FillMissing(allYears, tempLinked$yeardiagnosis, 
                              tempLinked$totallinked)
    
    cumLinked <- tempLinked$value
    
    # State migration rates
    migStateRate <- filter(hivMigrate, state == region)$rate
    migStateRateMin <- filter(hivMigrate, state == region)$lower
    migStateRateMax <- filter(hivMigrate, state == region)$upper
    
    # State departures
    depStateRate <- filter(hivInterstate, state == region)$departrate
    
    # State arrivals
    arrStateRate <- filter(hivInterstate, state == region)$arriverate
    
    # Do the state calculation and range
    linkedState <- LivingDiagnosed(cumLinked, deathRate, migStateRate,
                                   arrStateRate, depStateRate, pldhivAll)
    
    linkedStateMin <- LivingDiagnosed(cumLinked, deathRateMax, 
      migStateRateMax, arrStateRate, depStateRate, pldhivAll)
    
    linkedStateMax <- LivingDiagnosed(cumLinked, deathRateMin,
      migStateRateMin, arrStateRate, depStateRate, pldhivAll)  
    
    # Store state results 
    hivLinkCare <- rbind(hivLinkCare, data_frame(stage = "linked", 
                                                 year = allYears, 
                                                 population = region, 
                                                 value = linkedState,
                                                 lower = linkedStateMin,
                                                 upper = linkedStateMax))
    
  }
  
  # Exposure mode calculations --------------------------------------------
  hivLinkedExp <- hiSset %>% 
    group_by(expgroup, yeardiagnosis) %>% 
    filter(!is.na(cd4count)) %>%
    summarise(linked = n()) %>% 
    mutate(totallinked = cumsum(linked)) %>%
    filter(yeardiagnosis <= analysisYear) 
  
  for (modes in modes) {
    tempLinked <- filter(hivLinkedExp, expgroup == mode)
    tempLinked <- FillMissing(allYears, tempLinked$yeardiagnosis, 
                              tempLinked$totallinked)
    
    cumLinked <- tempLinked$value
    
    # Exp migration rates, death rates, assumed to be same overall
    
    # Do the Exp calculation and range
    linkedExp <- LivingDiagnosed(cumLinked, deathRate, migrationRate)
    
    linkedExpMin <- LivingDiagnosed(cumLinked, deathRateMax, 
                                    migrationRateMax)
    linkedExpMax <- LivingDiagnosed(cumLinked, deathRateMin, 
                                    migrationRateMin)
    
    # Store the state results
    hivLinkCare <- rbind(hivLinkCare, data_frame(stage = "linked", 
                                                 year = allYears, 
                                                 population = mode, 
                                                 value = linkedExp,
                                                 lower = linkedExpMin,
                                                 upper = linkedExpMax))
  }
  
  # Finally bind to overall results
  if (bindCascade) {
    hivCascade <- rbind(hivCascade, hivLinkCare)
  }
}

# Replace values with hard coded if necessary
if (replaceValues) {
  tempHardCode <- filter(hardCodeValues, stage == "linked")
  if (nrow(tempHardCode) > 0) {
    hivCascade <- replaceEstimates(hivCascade, tempHardCode)
  }
}

```

## Number taking ART

```{r treatment}
# Calculate the number taking ART during the year. This uses a mixture of 
# data sets as the Prospection data is only available for 2013-2014. For 
# the  national overall estimates we use previously generated estimates
# produced by the script 0-ArtAnalysis.Rmd. 

# Note values are all data estimates except for the year 2012 for the 
# national data which is replaced by a fitted value

# Load up to 2000-2014 ART estimates -- we will use other data for
# >= 2013
artEstimates <- read.csv(file.path(dataFolder, "ART_Estimates-2014.csv"))

# Reload Prospection PBS data to get gender and state estimates
prospectionData <- read.csv(file.path(dataFolder, 
  paste0("pharmdash_HIVpatients", toString(analysisYear), 
    ".csv")), as.is = c(1, 2))

# Tidy up the prospection data
hivTreatedPbs <- prospectionData %>%
  filter(gender == "all") %>%
  select(-gender) %>%
  tbl_df()

yearNames <- strsplit(toString(2013:analysisYear), ", ")[[1]]

colnames(hivTreatedPbs) <- c("population", yearNames)
hivTreatedPbs <- gather(hivTreatedPbs,"year", "value",
                        2:ncol(hivTreatedPbs))
hivTreatedPbs$year <- as.numeric(as.character(hivTreatedPbs$year))

# Append overall gender data 
genderTreatedPbs <- prospectionData %>%
  filter(gender %in% c("m", "f"), state == "all") %>%
  select(-state) %>%
  mutate(gender = c("male", "female")) %>%
  tbl_df()

colnames(genderTreatedPbs) <- c("population", yearNames)

genderTreatedPbs <- gather(genderTreatedPbs,"year", "value",
                        2:ncol(genderTreatedPbs))
genderTreatedPbs$year <- as.numeric(as.character(genderTreatedPbs$year))

hivTreatedPbs <- bind_rows(hivTreatedPbs, genderTreatedPbs)

# Set-up range columns
hivTreatedPbs$lower <- NA
hivTreatedPbs$upper <- NA

# Sort out artEstimates
artEstimates <- artEstimates %>%
  select(year, alladjust, fitmin, fitmax, rel, rellower, relupper) %>%
  rename(value = alladjust, lower = fitmin, upper = fitmax, 
         trend = rel, trendlwr = rellower, trendupr = relupper) %>%
  mutate(population = "all") %>%
  select(population, everything())

# Bind all our ART data together
hivTreated <- rbind(filter(select(artEstimates, -contains("trend")), 
                           year <= 2012), 
                    filter(hivTreatedPbs, population == "all"),
                    filter(hivTreatedPbs, population != "all"))

# Add stage column
hivTreated$stage <- "numART"

# Calculate number on treatment for states and genders --------------------

# Use the relative rates to number in states

populations <- c("nsw", "vic", "qld", "nt",  "wa",  "sa",  "tas", "act", 
            "male", "female")

# Estimate state values for 2000-2012 using artEstimate trends (up to 2014)
for (pop in populations) {
  # Extract final year data 
  treatFinal <- filter(hivTreated, population == pop,
                       year %in% c(2013:2014))
  
  # index positions
  indexFinal <- nrow(artEstimates)
  index2013 <- nrow(filter(artEstimates, year <= 2013))
  
  # Calculate estimates and ranges
  tempFit <- treatFinal$value[nrow(treatFinal)] * artEstimates$trend
  tempFit[index2013:indexFinal] <- treatFinal$value
  tempLwr <- tempFit * artEstimates$trendlwr
  tempUpr <- tempFit * artEstimates$trendupr
  
  # Create a data frame 
  tempDf <- data_frame(population = pop, year = 2000:2014,
                       value = tempFit, lower = tempLwr, upper = tempUpr, 
                       stage = "numART")
  
  # Append data prior to 2013 
  hivTreated <- rbind(hivTreated, filter(tempDf, year <= 2012))
}

# Order by state and year
hivTreated <- hivTreated %>%
  arrange(population, year) %>%
  filter(year <= analysisYear)


# calculate uncertainty in Prospection data -------------------------------
popData <- read_excel(file.path(dirname(dirname(dataFolder)), "data",
                                "ABS_population_sizes.xlsx"),
                      sheet = 2)
source(file.path(Rcode, "pharmDashError.R"), echo=TRUE)

# Loop through years and regions appending lower and upper
prospectionYears <- c(2013, 2014, 2015)
regions <- c(populations, "all")

for (nyear in prospectionYears) {
 for (pop in regions) {
   numArt <- filter(hivTreated, year == nyear, population == pop)$value
   numPop <- filter(popData, year == nyear, population == pop)$erp
   
   error <- PharmDashError(numPop, numArt)
   
   hivTreated[(hivTreated$year == nyear & 
                 hivTreated$population == pop) , ]$lower <- error$lower
   hivTreated[(hivTreated$year == nyear & 
                 hivTreated$population == pop) , ]$upper <- error$upper
   
   } 
}

# Add medicare ineligibles
if (addTempRes) {
  
  # Load the temporary resident estimates
  tempResArt <- read.csv(file.path(dataFolder,
                                   "ART_medicare_ineligible.csv"))
  
  # Replace with updated values
  for (ii in 1:nrow(tempResArt)) {
    hivTreated <- hivTreated %>%
      mutate(value = ifelse(population == tempResArt$population[ii] &
                            year == tempResArt$year[ii] &
                            stage == "numART", 
                            value + tempResArt$value[ii],
                            value),
             lower = ifelse(population == tempResArt$population[ii] &
                            year == tempResArt$year[ii] &
                            stage == "numART", 
                            lower + tempResArt$lower[ii],
                            lower),
             upper = ifelse(population == tempResArt$population[ii] &
                            year == tempResArt$year[ii] &
                            stage == "numART", 
                            upper + tempResArt$upper[ii],
                            upper))
  }
}

# Finally bind to overall results
if (bindCascade) {
  hivCascade <- rbind(hivCascade, hivTreated)
}

# Do some plots if required -----------------------------------------------
if (plots) {
  treatPlot1 <- ggplot(data = relTreat, aes(x = year, y = fit)) + 
    geom_point(data = s100data, aes(x = year, y =  relative), 
               color = "black", size = 4) + 
    geom_line(color = "red") +
    geom_line(aes(y = lwr), color = "blue", linetype = "dashed") +
    geom_line(aes(y = upr), color = "blue", linetype = "dashed") +
    scale_x_continuous(breaks = seq(2005, analysisYear, by =2)) +
    ylim(c(0,1.5)) +  
    ylab("Relative number on treatment") + xlab("Year") + 
    ggtitle("Fitted number on ART relative to 2012 
            (based on s100 spending)") + 
    plotOpts
  
  treatPlot2 <- ggplot(data = filter(hivTreated, population == "all"), 
                       aes(x = year, y = value)) +
    geom_line(color = "red") + 
    geom_line(aes(y = lower), color = "blue", linetype = "dashed") + 
    geom_line(aes(y = upper), color = "blue", linetype = "dashed") + 
    geom_point(data = filter(hivTreated, population == "all", 
                             year >= 2013), color = "black", size = 4) +
    scale_x_continuous(breaks = seq(2005, analysisYear, by =2)) +
    ylim(0,NA) + 
    ylab("Number on treatment") + xlab("Year") + 
    ggtitle("National number on ART") + 
    plotOpts
  
  # Save to file 
  treatPlot <- grid.arrange(treatPlot1, treatPlot2, ncol = 2)
  ggsave(file.path(figuresFolder, "treatment_rate.png"),
         plot = treatPlot, width = 15, height = 5)
}

# Replace values with hard coded if necessary
if (replaceValues) {
  tempHardCode <- filter(hardCodeValues, stage == "numART")
  if (nrow(tempHardCode) > 0) {
    hivCascade <- replaceEstimates(hivCascade, tempHardCode)
  }
}

```

## Number retained in care

```{r retained}
# Calculate the number retained in care during the year. This uses a 
# mixture of data sets from MBS and AHOD plus the number of people 
# recieving treatment. 

# Initialize final results data frame using hivtreated
hivRetained <- data.frame(stage = character(), 
                         year = double(),
                         population = character(),
                         value = double(),
                         lower = double(),
                         upper = double())

if (useClinic) {
  # Use McMahon et al data for 2013 onwards
  # Hardcoded: value, lower, upper.  Lower and upper ranges correspond 
  # to the range for the percentage retained after follow-up in McMahon 
  # et al., Clinic Network Collaboration and Patient Tracing to Maximize 
  # Retention in HIV Care, PLOS One, May 26, 2015.
  vicClinicData <- c(0.95, 0.914, 0.988)
  
  # Calculated retained in care post 2014 for all the main populations
  mainPops <- c("all", "nsw", "vic", "qld", "msm", "non-indigenous",
                "male", "female")
  
  hivRetained <- hivDiagnosed %>%
    filter(year >= 2013, population %in% mainPops) %>%
    mutate(retained = value * vicClinicData[1],
           retain_lower = lower * vicClinicData[2],
           retain_upper = upper * vicClinicData[3]) %>%
    select(-stage, -value, -lower, -upper) %>%
    rename(value = retained, lower = retain_lower, upper = retain_upper)
  #
  hivRetained$stage <- "retained"
  
} else {
  # Use old Medicare testing data approach --------------------------------
  
  # NOTE: this approach does not appear to produce reliable results and
  # is needs to be reviewed in detail and tidied up. 
  
  # Load all the data we need
  mbsFolder <- file.path(path.expand("~"), "Research",
                         "!Evaluation_Modelling","data")
  
  cd4data <- read.csv(file.path(mbsFolder, "MBS_Data_71139-clean.csv"))
  vlnoARTdata <- read.csv(file.path(mbsFolder, "MBS_Data_69378-clean.csv"))
  vlARTdata <- read.csv(file.path(mbsFolder, "MBS_Data_69381-clean.csv"))
  
  # Reload ahodData
  ahodData <- read.csv(file.path(dataFolder, 
                                 paste("ahod", toString(analysisYear), 
                                       ".csv", sep = "")))
  
  # Filter, select and gather the data we need
  cd4data <- cd4data %>%
    filter(sex == "all" & age == "all") %>%
    select(-sex, -age) %>%
    gather("state", "n", 2:10) %>%
    filter(year <= analysisYear)
  
  vlnoARTdata <- vlnoARTdata %>%
    filter(sex == "all" & age == "all") %>%
    select(-sex, -age) %>%
    gather("state", "n", 2:10) %>%
    filter(year <= analysisYear)
  
  vlARTdata <- vlARTdata %>%
    filter(sex == "all" & age == "all") %>%
    select(-sex, -age) %>%
    gather("state", "n", 2:10) %>%
    filter(year <= analysisYear)
  
  # Clean up the AHOD data on number of tests 
  
  # Some of the people of unknown modes have missing data
  replaceVars <- c("medCd4_noRx", "meanCd4_noRx", "medVL_noRx", 
                   "meanVL_noRx", "meanCd4_Rx")
  for (ii in 1:nrow(ahodData)) {
    if (is.na(ahodData$medCd4_noRx[ii])) {
      ahodData$medCd4_noRx[ii] <- filter(ahodData, 
        year == ahodData$year[ii], state == "all", 
        mode == ahodData$mode[ii])$medCd4_noRx
      ahodData$meanCd4_noRx[ii] <- filter(ahodData, 
        year == ahodData$year[ii], state == "all", 
        mode == ahodData$mode[ii])$meanCd4_noRx
      ahodData$medVL_noRx[ii] <- filter(ahodData, 
        year == ahodData$year[ii], state == "all", 
        mode == ahodData$mode[ii])$medVL_noRx
      ahodData$meanVL_noRx[ii] <- filter(ahodData, 
        year == ahodData$year[ii], state == "all", 
        mode == ahodData$mode[ii])$meanVL_noRx
      ahodData$meanCd4_Rx[ii] <- filter(ahodData, 
        year == ahodData$year[ii], state == "all",
        mode == ahodData$mode[ii])$meanCd4_Rx
    }
  }
  
  # Calculate averages across populations
  
  # ahodTests <- ahodData %>% 
  #   group_by(year, state) %>%
  #   summarise(npeople = sum(n_id),
  #             nvltests = sum(meanVL_noRx * n_id),
  #             avevltests = nvltests/npeople,
  #             ncd4Rxtests = sum(meanCd4_Rx * n_id),
  #             avecd4Rxtests = ncd4Rxtests/npeople,
  #             ncd4tests = sum(meanCd4_noRx * n_id),
  #             avecd4tests = ncd4tests/npeople) %>%
  #   filter(year <= analysisYear)
  
  ahodTests <- ahodData %>%
    filter(mode == "all") %>%
    select(-mode) %>%
    filter(year <= analysisYear)
  
  ### Do the calculations for all
  treatYears <- filter(hivtreated, population == "all")$year
  treatValue <- filter(hivtreated, population == "all")$value
  treatLower <- filter(hivtreated, population == "all")$lower
  treatUpper <- filter(hivtreated, population == "all")$upper
  
  if (useCD4) {
    # Using CD4 data
    numTreated <- filter(hivtreated, population == "all" & 
                           year %in% treatYears)$value
    aveCd4_Rx <- filter(ahodTests, state == "all" & 
                          year %in% treatYears)$meanCd4_Rx
    aveCd4_noRx <- filter(ahodTests, state == "all" & 
                            year %in% treatYears)$meanCd4_noRx
    numCd4Tests <- filter(cd4data, state == "all" & year %in% treatYears)$n
    
    receivedCare <- (numCd4Tests - numTreated * aveCd4_Rx)/aveCd4_noRx
    
  } else {
    # Use VL estimates
    avevlTests <- filter(ahodTests, state == "all", 
                         year %in% treatYears)$meanVL_noRx
    numvlTests <- filter(vlnoARTdata, 
                         state == "all", 
                         year %in% treatYears)$n
    
    receivedCare <- (numvlTests/avevlTests)
  }
  
  
  # Bind to hivretained
  hivRetained <- rbind(hivRetained, data.frame(stage = "retained", 
    year = treatYears, population = "all",
    value = receivedCare + treatValue,
    lower = receivedCare + treatLower,
    upper = receivedCare + treatUpper))

  # Do the calculations for each state ------------------------------------
  
  # Loop through states and calculate number suppressed. 
  states <- c("act", "nsw", "vic", "qld", "nt", "wa", "sa", "tas")
  # nstates <- length(states)
  availableStates <- c("all", "nsw", "vic", "qld")
  
  for (region in states) {
    treatValue <- filter(hivtreated, population == region)$value
    treatLower <- filter(hivtreated, population == region)$lower
    treatUpper <- filter(hivtreated, population == region)$upper
    
    numTreated <- filter(hivtreated, population == region & 
                           year %in% treatYears)$value
    numCd4Tests <- filter(cd4data, state == region & 
                            year %in% treatYears)$n
    
    if (useCD4) { 
      # Use CD4 results - warning produces negative numbers for some states 
      # due to number of tests calculations
      if (region %in% availableStates) {
        
        aveCd4_Rx <- filter(ahodTests, state == region & 
                              year %in% treatYears)$meanCd4_Rx
        if (any(is.na(aveCd4_Rx))){
          naindex <- is.na(aveCd4_Rx)
          temp <- filter(ahodTests, state == "all" & 
                           year %in% treatYears)$meanCd4_Rx
          aveCd4_Rx[naindex] <- temp[naindex]
        }
        
        aveCd4_noRx <- filter(ahodTests, state == region & 
                                year %in% treatYears)$meanCd4_noRx
        if (any(is.na(aveCd4_noRx))){
          naindex <- is.na(aveCd4_noRx)
          temp <- filter(ahodTests, state == "all" & 
                           year %in% treatYears)$meanCd4_noRx
          aveCd4_noRx[naindex] <- temp[naindex]
        }
        
      } else {  
        # Not available so use all data
        aveCd4_Rx <- filter(ahodTests, state == "all" & 
                              year %in% treatYears)$meanCd4_Rx
        aveCd4_noRx <- filter(ahodTests, state == "all" & 
                                year %in% treatYears)$meanCd4_noRx
      }
      
      receivedCare <- (numCd4Tests - numTreated * aveCd4_Rx)/aveCd4_noRx
      
    } else {
      # Use VL testing data 
      numvlTests <- filter(vlnoARTdata, state == region & 
                             year %in% treatYears)$n
      
      # Work out average VL tests for each state if available and non-NA
      if (states[ii] %in% availableStates) {
        avevlTests <- filter(ahodTests, state == region & 
                               year %in% treatYears)$meanVL_noRx
        if (any(is.na(avevlTests))){
          naindex <- is.na(avevlTests)
          tempTests <- filter(ahodTests, state == "all" & 
                                year %in% treatYears)$meanVL_noRx
          avevlTests[naindex] <- tempTests[naindex]
        }     
      } else {
        # Not available so use all data
        avevlTests <- filter(ahodTests, state == "all" & 
                               year %in% treatYears)$meanVL_noRx
      }
      
      receivedCare <- (numvlTests/avevlTests)
    }
    # Bind to hivretained
    hivRetained <- rbind(hivRetained, 
                         data.frame(stage = "retained", 
                                    year = treatYears,
                                    population = region,
                                    value = receivedCare + treatValue,
                                    lower = receivedCare + treatLower,
                                    upper = receivedCare + treatUpper))
    
  }
  
  # TODO: calculate by mode of exposure and country of birth
}

# Finally bind to overall results
if (bindCascade) {
  hivCascade <- rbind(hivCascade, hivRetained)
}

# Replace values with hard coded if necessary
if (replaceValues) {
  tempHardCode <- filter(hardCodeValues, stage == "retained")
  if (nrow(tempHardCode) > 0) {
    hivCascade <- replaceEstimates(hivCascade, tempHardCode)
  }
}

```

### Number with suppressed virus

```{r suppressed}
# Calculate the number on ART with suppressed virus during the year. This uses 
# data from AHOD data and the number of people recieving treatment. 

# Initialize final results data frame
hivSuppressed <- data.frame(stage = character(), 
                            year = double(),
                            population = character(),
                            value = double(),
                            lower = double(),
                            upper = double())

# Load all the data we need
ahodData <- read.csv(file.path(dataFolder, 
  paste0("ahod", toString(analysisYear), ".csv")))

# Extract the viral suppression data
propSuppressed <- ahodData %>%
# filter(state == "all") %>%
  select(one_of(c("year", "state", "population", "n_id")), 
         starts_with("n_rx"), -n_rx) %>% 
  group_by(year, state) %>%
  summarise(n = sum(n_id),
            n200 = sum(n_rx200)) %>%
  mutate(prop200 = n200/n) %>%
  # Added 95% confidence interval
  mutate(prop200lower = prop200 - qnorm(0.975) * 
           sqrt(prop200 * (1 - prop200) / n),
         prop200upper = prop200 + qnorm(0.975) * 
           sqrt(prop200 * (1 - prop200) / n)) %>%
  filter(year <= analysisYear) %>%
  ungroup() %>%
  rename(population = state)

# Append male and female data
propSuppressed <- ahodData %>%
  select(one_of(c("year", "state", "population", "n_id")), 
         starts_with("n_rx"), -n_rx) %>% 
  filter(population %in% c("MALE", "FEMALE"), state == "all") %>%
  mutate(population = tolower(population)) %>%
  select(-state) %>%
  group_by(year, population) %>%
  summarise(n = sum(n_id),
            n200 = sum(n_rx200)) %>%
  mutate(prop200 = n200/n) %>%
  # Added 95% confidence interval
  mutate(prop200lower = prop200 - qnorm(0.975) * 
           sqrt(prop200 * (1 - prop200) / n),
         prop200upper = prop200 + qnorm(0.975) * 
           sqrt(prop200 * (1 - prop200) / n)) %>%
  filter(year <= analysisYear) %>%
  bind_rows(propSuppressed, .)

dataStart <- min(propSuppressed$year) 

# TODO: by exposure mode

# Loop through populations and calculate number suppressed. 
populations <- c("act", "nsw", "vic", "qld", "nt", "wa", "sa", "tas",
                 "all", "male", "female")
availablePops <- c("all", "nsw", "vic", "qld", "male", "female")

for (pop in populations) {
  # Proportion suppressed
  if(pop %in% availablePops) {
    tempDf <- filter(propSuppressed, population == pop)
  } else {
    tempDf <- filter(propSuppressed, population == "all")
  }
  
  tempProp <- tempDf$prop200
  tempPropMin <- tempDf$prop200lower
  tempPropMax <- tempDf$prop200upper
  
  # Number treated 
  treatDf <- filter(hivCascade, stage == "numART", 
                    population == pop, year >= dataStart)
  tempTreat <- treatDf$value
  tempTreatMin <- treatDf$lower
  tempTreatMax <- treatDf$upper
  
  # nyears <- length(tempDf$year)
  
  # Number suppressed
  hivSuppressed <- rbind(hivSuppressed, 
                         data.frame(stage = "suppressed",  
                         year = tempDf$year,
                         population = pop,
                         value = tempTreat * tempProp,
                         lower = tempTreatMin * tempPropMin,
                         upper = tempTreatMax * tempPropMax)) 
}

### TODO: number suppressed by exposure and country of birth. 
# Once we work out how to do it

# Finally bind to overall results
if (bindCascade) {
  hivCascade <- rbind(hivCascade, hivSuppressed)
}

# Replace values with hard coded if necessary
if (replaceValues) {
  tempHardCode <- filter(hardCodeValues, stage == "suppressed")
  if (nrow(tempHardCode) > 0) {
    hivCascade <- replaceEstimates(hivCascade, tempHardCode)
  }
}

```


```{r cleanup}
# Save HIV results dataframe
if (saveResults) {
  # Directory and file name
  saveString <- file.path(outputFolder, 
    paste("HIVresults-", toString(analysisYear), sep = ""))
  
  # Write to csv
  write.csv(hivResults, file = paste(saveString, ".csv", sep =""), 
            row.names = FALSE)
  
  # Save as R object
  save(hivResults, file = paste(saveString, ".rda", sep =""))
  save(hivGender, hivDiagGender, 
       file = paste(saveString, "_gender.rda", sep =""))
}

# Save PLDHIV stage and hivInterstate - used for the ECDC model estimates
if (savePldhiv) {
  # Directory and file name - PLDHIV
  saveStringPldhiv <- file.path(outputFolder, 
    paste("HIVpldhivEstimates-", toString(analysisYear), sep = ""))
  
  # Write to csv
  write.csv(hivDiagnosed, file = paste(saveStringPldhiv, ".csv", sep =""), 
            row.names = FALSE)
  
  # Save as R object
  save(hivDiagnosed, file = paste(saveStringPldhiv, ".rda", sep =""))
  
  # Directory and file name - hivInterstate
  saveStringInter<- file.path(outputFolder, 
    paste("HIVinterstateEstimates-", toString(analysisYear), sep = ""))
  
  # Write to csv
  write.csv(hivInterstate, file = paste(saveStringInter, ".csv", sep =""), 
            row.names = FALSE)
  
  # Save as R object
  save(hivInterstate, file = paste(saveStringInter, ".rda", sep =""))
}

# Save final HIV cascades data frame
if (saveCascade) {
  # Directory and file name
  saveString <- file.path(outputFolder, paste("HIVcascadeEstimates-", 
    toString(analysisYear), sep = ""))
  
  # Write to csv
  write.csv(hivCascade, file = paste(saveString, ".csv", sep =""), 
            row.names = FALSE)
  
  # Save as R object
  save(hivCascade, file = paste(saveString, ".rda", sep =""))
}

```
