Calculation for number of people living with diagnosed HIV
==========================================================

Neil Bretana and Richard T. Gray

This script is used for calculating the number of people 
living with diagnosed HIV in Australia. This is one of the key steps for
producing the estimates of the Australian HIV diagnosis and care cascade. 

This script is part of a project containing version 3.0 of the HIV cascade
calculation scripts. 

```{r Initialization}
# Chunk to setup everything

# Open as a project (setting working directory to source and restarting R)

# Setup directories
basePath <- getwd()
Rcode <- file.path(dirname(basePath), "code") # All cascades code
HIVcode <- file.path(basePath, "code") 
dataFolder <- file.path(basePath, "data")
outputFolder <- file.path(basePath, "output")
figuresFolder <- file.path(basePath, "output", "figures")

# Notifications folder is a private secure folder 
notificationsFolder <- file.path("/", "SVR-NAS", "Public", "SERP", "Data", 
  "National HIV Registry", "2017", "National", "Hamish & Richard")

# Load standard libraries and options ------------------------------------
source(file.path(Rcode, "LoadLibrary.R"))
# source(file.path(Rcode, "DataLibraries.R"))
# source(file.path(Rcode, "PlotOptions.R"))
LoadLibrary(tidyverse)
# LoadLibrary(tibble)
```

The following chunck specifies all the parameters for producing the
estimates of PLHIV previously diagnosed. Result files are saved to the
specified project folder and have a cascade file handle. 

*Current projects*
- ASR_2017 (2017 ASR cascades for year 2016)
- CALD_Cascades
- Paper_2016 (national cascade for paper)
- Aging_Estimates (todo)

```{r Script parameters}
# Chunk to enter all the script parameters we will use
analysisYear <- 2017
saveResults <- TRUE

# Set HIV subsetting function parameters----------------------------------

projectOutput <- "ASR_2018" # "." for main output folder 

# cascadeName <- paste0("NSW_Vic_All-", toString(analysisYear))
cascadeName <- "All"
targetGender <- "all" # all, male, female (single)
targetAge <- "all" # all or split

# Note regarding ageing: The calculations don't specifically target 
# specific ages.  Rather this simply chooses whether age is considered or 
# not."all" means there is no division by age whereas "split" means teh 
# calculations are doen for all agegroups specified as a0_4, a5_9, 
# a10_14,...,a85+ (5 year age bins). To estimate for specific age run with
# split and then filter out age estimates as required essentially turns on 
# doAge below. 

targetCob <- "all" # all=including n/a, Thailand, etc. (combination)
                         # "non-australia", "non-aus-nz"
targetExposure <- "all" #msm, hetero, pwid, otherexp (combination)
targetAtsi <- "all" # all, indigenous or non_indigenous.
# Only used if country is Australia (single)
targetState <- "all" # nsw, sa, nt, qld, vic, wa, act, tas
# (combination)
targetLocalRegion <- "all" #tbd (combination)
targetGlobalRegion <- "all" # South-East Asia, Sub-Saharan Africa, 
# Oceania, South American, Other cob, etc
# (combination)

# Some error checking 
if ((length(targetGender) > 1) || (length(targetAtsi) > 1)) {
  stop("Error: targetGender or targetAtsi not a single value") 
}

if (targetAtsi != "all" && targetCob[1] != "Australia" &&
    length(targetCob) != 1) {
  stop("Error: indigenous status only valid for Australian born")   
}

# Script options for calculations
interState <- ifelse(targetState[1] != "all", TRUE, FALSE)
doAge <- ifelse(targetAge == "split", TRUE, FALSE) # TRUE for ageing

if (targetCob[1] != "all" || targetGlobalRegion[1] != "all") {
  # Separate out  know indigenous notifications so they don't affect
  # country of bith adjustement estimates as they are assumed to be all
  #  known and 
  separateAborig <- TRUE
} else {
  separateAborig <- FALSE
}

doRetained <- TRUE # TRUE for appending retained in care
doRetained <- ifelse(doAge, FALSE, doRetained) # Turn off for ageing
if (doRetained) {
  # Need to specify years for reatined in care calculations
  # This is simply a proportion based on James McMahon's paper
  # which suggested 92-98% of PLDHIV were retained in care. 
  retainedYears <- 2013:analysisYear
}

doUnique <- TRUE
yearUnique <- NULL
saveUnique <- FALSE

doUnique <- ifelse(targetAtsi == "indigenous", FALSE, doUnique)
yearUnique <- ifelse(is.null(yearUnique), 2100, yearUnique) # Well past today
saveUnique <- ifelse(!saveResults, FALSE, saveUnique)
  
# Settings for generating ECDC model inputs ------------------------------
ecdcData <- TRUE
ecdcData <- ifelse(doAge, FALSE, ecdcData) # Turn off for ageing

ecdcVersion <- '1.2.2'
excludeOS <- FALSE
excludeOS <- ifelse(!ecdcData, FALSE, excludeOS) # Turn off

ecdcModel <- cascadeName # name
if (excludeOS) {
  # If excludeOS don't save the pldhiv estimates as we are only using this
  # for ECDC calculations
  saveResults <- FALSE
  doRetained <- FALSE
}

# Leave projections chunk turned off so it is not called unless required. 
# Simply run projections from within the chunk. 
projectPldhiv <- FALSE 

# Store paramaters for saving
hivParams <- data.frame(cascadeName, targetGender, targetAge, targetCob,
  targetExposure, targetAtsi, targetState, targetLocalRegion,
  targetGlobalRegion, interState, doAge, separateAborig, doRetained,
  doUnique, yearUnique, ecdcData, ecdcVersion, excludeOS)

```

```{r Functions}
# Load functions used for analysis 

# Source functions for filling in missing data
source(file.path(Rcode, "FillMissing.R"))
source(file.path(Rcode, "FillDataFrame.R"))

# Load function to calculate number living with diagnosed HIV
source(file.path(HIVcode,"LivingDiagnosed.R"))
source(file.path(HIVcode,"LivingDiagnosedAge.R"))

# Function to easily extract sub-populations of interest 
source(file.path(HIVcode, "SubHivSet.R"))

# Functions for removing duplicates annually
source(file.path(HIVcode, "DeduplicationFunctions.R"))

# Function to replace estimates
source(file.path(HIVcode, "ReplaceEstimates.R"))

# Function to tidy notifications
source(file.path(HIVcode, "TidyNotifications.R"))

# Functions to output ECDC model data
source(file.path(HIVcode, "EcdcCalculations.R"))
source(file.path(HIVcode, "EcdcFiles.R"))

# Functions for adjustments
source(file.path(HIVcode, "GetAdjustments.R"))
source(file.path(HIVcode, "GetMigrate.R"))
source(file.path(HIVcode, "GetInterRegion.R"))

```

```{r Clean notifications}
# This chunk loads the national notifications and subsets based on the
# specified criteria in Script paramaters

# Load cleaned notifications data from storage
origHivData <- read.csv(file.path(notificationsFolder, 
  paste0("cascadeHIVnotifications-clean-", toString(analysisYear), 
    ".csv"))) 

# Read in country code data
countryCodes <- read.csv(file.path(dataFolder, "countryRegionCodes.csv"))

# Tidy up notifications for calculations
hivData <- TidyNotifications(origHivData, analysisYear, countryCodes)

# Data checks-------------------------------------------------------------

# Quick check that we are not doing analysis outside of the data
if (max(hivData$yeardiagnosis) < analysisYear) {
  stop("No data specified for final year of analysis.")
}

# HIV data variables------------------------------------------------------

# Setup variables for overarching analysis                  
allYears <- min(hivData$yeardiagnosis):analysisYear # all years of data

```

```{r Subset notifications}
# Create subsetted notifications dataframe. May have to do this multiple
# times to get the extact number of specific category and those excluded
# for inter-regional movement. E.g. MSM only in NSW as excluded will have
# non-MSM and non-NSW

if (excludeOS) {
  hivData <- filter(hivData, is.na(previ_diag_overseas))
}

hivSetAll <- filter(hivData, yeardiagnosis <= analysisYear)
annDiagsOrig <- hivSetAll %>% 
  group_by(yeardiagnosis) %>%
  summarise(notifications = n()) %>%
  mutate(totalnotifications = cumsum(notifications)) %>%
  ungroup() 

# May not need to do this anymore.
if (separateAborig) {
  # Set indigenous aside separately to add on later if required
  hivSetIndigenous <- filter(hivSetAll, aboriggroup == 'indigenous')
  hivSetNonIndigenous <- filter(hivSetAll, 
    aboriggroup == 'non_indigenous')
  
  if (targetAtsi == "indigenous") {
    hivSetAll <- hivSetIndigenous
  } else {
    hivSetAll <- hivSetNonIndigenous
  }
}

# Extract subset of notifications we want
hivSetReturn <- SubHivSet(hivSetAll, "all", targetGender,
  targetExposure, targetCob, targetAtsi,
  targetState, targetGlobalRegion)

hivSet <- hivSetReturn[[1]]
hivSetExcluded <- hivSetReturn[[2]]
hivSetUnknown <- hivSetReturn[[3]]

# MAJOR HACK for state cascades to fix subsetting issues for 
# multiple selections
# hivSetExcluded <- filter(hivSetExcluded, state == targetState)

# Calculate unique notifications and duplicates for the known set.
if (doUnique) {
  hivSetUnique <- SubHivSet(hivSetAll, "all", targetGender,
    targetExposure, "all", "all",
    targetState, "all")
  
  uniqueNotifications <- GetUnique(hivSetUnique[[1]], allYears, 
    yearUnique = 2100)
} 

# Calculation cumulative proportion male. This is used for gender weighted
# migration rates

hivSetGender <- hivSet %>% 
  group_by(yeardiagnosis, sex) %>% 
  summarise(notifications = n()) %>% 
  ungroup() %>%
  spread(sex, notifications) %>%
  rename(year = yeardiagnosis)
hivSetGender[is.na(hivSetGender)] <- 0

# Fill in missing years with zeros
hivSetGender <- FillDataFrame(1980:analysisYear, hivSetGender) %>%
  gather("sex", "notifications", 2:ncol(.)) %>%
  arrange(year)

if (targetGender == "all") {
  hivGenderCum <- hivSetGender %>% 
    group_by(sex) %>% 
    mutate(cumnotifications = cumsum(notifications)) %>%
    ungroup() %>%
    select(-notifications) %>%
    spread(sex, cumnotifications) %>%
    select(-starts_with("unknown")) %>%
    gather("sex", "cumnotifications", 2:ncol(.)) %>%
    mutate(cumnotifications = ifelse(is.na(cumnotifications), 0, 
      cumnotifications)) %>%
    group_by(year) %>% 
    mutate(propnotifications = cumnotifications / sum(cumnotifications)) %>%
    select(-cumnotifications) %>%
    spread(sex, propnotifications) %>%
    mutate(female = ifelse(is.na(female), 0, female),
      male = ifelse(is.na(male), 0, male),
      transgender = ifelse(is.na(transgender), 0, transgender)) 
  
  propDiagsMale <- hivGenderCum$male
} else {
  propDiagsMale <- NULL
} 

if (doAge) {
  
  # Calculation cumulative proportion male for each age group.
  if (targetGender == "all") {
    hivSetGenderAge <- hivSet %>%
      group_by(yeardiagnosis, sex, agebin) %>%
      summarise(notifications = n()) %>%
      ungroup() %>%
      spread(sex, notifications)
    hivSetGenderAge[is.na(hivSetGenderAge)] <- 0
    hivSetGenderAge <- hivSetGenderAge %>%
      mutate(other = female+transgender+unknown) %>%
      rename(year = yeardiagnosis) %>%
      select(year, agebin, male, other)
    hivSetGenderAge[is.na(hivSetGenderAge)] <- 0
    
    # Fill in missing years with zeros - have to do males and others and
    # then rebind seperately
    hivSetMaleAge <- hivSetGenderAge %>%
      select(-other) %>%
      spread(agebin, male)
    hivSetMaleAge[is.na(hivSetMaleAge)] <- 0
    hivSetMaleAge <- FillDataFrame(1980:analysisYear, hivSetMaleAge) %>%
      gather("agebin", "male", 2:20) %>%
      arrange(year)
    
    hivSetOtherAge <- hivSetGenderAge %>%
      select(-male) %>%
      spread(agebin, other)
    hivSetOtherAge[is.na(hivSetOtherAge)] <- 0
    hivSetOtherAge <- FillDataFrame(1980:analysisYear, hivSetOtherAge) %>%
      gather("agebin", "other", 2:20) %>%
      arrange(year)
    
    hivGenderAgeCum <- hivSetMaleAge %>%
      mutate(other = hivSetOtherAge$other) %>%
      group_by(agebin) %>%
      mutate(cummale = cumsum(male),
        cumother = cumsum(other)) %>%
      ungroup() %>%
      select(-male, -other) %>%
      group_by(year, agebin) %>%
      mutate(propmale = cummale / (cummale + cumother)) %>%
      mutate(propmale = ifelse(is.nan(propmale), 1, propmale)) %>%
      select(-cummale, -cumother) %>%
      spread(agebin, propmale)
    
    propDiagsAgeMale <- as.matrix(hivGenderAgeCum)
    
  } else {
    propDiagsAgeMale <- NULL
  } 
}

```

```{r Annual notifications and proportions}
# This chunk creates a dataframe of the annual notifications for the
# specified criteria.

includeDiags <- hivSet %>% 
  group_by(yeardiagnosis) %>%
  summarise(included = n()) %>%
  ungroup() %>%
  rename(year = yeardiagnosis)
includeDiags <- FillDataFrame(allYears, includeDiags)

# If excluded and unknown is empty replace with zeros
if (nrow(hivSetExcluded) == 0) {
  excludedDiags <- data_frame(year = allYears,
    excluded = 0)
} else {
  excludedDiags <- hivSetExcluded %>%
    group_by(yeardiagnosis) %>% 
    summarise(excluded = n()) %>%
    rename(year = yeardiagnosis)
  
}
excludedDiags <- FillDataFrame(allYears, excludedDiags)

if (nrow(hivSetUnknown) == 0) {
  unknownDiags <- data_frame(year = allYears,
    unknown = 0)
} else {
  unknownDiags <- hivSetUnknown %>%
    group_by(yeardiagnosis) %>% 
    summarise(unknown = n()) %>%
    rename(year = yeardiagnosis)
}
unknownDiags <- FillDataFrame(allYears, unknownDiags)

# Adjust included and excluded annual diagnoses propotionally to replace
# unknowns
adjustDiags <- includeDiags %>% 
  left_join(excludedDiags, by = "year") %>%
  left_join(unknownDiags, by = "year") %>%
  mutate(all = included + excluded + unknown) %>%
  mutate(included = ifelse(is.na(included), 0, included),
    excluded = ifelse(is.na(excluded), 0, excluded),
    unknown = ifelse(is.na(unknown), 0, unknown)) %>%
  mutate(prop_included = included / (included + excluded),
    prop_excluded = excluded / (included + excluded)) %>%
  mutate(prop_included = ifelse(is.nan(prop_included), 0, prop_included), 
    prop_excluded = ifelse(is.nan(prop_excluded), 0, 
      prop_excluded)) %>%
  mutate(adjusted_included = included  + unknown * prop_included,
    adjusted_excluded = excluded + unknown * prop_excluded)

if (interState) {
  # Have to do the same thing to get the overall national estimate for 
  # these populations
  hivSetReturnNat <- SubHivSet(hivSetAll, "all", targetGender,
    targetExposure, targetCob, targetAtsi,
    "all", "all")
  
  hivSetNat <- hivSetReturnNat[[1]]
  hivSetExcludedNat <- hivSetReturnNat[[2]]
  hivSetUnknownNat <- hivSetReturnNat[[3]]
  
  includeDiagsNat <- hivSetNat %>% 
    group_by(yeardiagnosis) %>%
    summarise(included = n()) %>%
    ungroup() %>%
    rename(year = yeardiagnosis)
  includeDiagsNat <- FillDataFrame(allYears, includeDiagsNat)
  
  # If excluded and unknown is empty replace with zeros
  if (nrow(hivSetExcludedNat) == 0) {
    excludedDiagsNat <- data_frame(year = allYears,
      excluded = 0)
  } else {
    excludedDiagsNat <- hivSetExcludedNat %>%
      group_by(yeardiagnosis) %>% 
      summarise(excluded = n()) %>%
      rename(year = yeardiagnosis)
    
  }
  excludedDiagsNat <- FillDataFrame(allYears, excludedDiagsNat)
  
  if (nrow(hivSetUnknown) == 0) {
    unknownDiagsNat <- data_frame(year = allYears,
      unknown = 0)
  } else {
    unknownDiagsNat <- hivSetUnknownNat %>%
      group_by(yeardiagnosis) %>% 
      summarise(unknown = n()) %>%
      rename(year = yeardiagnosis)
  }
  unknownDiagsNat <- FillDataFrame(allYears, unknownDiagsNat)
  
  # Adjust included and excluded annual diagnoses propotionally to replace
  # unknowns
  adjustDiagsNat <- includeDiagsNat %>% 
    left_join(excludedDiagsNat, by = "year") %>%
    left_join(unknownDiagsNat, by = "year") %>%
    mutate(all = included + excluded + unknown) %>%
    mutate(included = ifelse(is.na(included), 0, included),
      excluded = ifelse(is.na(excluded), 0, excluded),
      unknown = ifelse(is.na(unknown), 0, unknown)) %>%
    mutate(prop_included = included / (included + excluded),
      prop_excluded = excluded / (included + excluded)) %>%
    mutate(prop_included = ifelse(is.nan(prop_included), 0, 
      prop_included), 
      prop_excluded = ifelse(is.nan(prop_excluded), 0, 
        prop_excluded)) %>%
    mutate(adjusted_included = included  + unknown * prop_included,
      adjusted_excluded = excluded + unknown * prop_excluded)
}

hivResults <- data_frame(year = adjustDiags$year,
  notifications = adjustDiags$adjusted_included,
  cumnotifications = cumsum(adjustDiags$adjusted_included),
  all_notifications = adjustDiags$all,
  all_cumnotifications = cumsum(adjustDiags$all))

# Proportion in each age group--------------------------------------------
# For the known diagnoses calculate proportion by age bin, exposure group,
# cd4 count category and diagnosis type. This will be used to distribute 
# annual notifications for aging PLDHIV.  
if (doAge) {
  agedDiags <- hivSet %>%
    group_by(yeardiagnosis, agebin) %>%
    summarise(diags = n()) %>%
    ungroup() %>%
    spread(agebin, diags) %>%
    rename(year = yeardiagnosis)
  agedDiags[is.na(agedDiags)] <- 0
  
  #fill missing years
  agedDiags <- FillDataFrame(1980:analysisYear, agedDiags) %>%
    gather("agebin", "diagnoses", 2:20) %>%
    arrange(year) %>%
    filter(agebin != "not_reported") %>%
    group_by(year) %>%
    mutate(propdiags = diagnoses / sum(diagnoses)) %>%
    mutate(propdiags = ifelse(is.nan(propdiags), 0 , propdiags)) %>%
    ungroup()
  
  nyears <- analysisYear - 1980 + 1
  nages <- 18
  
  ageList <- c("a0_4", "a5_9","a10_14", "a15_19", "a20_24", "a25_29", 
    "a30_34", "a35_39", "a40_44", "a45_49", "a50_54", "a55_59", 
    "a60_64", "a65_69", "a70_74", "a75_79", "a80_84", "a85+")
  
  yearList <- paste0("y", as.character(1980:analysisYear))
  
  # Adjust_included notifications by age and year and convert to matrix
  hivResultsAge <- agedDiags %>% 
    left_join(., hivResults, by = "year") %>% 
    select(-diagnoses, -cumnotifications, -all_notifications,
      -all_cumnotifications) %>%
    group_by(year, agebin) %>%
    mutate(diags = propdiags * notifications) %>%
    select(-propdiags, -notifications) %>%
    spread(year, diags) %>%
    ungroup() %>%
    slice(c(1,10,2:9,11:18)) %>%
    select(-agebin) %>%
    as.matrix()
  
  colnames(hivResultsAge) <- yearList
  rownames(hivResultsAge) <- ageList
  
}

```

```{r Load base and adjustment estimates}
# This loads the adjustment files for adjusting the death rates and
# migration rates  
hivBase <- read.csv(file.path(dataFolder, paste0("HIVbaseEstimates-",
  toString(analysisYear), ".csv")))
hivAdjustments <- read.csv(file.path(dataFolder,
  paste0("HIVadjustments-",
    toString(analysisYear), ".csv")))
# hivInterstate <- read.csv(file.path(dataFolder,
#   paste0("HIVinterstateEstimates-",
#     toString(analysisYear), ".csv")))

mainDataFolder <- file.path(dirname(getwd()), "data")
# absMigration <- read.csv(file.path(mainDataFolder,
#   paste0("ABS_migration_clean-", toString(analysisYear), ".csv")),
#   as.is = 1)

# Load cleaned NOM data variable (cleanNom)
load(file = file.path(mainDataFolder, "cleaned_ABS_nom_data.R"))
 
absInterstate <- read_csv(file.path(mainDataFolder, 
  paste0("ABS_interstate_age_sex_clean-", toString(analysisYear), ".csv")))

# Now get the death rates, base migration rates, and proportion stay rates
# Migration rates are now calculated using GetMigrate
subsetRates <- GetAdjustments(hivBase, hivAdjustments, 
  "all", targetGender, targetExposure, targetCob, targetAtsi, 
  targetLocalRegion, targetState, targetGlobalRegion) 

# subsetRatesTest <- GetAdjustments(hivBase, hivAdjustments, 
#   "all", targetGender, targetExposure, "non-australia", targetAtsi, 
#   targetLocalRegion, targetState, targetGlobalRegion)

# Get the annual proportion unique
if (doUnique) {
  subsetRates$cumunique <- uniqueNotifications$cumunique 
  subsetRates$ annunique <- uniqueNotifications$annunique
} 

# Get migration rate adjustments 
relMigration <- GetMigrate(analysisYear, cleanNom, "all",
  targetGender, targetExposure, targetCob, targetAtsi, targetLocalRegion,
  targetState, targetGlobalRegion, propMale = propDiagsMale)

# Adjust migration rate for Indigenous population if required
# Potentially move into GetMigrate
if (targetAtsi == "indigenous" && length(targetCob) == 1 &&
    targetCob[1] == "Australia") {
  relMigration <- 0
} else if ((targetAtsi == "non_indigenous" &&
    targetCob[1] == "Australia")|| targetGlobalRegion[1] != "all" ||
    (targetCob[1] != "all" && targetCob[1] != "Australia")) {
  relMigration <- relMigration *
    hivAdjustments$non_aborig_migration
}

# Final migration rates
subsetRates$mrate <- relMigration * hivBase$migrationrate
subsetRates$mrate_lower <- relMigration * hivBase$migrationrate_lower
subsetRates$mrate_upper <- relMigration * hivBase$migrationrate_upper

if (interState) {
  # For interstate calculations also need overall population estimates
  subsetRatesAll <- GetAdjustments(hivBase, hivAdjustments,
    "all", targetGender, targetExposure, targetCob, targetAtsi, 
    targetLocalRegion, "all", targetGlobalRegion)  
  
  # Get migration rate adjustments 
  relMigrationAll <- GetMigrate(analysisYear, cleanNom, "all",
    targetGender, targetExposure, targetCob, targetAtsi,
    targetLocalRegion, "all", targetGlobalRegion, 
    propMale = propDiagsMale)
  
  # Adjust migration rate for Indigenous population if required
  # Potentially move into GetMigrate
  if (targetAtsi == "indigenous" && length(targetCob) == 1 &&
      targetCob[1] == "Australia") {
    relMigrationAll <- 0
  } else if ((targetAtsi == "non_indigenous" &&
      targetCob[1] == "Australia")|| targetGlobalRegion[1] != "all" ||
      (targetCob[1] != "all" && targetCob[1] != "Australia")) {
    relMigrationAll <- relMigrationAll *
      hivAdjustments$non_aborig_migration
  }
  
  # Final migration rates
  subsetRatesAll$mrate <- relMigrationAll * hivBase$migrationrate
  subsetRatesAll$mrate_lower <- relMigrationAll *
    hivBase$migrationrate_lower
  subsetRatesAll$mrate_upper <- relMigrationAll *
    hivBase$migrationrate_upper
}

# Get interregion rates - only have date since 1982 assume zero rate for
# 1980-81. 
if (interState) {
  interRegionRates <- GetInterRegion(analysisYear, cleanNom, 
    absInterstate, NULL, "all", targetState, targetLocalRegion,
    assumeAdult = TRUE)
  
  subsetRates$inter_arriverate <- interRegionRates$arriverate
  subsetRates$inter_departrate <- interRegionRates$departrate
} else {
  subsetRates$inter_arriverate <- 0
  subsetRates$inter_departrate <- 0
}

if (doAge) {
  # Load age based relative deathrates and migration rates.
  
  # Relative death rates - based on overall data
  hivAgeDeath <- read.csv(file.path(dataFolder,
    paste0("HIVageEstimates-",
      toString(analysisYear), ".csv")))
  relAgeDeath <- hivAgeDeath %>%
    filter(population == targetGender, year <= analysisYear) %>%
    select(year, age, reldeathrate) %>%
    spread(year, reldeathrate) %>%
    select(-age)
  colnames(relAgeDeath) <- yearList
  rownames(relAgeDeath) <- ageList
  
  # Relative migration rates
  relAgeMigrate <- GetMigrateAge(analysisYear, cleanNom, targetGender, 
    targetExposure, targetCob, targetAtsi, targetLocalRegion, targetState, 
    targetGlobalRegion, propMale = propDiagsAgeMale)
  
  colnames(relAgeMigrate) <- yearList
  rownames(relAgeMigrate) <- ageList
  
  if (interState) {
    
  }
}

```

```{r Calculate PLDHIV}
# This chunk fianlly calculates the number of people living with diagnosed
# HIV

if (interState) {
  # A bit more work to do if we do inter-regional migration
  if (doAge) {
    # Do age based calculations
    
  } else {
    # Calculate overall first for inter-regional migration
    pldhivOverall <- LivingDiagnosed(adjustDiagsNat$adjusted_included,
      subsetRatesAll$annunique, 
      subsetRatesAll$deathrate,
      subsetRatesAll$mrate,
      subsetRatesAll$propstay) %>%
      mutate(year = allYears) %>% 
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallMin <- LivingDiagnosed(adjustDiagsNat$adjusted_included,
      subsetRatesAll$annunique,  
      subsetRatesAll$deathrate_upper,
      subsetRatesAll$mrate_upper,
      subsetRatesAll$propstay_lower) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallMax <- LivingDiagnosed(adjustDiagsNat$adjusted_included,
      subsetRatesAll$annunique,  
      subsetRatesAll$deathrate_lower,
      subsetRatesAll$mrate_lower,
      subsetRatesAll$propstay_upper) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    # Now do regional migration
    pldhivAll <- LivingDiagnosed(adjustDiags$adjusted_included,
      subsetRates$annunique, 
      subsetRates$deathrate, 
      subsetRates$mrate,
      subsetRates$propstay,
      arrivals = subsetRates$inter_arriverate, 
      departs = subsetRates$inter_departrate, 
      pldhiv = pldhivOverall$pldhiv) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    # Use best estimate overall for min and max
    pldhivAllMin <- LivingDiagnosed(adjustDiags$adjusted_included,
      subsetRates$annunique,  
      subsetRates$deathrate_upper,
      subsetRates$mrate_upper,
      subsetRates$propstay_lower,
      arrivals = subsetRates$inter_arriverate,
      departs = subsetRates$inter_departrate,
      pldhiv = pldhivOverall$pldhiv) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivAllMax <- LivingDiagnosed(adjustDiags$adjusted_included,
      subsetRates$annunique,  
      subsetRates$deathrate_lower,
      subsetRates$mrate_lower,
      subsetRates$propstay_upper,
      arrivals = subsetRates$inter_arriverate,
      departs = subsetRates$inter_departrate,
      pldhiv = pldhivOverall$pldhiv) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
  } 
} else {
  
  # Do overall calculations only
  if (doAge) {
    # Do age based calculations - age group estimates should almost 
    # always be normalized to the overall estimates as differences in 
    # death rates and migration rates can produce inconsistenices across
    # the age groups. Normalization can be turned off for testing to make
    # sure the results are not too different (comapring 
    # pldhivOverall$pldhiv vs colSums(pldhivAll). 
    
    # Calculate overall (non-age) PLDHIV estimates for normalization
    pldhivOverall <- LivingDiagnosed(adjustDiags$adjusted_included,
      subsetRates$annunique, 
      subsetRates$deathrate,
      subsetRates$mrate,
      subsetRates$propstay) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOveralllMin <- LivingDiagnosed(adjustDiags$adjusted_included,
      subsetRates$annunique,  
      subsetRates$deathrate_upper,
      subsetRates$mrate_upper,
      subsetRates$propstay_lower) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallMax <- LivingDiagnosed(adjustDiags$adjusted_included,
      subsetRates$annunique,  
      subsetRates$deathrate_lower,
      subsetRates$mrate_lower,
      subsetRates$propstay_upper) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    # Calculate age group estimates 
    # NOTE: use base migration rate as mrate is calculated assuming people
    # are aged > 15 years
    pldhivAll <- LivingDiagnosedAge(hivResultsAge,
      subsetRates$annunique, 
      subsetRates$deathrate,
      hivBase$migrationrate, 
      subsetRates$propstay,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      normalize = pldhivOverall$pldhiv) 
    
    pldhivAllMin <- LivingDiagnosedAge(hivResultsAge,
      subsetRates$annunique, 
      subsetRates$deathrate_upper,
      hivBase$migrationrate_upper, 
      subsetRates$propstay_lower,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      normalize = pldhivOveralllMin$pldhiv)
    
    pldhivAllMax <- LivingDiagnosedAge(hivResultsAge,
      subsetRates$annunique, 
      subsetRates$deathrate_lower,
      hivBase$migrationrate_lower, 
      subsetRates$propstay_upper,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      normalize = pldhivOverallMax$pldhiv)
    
    
  } else {
    pldhivAll <- LivingDiagnosed(adjustDiags$adjusted_included,
      subsetRates$annunique, 
      subsetRates$deathrate,
      subsetRates$mrate,
      subsetRates$propstay) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivAllMin <- LivingDiagnosed(adjustDiags$adjusted_included,
      subsetRates$annunique,  
      subsetRates$deathrate_upper,
      subsetRates$mrate_upper,
      subsetRates$propstay_lower) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivAllMax <- LivingDiagnosed(adjustDiags$adjusted_included,
      subsetRates$annunique,  
      subsetRates$deathrate_lower,
      subsetRates$mrate_lower,
      subsetRates$propstay_upper) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
  }
}

# Store results
if (doAge) {
  # Store estimates by year and age
  pldhivDf <- as.data.frame(pldhivAll) %>% 
    rownames_to_column(var = "agebin") %>%
    gather("year", "pldhiv", 2:ncol(.)) %>%
    select(year, everything()) %>%
    mutate(year = as.integer(str_sub(year, 2))) %>%
    as_tibble()
  
  pldhivDfMin <- as.data.frame(pldhivAllMin) %>% 
    rownames_to_column(var = "agebin") %>%
    gather("year", "pldhiv", 2:ncol(.)) %>%
    select(year, everything()) %>%
    mutate(year = as.integer(str_sub(year, 2))) %>%
    as_tibble()
  
  pldhivDfMax <- as.data.frame(pldhivAllMax) %>% 
    rownames_to_column(var = "agebin") %>%
    gather("year", "pldhiv", 2:ncol(.)) %>%
    select(year, everything()) %>%
    mutate(year = as.integer(str_sub(year, 2))) %>%
    as_tibble()
  
  hivDiagnosed <- data.frame(stage = "pldhiv",
    year = pldhivDf$year,
    agebin = pldhivDf$agebin,
    value = pldhivDf$pldhiv,
    lower = pldhivDfMin$pldhiv,
    upper = pldhivDfMax$pldhiv) %>%
    as_tibble()
  
} else {
  # Don't need to store age
  hivDiagnosed <- data.frame(stage = "pldhiv",
    year = allYears,
    value = pldhivAll$pldhiv,
    lower = pldhivAllMin$pldhiv,
    upper = pldhivAllMax$pldhiv)
}

```

```{r ECDC Outputs}
# ECDC calculations-------------------------------------------------------
if (ecdcData) {
  normalizeFactor <- adjustDiags$included / 
    adjustDiags$adjusted_included
  normalizeFactor[is.nan(normalizeFactor)] <- 1
  
  # Folder for ECDC output
  ecdcFolder <- file.path(outputFolder, projectOutput)
  
  if (excludeOS) {
    # excluding OS diagnosis
    dataAll <- EcdcFolders(ecdcFolder, ecdcModel, 
      includeOS = FALSE)
    EcdcFiles(hivSet, dataAll, propUnique = subsetRates$cumunique,
      propKnown = normalizeFactor)
  } else {
    # including OS diagnosis
    dataAll <- EcdcFolders(ecdcFolder, ecdcModel)
    EcdcFiles(hivSet, dataAll, propUnique = subsetRates$cumunique,
      propKnown = normalizeFactor) 
  }
  
  # Create output directory
  resultsEcdcPath <- file.path(ecdcFolder, "ECDC_models", cascadeName)
  
  #save parameters 
  saveStringParams <- file.path(resultsEcdcPath, "Parameters")
  
  # Write to csv
  write_csv(hivParams, paste0(saveStringParams, ".csv"))
  
  # Save deaths and emigrants into ECDC
  
  # All deaths
  deaths <- pldhivAll %>%
    select(year, deaths) %>%
    rename(all = deaths)
  EcdcWrite(deaths, dataAll[[1]], "deaths")
  
  # All emigrants
  if (interState) {
    emigrants <- pldhivAll %>% 
      select(year, emigrants, diag_departs, inter_departs,
        inter_arrivals) %>%
      mutate(total = emigrants + diag_departs + inter_departs -
          inter_arrivals) %>%
      select(year, total) %>%
      rename(all = total)
  } else {
    emigrants <- pldhivAll %>% 
      select(year, emigrants, diag_departs) %>%
      mutate(total = emigrants + diag_departs) %>%
      select(year, total) %>%
      rename(all = total)
  }
  
  EcdcWrite(emigrants, dataAll[[1]], "emigrants")
  
  hivExpCum <- hivSet %>% 
    filter(is.na(previ_diag_overseas)) %>%
    group_by(expgroup, yeardiagnosis) %>% 
    summarise(notifications = n()) %>% 
    ungroup() %>% 
    group_by(expgroup) %>% 
    mutate(cumnotifications = cumsum(notifications)) %>%
    ungroup() %>% 
    select(-notifications) %>%
    spread(expgroup, cumnotifications) 
  
  if (!("hetero" %in% names(hivExpCum))) hivExpCum$hetero <- 0
  if (!("msm" %in% names(hivExpCum))) hivExpCum$msm <- 0
  if (!("otherexp" %in% names(hivExpCum))) hivExpCum$otherexp <- 0
  if (!("pwid" %in% names(hivExpCum))) hivExpCum$pwid <- 0
  if (!("unknown" %in% names(hivExpCum))) hivExpCum$unknown <- 0
  
  hivExpCum <- hivExpCum %>% select(-unknown) %>%
    gather("expgroup", "cumnotifications", 2:5) %>%
    mutate(cumnotifications = ifelse(is.na(cumnotifications), 0, 
      cumnotifications)) %>%
    group_by(yeardiagnosis) %>% 
    mutate(propnotifications = cumnotifications /
        sum(cumnotifications)) %>%
    mutate(propnotifications = ifelse(is.na(propnotifications), 0, 
      propnotifications)) %>%
    select(-cumnotifications) %>%
    ungroup() %>% 
    spread(expgroup, propnotifications) %>%
    rename(year = yeardiagnosis) 
  hivExpCum$msm[2] <- 1.0
  
  expDeaths <- FillDataFrame(1980:analysisYear, hivExpCum, 
    cumulative = TRUE)
  expDeaths[, 2:5] <- expDeaths[, 2:5] * 
    matrix(rep(pldhivAll$deaths, 4), ncol = 4)
  
  EcdcWrite(expDeaths, dataAll[[2]], "deaths")
  
  expEmig <- FillDataFrame(1980:analysisYear, hivExpCum, 
    cumulative = TRUE)
  expEmig[, 2:5] <- expEmig[, 2:5] * 
    matrix(rep(emigrants$all, 4), ncol = 4)
  
  EcdcWrite(expEmig, dataAll[[2]], "emigrants")
  
}

```

```{r Append retained}
if (doRetained) {
  # Perform and append retained in care calculations
  source(file.path(HIVcode, "RetainedCare.R"))
  
  # Load retained in care data - Use McMahon et al data for 2013 onwards
  # Hardcoded: value, lower, upper.  Lower and upper ranges correspond 
  # to the range for the percentage retained after follow-up in McMahon 
  # et al., Clinic Network Collaboration and Patient Tracing to Maximize 
  # Retention in HIV Care, PLOS One, May 26, 2015.
  hivParameters <- read.csv(file.path(dataFolder, 
    "individualHIVparameters.csv"), as.is = 1)
  hivParameters <- select(hivParameters, parameter, value)
  
  for (ii in 1:nrow(hivParameters)) {
    assign(hivParameters$parameter[ii], hivParameters$value[ii])
  }
  
  retained <- vicClinicRetained
  retainedLower <- vicClinicRetainedLower
  retainedUpper <- vicClinicRetainedUpper
  
  hivRetained <- RetainedCare(hivDiagnosed, retained, retainedLower,
    retainedUpper, retainedYears)
  
  # Merge with hivDiagnosed
  hivDiagnosed <- bind_rows(hivDiagnosed, hivRetained)
  
}
```

```{r Save results}
if (saveResults) {
  # Create output directory
  resultsPath <- file.path(outputFolder, projectOutput, cascadeName)
  dir.create(resultsPath, showWarnings = FALSE, recursive = TRUE)
  
  # Save all estimates
  if (doAge) {
    saveStringDetails <- file.path(resultsPath, 
      paste0("pldhiv-", toString(analysisYear), "-age-"))
    write_csv(rownames_to_column(as.data.frame(pldhivAll), var = "agebin"),
      paste0(saveStringDetails, "all.csv"))
    write_csv(rownames_to_column(as.data.frame(pldhivAllMin), 
      var = "agebin"), paste0(saveStringDetails, "min.csv"))
    write_csv(rownames_to_column(as.data.frame(pldhivAllMax), 
      var = "agebin"), paste0(saveStringDetails, "max.csv"))
  } else {
    saveStringDetails <- file.path(resultsPath, 
      paste0("pldhiv-", toString(analysisYear), "-"))
    write_csv(pldhivAll, paste0(saveStringDetails, "all.csv"))
    write_csv(pldhivAllMin, paste0(saveStringDetails, "min.csv"))
    write_csv(pldhivAllMax, paste0(saveStringDetails, "max.csv"))
  }
  
  # Save main results
  saveStringPldhiv <- file.path(resultsPath, 
    paste0("HIVpldhivEstimates-", toString(analysisYear)))
  if (doAge) {
    saveStringPldhiv <- paste0(saveStringPldhiv, "-age")
  }
  write_csv(hivDiagnosed, paste0(saveStringPldhiv, ".csv"))
  
  #save parameters 
  saveStringParams <- file.path(resultsPath, "PldhivParameters")
  
  # Write to csv
  write_csv(hivParams, paste0(saveStringParams, ".csv"))
  
  # Write uniqueNotifications to file
  if (doUnique) {
    saveStringUnique <- file.path(resultsPath, "UniqueNotifications")
    write_csv(uniqueNotifications, paste0(saveStringUnique, ".csv"))
  }
  
}

```

```{r Projections}
# This chunk is used for generating projections of the number of people 
# living with diagnosed HIV. To do the projections we simply make
# assumptions about the future changes to annual diagnoses, deathrates, 
# migration rates into a specified future period.  
# 
# Any change in inputs to LivingDiagnosed function can be manually 
# specified the default is to keep everything the same as the analysis 
# year.
# 
# Any counterfactual or future projection scenario can be manually 
# specified.
# 
# Maybe move this into a separate function or script but fits nicely here.
# projectPldhiv <- TRUE
if (projectPldhiv) { 
  
  # Manually set final year for projections and projection name
  projectYear <- analysisYear + 10  
  projectName <- "future_linear"
  
  # Specifiy projection option for future diagnoses
  projectOption <- "linear" #status-quo, linear, reduce 
  projectDecrease <- 0.65 # 0, 0.65 (35% reduction), 0.5 (50% 
                          # reduction) relative reduction!
  
  saveProjResults <- TRUE 
  # Reset if saving things overall
  saveProjResults <- ifelse(saveResults, TRUE, saveProjResults) 
  
  # Functions for setting up vectors
  End <- function(vector) return(tail(vector, 1))
  ProjVec <- function(vector, nyears) return(c(vector, 
    rep(End(vector), nyears)))
  
  # Setup projection years
  projectYears <- (analysisYear + 1):projectYear
  nprojYears <- length(projectYears)
  totalYears <- c(allYears, projectYears)
  
  # Setup Projection relative decrease (linear over projectYears)
  projectDecreaseFuture <- seq(1, projectDecrease, length = (nprojYears+1))
  projectDecreaseAll <- c(rep(1, nyears), 
    tail(projectDecreaseFuture, nprojYears))
  
  # Default vectors for projections assume everything stays the same.
  # Keeping the number of diagnoses and annUnique the same as the 
  # analysis year value means the same number of unique diagnoses will
  # occur each year. SELECT STANDARD OPTION OR MANUALLY CHANGE TO RUN
  #  ALTERNATE SCENARIOS.
  
  # Diagnoses options
  if (projectOption == "status-quo") {
    diagnosesFuture <- ProjVec(adjustDiags$adjusted_included, nprojYears)
  } else if (projectOption == "linear") {
    # Trend diagnoses (using trend over last 5 years)
    trendlm <- lm(diagnoses ~ year, 
      data.frame(year = (analysisYear - 4):analysisYear, 
        diagnoses = tail(adjustDiags$adjusted_included, 5)))
    trendDiags <- predict(trendlm, data.frame(year = projectYears))
    diagnosesFuture <- c(adjustDiags$adjusted_included, trendDiags)
  } else if(projectOption == "reduce") {
    diagnosesFuture <- projectDecreaseAll * 
      ProjVec(adjustDiags$adjusted_included, nprojYears)
  } else {
    # MANUALLY CHANGE HERE TO RUN ALTERNATE SCENARIOS
  }
  
  # Use trend diagnoses as default - not need different emigration 
  # rates for overall and age calculations because the overall rate assumes
  # all PLDHIV are adults and to align with estimates above up to 
  # analysis year.
  diagnoses <- diagnosesFuture
  annUnique <- ProjVec(subsetRates$annunique, nprojYears)
  deathrate <- ProjVec(subsetRates$deathrate, nprojYears)
  osrateOverall <- ProjVec(subsetRates$mrate, nprojYears)
  osrateAge <- ProjVec(hivBase$migrationrate, nprojYears)
  propStay <- ProjVec(subsetRates$propstay, nprojYears)   
  
  # CHANGE DEFAULTS HERE
  # 
  # Example showing counterfactual to calculate number living 
  # diagnosed before 1996 etc
  # diagnoses[totalYears > 1996] <- 0 
  # projectName <- "pre1996"
  # Example looking at future impact of PrEP after 2016 assuming 
  # 50% reduction in diagnoses
  # diagnoses[totalYears > 2016] <- 0.5 * diagnoses[totalYears > 2016]
  
  # Do future projections
  pldhivAllFuture <- LivingDiagnosed(diagnoses,
    annUnique, 
    deathrate,
    osrateOverall,
    propStay) %>%
    mutate(year = totalYears) %>%
    select(year, everything())
  
  # Do a similar process for each age group if doing age and run in 
  # Living DiagnosedAge(). To do past 5 years age trends we need to loop
  # cross age groups to generate estimates.
  if (doAge) {
    
    # Setup hivResultsAge for future. Most are the same as for the non-age
    # calculations except diagnoses, relAgeDeath, and relAgeMigrate need to
    # be extended into the future
    
    
    # Status quo diagnoses and relative reductions can be applied across
    # the age groups
    
    if (projectOption == "status-quo") {
      hivResultsAgeFuture <- cbind(hivResultsAge,
        matrix(rep(hivResultsAge[,ncol(hivResultsAge-1)], nprojYears), 
          ncol = nprojYears))
      colnames(hivResultsAgeFuture) <- paste0("y", 
        as.character(totalYears))
    } else if (projectOption == "linear") {
      # Project each age group independently
      hivResultsAgeFuture <- cbind(hivResultsAge,
        matrix(0, ncol = nprojYears, nrow = nages))
      colnames(hivResultsAgeFuture) <- paste0("y", 
        as.character(totalYears))
      for (age in 1:nages) {
        # Extract age group diagnoses
        ageDiagnoses <- hivResultsAge[age, ]
        
        # Estimate trends
        trendlm <- lm(diagnoses ~ year, 
          data.frame(year = (analysisYear - 4):analysisYear, 
            diagnoses = tail(ageDiagnoses, 5)))
        trendDiags <- predict(trendlm, data.frame(year = projectYears))
        
        # Make sure diagnoses are at least zero (okay as normalization 
        # should fix this.
        trendDiags[trendDiags < 0] <- 0
        
        # Store final age trends
        hivResultsAgeFuture[age, ] <-c(ageDiagnoses, trendDiags)
      } 
    } else if(projectOption == "reduce") {
      # Assume same reduction across all age groups
      hivResultsAgeFuture <- cbind(hivResultsAge,
        matrix(0, ncol = nprojYears, nrow = nages))
      colnames(hivResultsAgeFuture) <- paste0("y", 
        as.character(totalYears))
      for (age in 1:nages) {
        # Extract age group diagnoses
        ageDiagnoses <- hivResultsAge[age, ]
        
        # Reduce future diagnoses
        diagnosesFuture <- projectDecreaseAll * ProjVec(ageDiagnoses, 
          nprojYears)
        
        # Store final age trends
        hivResultsAgeFuture[age, ] <- diagnosesFuture
      }
    } else {
      # MANUALLY CHANGE HERE TO RUN ALTERNATE SCENARIOS
    }
    
    # Set aged diagnoses option
    diagnosesAge <- hivResultsAgeFuture
    
    # Deaths is a bit tricky because the final row is zero
    relAgeDeathFuture <- cbind(relAgeDeath[, 1:(ncol(relAgeDeath)-1)], 
      matrix(rep(relAgeDeath[, (ncol(relAgeDeath)-1)], nprojYears), 
        ncol = nprojYears), relAgeDeath[, ncol(relAgeDeath)])
    colnames(relAgeDeathFuture) <- paste0("y", as.character(totalYears))
    
    # Migration is straight forward
    relAgeMigrateFuture <- cbind(relAgeMigrate,
      matrix(rep(relAgeMigrate[,ncol(relAgeMigrate-1)], nprojYears), 
        ncol = nprojYears))
    colnames(relAgeMigrateFuture) <- paste0("y", as.character(totalYears))
    
    # Now run projections
    pldhivAgeFuture <- LivingDiagnosedAge(diagnosesAge,
      annUnique, 
      deathrate,
      osrateAge, 
      propStay, 
      agedeath = relAgeDeathFuture,
      agemigrate = relAgeMigrateFuture,
      normalize = pldhivAllFuture$pldhiv)
    
    # COnvert to along data frame
    hivDiagnosedFuture <- as.data.frame(pldhivAgeFuture) %>% 
      rownames_to_column(var = "agebin") %>%
      gather("year", "pldhiv", 2:ncol(.)) %>%
      select(year, everything()) %>%
      mutate(year = as.integer(str_sub(year, 2))) %>%
      as_tibble()
  }
  
  if (saveProjResults) {
    # Create output directory
    resultsPath <- file.path(outputFolder, projectOutput, cascadeName)
    dir.create(resultsPath, showWarnings = FALSE, recursive = TRUE)
    
    # Set up files
    if (doAge) {
      saveStringDetails <- file.path(resultsPath, 
        paste0("pldhiv-", toString(analysisYear), "-age-"))
    } else {
      saveStringDetails <- file.path(resultsPath, 
        paste0("pldhiv-", toString(analysisYear), "-"))
    }
    
    # Save main results
    saveStringPldhiv <- file.path(resultsPath, 
      paste0("HIVpldhivEstimates-", toString(analysisYear)))
    if (doAge) {
      saveStringPldhiv <- paste0(saveStringPldhiv, "-age")
    }
    
    # Save results
    if (doAge) {
      write_csv(rownames_to_column(as.data.frame(pldhivAgeFuture), 
        var = "agebin"), paste0(saveStringDetails, projectName,
          ".csv")) 
      write_csv(hivDiagnosedFuture, paste0(saveStringPldhiv, "-",
        projectName, ".csv"))
      write_csv(pldhivAllFuture, paste0(saveStringDetails, projectName,
        "_overall.csv"))
    } else {
      write_csv(pldhivAllFuture, paste0(saveStringDetails, projectName,
        ".csv"))
    }
  }
  
}
```
