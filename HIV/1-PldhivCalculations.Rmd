Calculation for number of people living with diagnosed HIV
==========================================================

Neil Bretana and Richard T. Gray

This script is used for calculating the number of people 
living with diagnosed HIV in Australia. This is one of the key steps for
producing the estimates of the Australian HIV diagnosis and care cascade. 

This script is part of a project containing version 3.0 of the HIV cascade
calculation scripts. 

```{r Initialization}
# Chunk to setup everything

# Open as a project (setting working directory to source and restarting R)

# Setup directories
basePath <- getwd()
Rcode <- file.path(dirname(basePath), "code") # All cascades code
HIVcode <- file.path(basePath, "code") 
dataFolder <- file.path(basePath, "data")
outputFolder <- file.path(basePath, "output")
figuresFolder <- file.path(basePath, "output", "figures")

# Notifications folder is a private secure folder 
notificationsFolder <- file.path("/", "SVR-NAS", "Public", "SERP", "Data", 
  "National HIV Registry", "2017", "National", "Hamish & Richard")
# tempImputeFolder <- file.path(dirname(dirname(basePath)), "data", "HIV", 
#     "cascadeImputedHIVnotifications-2017")

# Load standard libraries and options ------------------------------------
source(file.path(Rcode, "LoadLibrary.R"))
LoadLibrary(tidyverse)
```

The following chunck specifies all the parameters for producing the
estimates of PLHIV previously diagnosed. Result files are saved to the
specified project folder and have a cascade file handle. 

*Current projects*
- ASR_2016, ASR_2017, ASR_2018 (cascades for the Annual Surveillance 
Report(ASR))
- ASR_2018_Ageing (age estimates of PLDHIV for ASR)
- CALD_Cascades
- HIV_Cascade_Paper
- Ageing_Paper

```{r Cascade and script parameters}
# Chunk to enter all the script parameters we will use
analysisYear <- 2017
saveResults <- FALSE

# Set HIV cascade parameters----------------------------------

# Overarching project folder where all cascades will be stored
projectOutput <- "Test_Cascades" # "." for main output folder 
                                 # "HIV_Cascade_Paper" for paper

# Project CSV file for specifying cascade parameters - NULL = manual 
# otherwise cascade parameters are entred via a file in projectOutput 
# which need to exist
paramsFile <- "ProjectParameters.csv"
                            
# Cascade options----------------------------------------------------------
# The following variables specify the charactersitsics and hence the 
# notifications that will be included in the cascade. For some variables a 
# combination of categories can used by specifying a vector. Other 
# variables can only be specified as a single value.
# 
# When calculating multiple cascades these are entered as a list (of 
# vectors) for variables that can be combined or as vectors for single
# variables. All lists and vectors need to be the same length (equal to
# numCascades).
# 
# Note: These often have same value across all cascades in 
# a project so use rep() by default. These can then be manually changed as 
# required.

if (is.null(paramsFile)) {
  # Manually enter cascade specifications
  
  ##*********************************************************************##
  ## WARNING -- If multiple input categories
  ## are required you need to used the imputed notifications version.  
  ##*********************************************************************##  
  
  numCascades <- 1
  
  cascadeName <- "test-2017" # (single)
  targetGender <- rep("all", numCascades) # all, male, female (single)
  targetAge <- rep("all", numCascades) # all or split (single)
  # Note regarding ageing: The calculations don't specifically target 
  # specific ages.  Rather this simply chooses whether age is considered or 
  # not."all" means there is no division by age whereas "split" means teh 
  # calculations are doen for all agegroups specified as a0_4, a5_9, 
  # a10_14,...,a85+ (5 year age bins). To estimate for specific age run with
  # split and then filter out age estimates as required essentially turns on 
  # doAge below. 
  targetCob <- rep("all", numCascades) # all=including n/a, Thailand, etc.
  # (combination). "Australia", "non-australia", "non-aus-nz"
  targetExposure <- rep("all", numCascades) #msm, hetero, pwid, otherexp 
  # (combination)
  targetAtsi <- rep("all", numCascades) # all, indigenous or non_indigenous. 
  # Only used if country is Australia (single)
  
  targetState <- rep(c("all"), numCascades) # nsw, sa, nt, qld, vic, wa, act
  # tas (combination)
  targetLocalRegion <- rep("all", numCascades) #tbd (combination)
  
  targetGlobalRegion <- rep("all", numCascades) # South-East Asia, 
  # Sub-Saharan Africa, Oceania, South American, Other cob, etc 
  # (combination)
  
  # Imputation options-------------------------------------------------------
  # These variables specify if the imputed notifications sets should be used 
  # and how many sets to use.
  # 
  useImputed <- rep(TRUE, numCascades)
  nImputedSets <- rep(10, numCascades)  # Default is 10, the maximum
  
  # Script options--------------------------------------------------------
  # The following variables specify the various calculation options. 
  # When calculating multiple cascades these are entered as a vector. All
  # vectors need to be the same length (equal to numCascades).
  # 
  # Note: These are generally given the same value across all cascades in 
  # a project so use rep() by default. These can then be manually changed  
  # as required. 
  excludeAborig <- rep(FALSE, numCascades) # FALSE be default to include 
                                           # indigenous
  doRetained <- rep(TRUE, numCascades) # TRUE for appending retained in care
  
  # Settings for doing deduplication analysis
  doUnique <- rep(TRUE, numCascades)
  yearUnique <- rep(2017, numCascades) #Use NULL or year 2100 to turn off
  saveUnique <- rep(FALSE, numCascades)
  
  # Settings for generating ECDC model inputs
  ecdcData <- rep(TRUE, numCascades)
  ecdcVersion <- rep("1.3.0", numCascades) # Has to be the same
  excludeOS <- rep(FALSE, numCascades)
  
  # Leave projections chunk turned off so it is not called unless required. 
  # Simply run projections from within the chunk. 
  projectPldhiv <- rep(FALSE, numCascades) 
  
  # Manually set final year for projections and projection name
  projectYear <- rep(analysisYear + 10, numCascades)  
  projectName <- rep("future_sq", numCascades)
  
  # Specifiy projection option for future diagnoses - can project 
  # under the current "status-quo" level or follow trend over last 5 years
  # or project a relative reduction
  projectOption <- rep("status-quo", numCascades) #status-quo, linear, reduce 
  projectDecrease <- 0 # 0, 0.65 (35% reduction), 0.5 (50% 
                          # reduction), 0.35 (65% reduction) 
                          # relative reduction!
  
} else {
  # Read in a CSV file in 'projectOutput' (note project output folder has 
  # to already exist) with the 'paramsFile' name. 
  
  cascadeParameters <- read_csv(file.path(outputFolder, projectOutput,
    paramsFile))
  
  # Number of cascades
  numCascades <- nrow(cascadeParameters)
  
  # Pull out all the parameters separately. Default values are shown 
  # after each parameter (use in file and change as required)
  cascadeName <- cascadeParameters$cascadeName # Default: "All-analysisYear"
  targetGender <- cascadeParameters$targetGender # Default: "all"
  targetAge <- cascadeParameters$targetAge # Default: "all"
  targetCob <- cascadeParameters$targetCob # Default: "all"
  targetExposure <- cascadeParameters$targetExposure # Default: "all"
  targetAtsi <- cascadeParameters$targetAtsi # Default: "all"
  targetState <- cascadeParameters$targetState # Default: "all"
  targetLocalRegion <- cascadeParameters$targetLocalRegion # Default: "all"
  targetGlobalRegion <- cascadeParameters$targetGlobalRegion # Default: "all"
  
  # Imputation options
  useImputed <- cascadeParameters$useImputed # Default: TRUE
  nImputedSets <- cascadeParameters$nImputedSets # Default: 10
  
  # Script options
  excludeAborig <- cascadeParameters$excludeAborig # Default: FALSE
  doRetained <- cascadeParameters$doRetained # Default: TRUE
  
  # Deduplication analysis
  doUnique <- cascadeParameters$doUnique # Default: TRUE
  yearUnique <- cascadeParameters$yearUnique # Default: 2017
  saveUnique <- cascadeParameters$saveUnique # Default: FALSE
  
  # ECDC model
  ecdcData <- cascadeParameters$ecdcData # Default: TRUE
  ecdcVersion <- cascadeParameters$ecdcVersion # Default: "1.3.0"
  excludeOS <- cascadeParameters$excludeOS # Default: FALSE
  
  # Projections - defaults set to status quo for 10 years 
  projectPldhiv <- cascadeParameters$projectPldhiv # Default: FALSE
  projectYear <- cascadeParameters$projectYear # Default: 2017
  projectName <- cascadeParameters$projectName # Default: analysisYear + 10
  projectOption <- cascadeParameters$projectOption # Default: "future_sq"
  projectDecrease <- cascadeParameters$projectDecrease # Default: 0
    
} 

```

```{r Functions}
# Load functions used for analysis 

# Source functions for filling in missing data
source(file.path(Rcode, "FillMissing.R"))
source(file.path(Rcode, "FillDataFrame.R"))
source(file.path(Rcode, "FillMissingAge.R"))

# Load function to calculate number living with diagnosed HIV
source(file.path(HIVcode,"LivingDiagnosed.R"))
source(file.path(HIVcode,"LivingDiagnosedAge.R"))

# Function to easily extract sub-populations of interest 
source(file.path(HIVcode, "SubHivSet.R"))
source(file.path(HIVcode, "SubHivSetImpute.R"))

# Functions for removing duplicates annually
source(file.path(HIVcode, "DeduplicationFunctions.R"))

# Function to replace estimates
source(file.path(HIVcode, "ReplaceEstimates.R"))

# Function to tidy notifications
source(file.path(HIVcode, "TidyNotifications.R"))

# Functions to output ECDC model data
source(file.path(HIVcode, "EcdcCalculations.R"))
source(file.path(HIVcode, "EcdcFiles.R"))

# Functions for subsetting and annual notifications
source(file.path(HIVcode, "ProportionMale.R"))
source(file.path(HIVcode, "AnnualDiagnoses.R"))

# Functions for adjustments
source(file.path(HIVcode, "GetAdjustments.R"))
source(file.path(HIVcode, "GetMigrate.R"))
source(file.path(HIVcode, "GetInterRegion.R"))

# Perform and append retained in care calculations
if (doRetained) {
  source(file.path(HIVcode, "RetainedCare.R"))
}

# Simple but useful functions for looking at things
viewDiagnosed <- function() {
  print(pldhivAll %>% tail())
  print(pldhivAllMin %>% tail())
  print(pldhivAllMax %>% tail())
}


```

```{r Load notifications}
# This chunk loads the national notifications subset and imputed sets 
# based on the specified criteria in Script paramaters

# Load cascade notifications data from storage
hivData <- read_csv(file.path(notificationsFolder, 
  paste0("cascadeImputedHIVnotifications-", toString(analysisYear)),
  "cascadeHIVdata.csv"))

# Load imputed notifications sets if required
if (useImputed) {
  hivDataImputed <- read_csv(file.path(notificationsFolder, 
     paste0("cascadeImputedHIVnotifications-", toString(analysisYear)),
    "cascadeHIVimputed.csv"))
}

# Data checks-------------------------------------------------------------

# Quick check that we are not doing analysis outside of the data
if (max(hivData$yeardiagnosis) < analysisYear) {
  stop("No data specified for final year of analysis.")
}

# HIV data variables------------------------------------------------------

# Setup variables for overarching analysis                  
allYears <- min(hivData$yeardiagnosis):analysisYear # all years of data

```

```{r Load base and adjustment data}
# This loads the adjustment files for adjusting the death rates and
# migration rates  
hivBase <- read.csv(file.path(dataFolder, paste0("HIVbaseEstimates-",
  toString(analysisYear), ".csv")))
hivAdjustments <- read.csv(file.path(dataFolder,
  paste0("HIVadjustments-",
    toString(analysisYear), ".csv")))
# hivInterstate <- read.csv(file.path(dataFolder,
#   paste0("HIVinterstateEstimates-",
#     toString(analysisYear), ".csv")))

mainDataFolder <- file.path(dirname(getwd()), "data")
# absMigration <- read.csv(file.path(mainDataFolder,
#   paste0("ABS_migration_clean-", toString(analysisYear), ".csv")),
#   as.is = 1)

# Load cleaned NOM data variable (cleanNom)
load(file = file.path(mainDataFolder, "cleaned_ABS_nom_data.R"))
 
absInterstate <- read_csv(file.path(mainDataFolder, 
  paste0("ABS_interstate_age_sex_clean-", toString(analysisYear), ".csv")))

if (doAge) {
  # Specifications and deaths data by age
  
  # Set-up age matrix names
  ageList <- c("a0_4", "a5_9","a10_14", "a15_19", "a20_24", "a25_29", 
    "a30_34", "a35_39", "a40_44", "a45_49", "a50_54", "a55_59", 
    "a60_64", "a65_69", "a70_74", "a75_79", "a80_84", "a85+")
  
  yearList <- paste0("y", as.character(allYears))
  
  # Load age based relative deathrates 
  hivAgeDeath <- read.csv(file.path(dataFolder, paste0("HIVageEstimates-",
      toString(analysisYear), ".csv")))
}

```

```{r Loop through cascades}
# This chunk loops through the cascade parameters and produces the 
# PLDHIV cascade estimates by calling the main pldhiv calculation function.
# Everything is pretty much done in that function.
source(file.path(HIVcode, "CalculatePldhiv.R"))


for (ii in 1:numCascades) {
  pldhivCalculations <- CalculatePldhiv(analysisYear, saveResults, 
    projectOutput, cascadeName[ii], targetGender[ii], targetAge[ii], 
    targetCob[ii], targetExposure[ii], targetAtsi[ii], targetState[ii], 
    targetLocalRegion[ii], targetGlobalRegion[ii], excludeAborig[ii], 
    doRetained[ii], doUnique[ii], yearUnique[ii], ecdcData[ii], 
    ecdcVersion[ii], excludeOS[ii], projectPldhiv[ii], projectYear[ii], 
    projectName[ii], projectOption[ii], projectDecrease[ii])
}

```

```{r Error and option checking}
# Error checking and changes in options based on cascade parameters
# Check lengths of all cascade variables and options

if (sum(c(targetGender, targetAge, targetCob, targetExposure, targetAtsi, 
  targetState, targetLocalRegion, targetGlobalRegion) != "all") > 1 && 
    useImputed == FALSE) {
  warning("Multiple selections for subsetting non-imputed data set: 
    SubHivSet() will not work correctly. Changed to imputed data set")
  useImputed <- TRUE
  nImputedSets <- 10 # use default
}

# TODO: check lengths of all the variables and make sure they equal 
# numCascades

if ((length(targetGender) > 1) || (length(targetAtsi) > 1)) {
  stop("Error: targetGender or targetAtsi not a single value") 
}

if (targetAtsi != "all" && targetCob[1] != "Australia" &&
    length(targetCob) != 1) {
  stop("Error: indigenous status only valid for Australian born")   
}

# Change script options based on cascade parameters and other options------
interState <- ifelse(targetState[1] != "all", TRUE, FALSE)
doAge <- ifelse(targetAge == "split", TRUE, FALSE) # TRUE for ageing
doRetained <- ifelse(doAge, FALSE, doRetained) # Turn off for ageing
if (doRetained) {
  # Need to specify years for reatined in care calculations
  # This is simply a proportion based on James McMahon's paper
  # which suggested 92-98% of PLDHIV were retained in care. 
  retainedYears <- 2013:analysisYear
}

# Settings for doing deduplication analysis--------------------------------
doUnique <- ifelse(targetAtsi == "indigenous", FALSE, doUnique)
yearUnique <- ifelse(is.null(yearUnique), 2100, yearUnique) # Well past now
saveUnique <- ifelse(!saveResults, FALSE, saveUnique)
  
# Settings for generating ECDC model inputs--------------------------------
ecdcData <- ifelse(doAge, FALSE, ecdcData) # Turn off for ageing
# ecdcData <- ifelse(useImputed, FALSE, ecdcData) # Turn off for imputation at the moment
excludeOS <- ifelse(!ecdcData, FALSE, excludeOS) # Turn off
ecdcModel <- cascadeName # name
if (excludeOS) {
  # If excludeOS don't save the pldhiv estimates as we are only using this
  # for ECDC calculations
  saveResults <- FALSE
  doRetained <- FALSE
}

# Store paramaters for saving----------------------------------------------
hivParams <- data.frame(cascadeName, targetGender, targetAge, targetCob,
  targetExposure, targetAtsi, targetState, targetLocalRegion,
  targetGlobalRegion, excludeAborig, doRetained,
  doUnique, yearUnique, ecdcData, ecdcVersion, excludeOS, projectPldhiv,
  projectYear, projectName, projectOption, projectDecrease, analysisYear, 
  interState, doAge)

```

```{r Subset notifications}
# Create subsetted notifications dataframe. 

# Look at the overall notifications first
if (excludeOS) {
  hivData <- filter(hivData, is.na(previ_diag_overseas))
}

hivSetAll <- filter(hivData, yeardiagnosis <= analysisYear)
annDiagsOrig <- hivSetAll %>% 
  group_by(yeardiagnosis) %>%
  summarise(notifications = n()) %>%
  mutate(totalnotifications = cumsum(notifications)) %>%
  ungroup() 

if (excludeAborig) {
  # Set indigenous aside separately to add on later if required
  hivSetIndigenous <- filter(hivSetAll, aboriggroup == 'indigenous')
  hivSetAll <- filter(hivSetAll, aboriggroup == 'non_indigenous')
}

# Now select/calculate annual notifications for selected categories

if (useImputed) {
  # Use the imputed notifications sets - loop through each set of 
  # notifications subsetting the required ones and at the end calculate the
  # averages across the sets.
  
  uniqueNotificationsSets <- data_frame()
  uniqueNotificationsAllSets <- data_frame()
  
  hivResultsSets <- data_frame()
  hivResultsAgeSets <- data_frame()
  hivResultsAllSets <- data_frame()
  hivResultsAgeAllSets <- data_frame()
  
  if (targetGender == "all") {
    propDiagsMaleSets <- data_frame()
    propDiagsMaleAllSets <- data_frame()
    if (doAge) {
      propDiagsAgeMaleSets <- data_frame()
      propDiagsAgeMaleAllSets <- data_frame()
    }
  }
  
  if (ecdcData) {
    imputeHivSet <- data_frame()
  }
  
  for (ii in 1:nImputedSets) {
    
    tempHivSetAll <- hivDataImputed %>%
      filter(impute_set == ii) %>%
      select(-impute_set, -notification) 
    
    if (excludeAborig) {
      # Set indigenous aside separately to add on later if required
      tmepHivSetIndigenous <- filter(tempHivSetAll, aboriggroup == 'indigenous')
      tempHivSetAll <- filter(tempHivSetAll, aboriggroup == 'non_indigenous')
    }
    
    tempHivSetReturn <- SubHivSetImpute(tempHivSetAll, "all", targetGender,
      targetExposure, targetCob, targetAtsi, targetState, 
      targetGlobalRegion)
    
    tempHivSet <- tempHivSetReturn[[1]]
    tempHivSetExcluded <- tempHivSetReturn[[2]]
    tempHivSetUnknown <- data_frame() # Empty
    
    if (ecdcData) {
      # Need to save all notifications 
      imputeHivSet <- bind_rows(imputeHivSet, tempHivSet)
    }
    
    # HivSetUnknown outputs should be empty
    if (nrow(tempHivSetUnknown) != 0) {
      stop("Unknowns detected in imputed data set.")
    }
    
    if (interState || doAge) {
      tempHivSetReturnAll <- SubHivSetImpute(tempHivSetAll, "all", targetGender,
        targetExposure, targetCob, targetAtsi, "all", targetGlobalRegion)
      
      tempHivSetAll <- tempHivSetReturnAll[[1]]
      tempHivSetExcludedAll <- tempHivSetReturnAll[[2]]
      tempHivSetUnknownAll <- data_frame() # Empty
      
      # HivSetUnknown outputs should be empty
      if (nrow(tempHivSetUnknownAll) != 0) {
        stop("Unknowns detected in imputed data set.")
      }
    }
    
    # Calculate unique notifications and duplicates for the known set.
    if (doUnique) {
      tempHivSetUnique <- SubHivSetImpute(tempHivSetAll, "all", targetGender,
        targetExposure, "all", "all", targetState, "all")
      
      tempUniqueNotifications <- GetUnique(tempHivSetUnique[[1]], allYears, 
        yearUnique = yearUnique)
      
      # Collate
      uniqueNotificationsSets <- bind_rows(uniqueNotificationsSets, 
        tempUniqueNotifications)
      
      # For Interstate Calculations we need overall national estimates
      if (interState) {
        tempHivSetUniqueAll <- SubHivSetImpute(tempHivSetAll, "all", targetGender,
          targetExposure, "all", "all", "all", "all")
        
        tempUniqueNotificationsAll <- GetUnique(tempHivSetUniqueAll[[1]], 
          allYears, yearUnique = yearUnique) 
        
        # Collate
        uniqueNotificationsAllSets <- bind_rows(uniqueNotificationsAllSets, 
        tempUniqueNotificationsAll)
      }
    } 
    
    # Calculation cumulative proportion male. This is used for gender weighted
    # migration rates
    if (targetGender == "all") {
      tempPropDiagsMale <- ProportionMale(tempHivSet, analysisYear, FALSE,
        targetGender = targetGender)
      tempPropDiagsMaleAll <- ProportionMale(tempHivSetAll, analysisYear, 
        FALSE, targetGender = targetGender)
      
      tempPropDiagsMale <- as_tibble(tempPropDiagsMale) %>%
        add_column(year = allYears, .before = 1)
      tempPropDiagsMaleAll <- as_tibble(tempPropDiagsMaleAll) %>%
        add_column(year = allYears, .before = 1) 
      
      # Collate
      propDiagsMaleSets <- bind_rows(propDiagsMaleSets, tempPropDiagsMale)
      propDiagsMaleAllSets <- bind_rows(propDiagsMaleAllSets,
        tempPropDiagsMaleAll)
      
      if (doAge) {
        tempPropDiagsAgeMale <- ProportionMale(tempHivSet, analysisYear, 
          TRUE, targetGender = targetGender)
        tempPropDiagsAgeMaleAll <- ProportionMale(tempHivSetAll, 
          analysisYear, TRUE, targetGender = targetGender)
        
        # Collate
        propDiagsAgeMaleSets <- bind_rows(propDiagsAgeMaleSets, 
          as_tibble(tempPropDiagsAgeMale))
        propDiagsAgeMaleAllSets <- bind_rows(propDiagsAgeMaleAllSets, 
          as_tibble(tempPropDiagsAgeMaleAll))
      }
    }
    
    # Annual notifications
    tempAnnualDiags <- AnnualDiagnoses(tempHivSet, tempHivSetExcluded, 
      tempHivSetUnknown, allYears, doAge)
    
    tempHivResults <- tempAnnualDiags[[1]]
    tempHivResultsAge <- tempAnnualDiags[[2]] %>%
      as.data.frame() %>%
      rownames_to_column(var = "agegroup")
    
    # Collate
    hivResultsSets <- bind_rows(hivResultsSets, tempHivResults)
    hivResultsAgeSets <- bind_rows(hivResultsAgeSets, tempHivResultsAge)
    
    if (interState || doAge) {
      tempAnnualDiagsAll <- AnnualDiagnoses(tempHivSetAll, 
        tempHivSetExcludedAll, tempHivSetUnknownAll, allYears, doAge)
      
      tempHivResultsAll <- tempAnnualDiagsAll[[1]]
      tempHivResultsAgeAll <- tempAnnualDiagsAll[[2]] %>%
        as.data.frame() %>%
        rownames_to_column(var = "agegroup")
      
      # Collate
      hivResultsAllSets <- bind_rows(hivResultsAllSets, 
        tempHivResultsAll)
      hivResultsAgeAllSets <- bind_rows(hivResultsAgeAllSets,
        tempHivResultsAgeAll)
    }
  }
  
  # Outputs we need - take mean value across all imputed data sets---------
  if (doUnique) {
    uniqueNotifications <- uniqueNotificationsSets %>%
      group_by(year) %>%
      summarise_all(funs(mean)) %>%
      ungroup()
    if (interState) {
      uniqueNotificationsAll <- uniqueNotificationsAllSets %>%
        group_by(year) %>%
        summarise_all(funs(mean)) %>%
        ungroup()
    }
  }
  
  # For proportion male convert back to vector
  if (targetGender == "all") {
    propDiagsMale <- propDiagsMaleSets %>%
      group_by(year) %>%
      summarise_all(funs(mean)) %>%
      ungroup() %>%
      select(value) %>%
      as.matrix() %>%
      as.vector 
    propDiagsMaleAll <- propDiagsMaleAllSets %>%
      group_by(year) %>%
      summarise_all(funs(mean)) %>%
      ungroup() %>%
      select(value) %>%
      as.matrix() %>%
      as.vector
    
    if (doAge) {
      propDiagsAgeMale <- propDiagsAgeMaleSets %>%
        group_by(year) %>%
        summarise_all(funs(mean)) %>%
        ungroup() %>%
        as.matrix
      propDiagsAgeMaleAll <- propDiagsAgeMaleAllSets %>%
        group_by(year) %>%
        summarise_all(funs(mean)) %>%
        ungroup() %>%
        as.matrix
    }
  } else {
    propDiagsMale <- NULL
    propDiagsMaleAll <- NULL
    
    propDiagsAgeMale <- NULL
    propDiagsAgeMaleAll <- NULL
  }

  # Annual notifications
  hivResults <- hivResultsSets %>%
    group_by(year) %>%
    summarise_all(funs(mean)) %>%
    ungroup() 
  hivResultsAge <- hivResultsAgeSets %>%
    group_by(agegroup) %>%
    summarise_all(funs(mean)) %>%
    column_to_rownames(var = "agegroup") %>%
    ungroup() %>% 
    as.matrix()
  
  if (interState || doAge) {
  hivResultsAll <- hivResultsAllSets %>%
    group_by(year) %>%
    summarise_all(funs(mean)) %>%
    ungroup() 
  hivResultsAgeAll <- hivResultsAgeAllSets %>%
    group_by(agegroup) %>%
    summarise_all(funs(mean)) %>%
    column_to_rownames(var = "agegroup") %>%
    ungroup() %>% 
    as.matrix()
  }
  
} else {
  # Extract subset of notifications we want from data
  
  ##*********************************************************************##
  ## WARNING -- This following subsetting only works as required when 
  ## selecting a single input category for notififcations. If multiple 
  ## input categories are required you need to used the imputed 
  ## notifications version.  
  ##*********************************************************************## 
  
  if (excludeAborig) {
    # Set indigenous aside separately to add on later if required
    hivSetIndigenous <- filter(hivSetAll, aboriggroup == 'indigenous')
    hivSetAll <- filter(hivSetAll, aboriggroup == 'non_indigenous')
  }
  
  hivSetReturn <- SubHivSet(hivSetAll, "all", targetGender,
    targetExposure, targetCob, targetAtsi, 
    targetState, targetGlobalRegion)
  
  hivSet <- hivSetReturn[[1]]
  hivSetExcluded <- hivSetReturn[[2]]
  hivSetUnknown <- hivSetReturn[[3]]
  
  if (interState || doAge) {
    hivSetReturnAll <- SubHivSet(hivSetAll, "all", targetGender,
      targetExposure, targetCob, targetAtsi, "all", targetGlobalRegion)
    
    hivSetAll <- hivSetReturnAll[[1]]
    hivSetExcludedAll <- hivSetReturnAll[[2]]
    hivSetUnknownAll <- hivSetReturnAll[[3]]
  }
  
  # TEMPORARY HACK for state cascades to fix subsetting issues for 
  # multiple selections with country of birth
  # hivSetExcluded <- filter(hivSetExcluded, state == targetState)
  
  # Calculate unique notifications and duplicates for the known set.
  if (doUnique) {
    hivSetUnique <- SubHivSet(hivSet, "all", targetGender,
      targetExposure, "all", "all", targetState, "all")
    
    uniqueNotifications <- GetUnique(hivSetUnique[[1]], allYears, 
      yearUnique = yearUnique)
    
    # For Interstate Calculations we need overall national estimates
    if (interState) {
      hivSetUniqueAll <- SubHivSet(hivSetAll, "all", targetGender,
        targetExposure, "all", "all", "all", "all")
      
      uniqueNotificationsAll <- GetUnique(hivSetUniqueAll[[1]], 
        allYears, yearUnique = yearUnique)
    }
  } 
  
  # Calculation cumulative proportion male. This is used for gender weighted
  # migration rates
  if (targetGender == "all") {
    propDiagsMale <- ProportionMale(hivSet, analysisYear, FALSE)
    propDiagsMaleAll <- ProportionMale(hivSetAll, analysisYear, FALSE)
    
    if (doAge) {
      propDiagsAgeMale <- ProportionMale(hivSet, analysisYear, TRUE,
        targetGender = targetGender)
      propDiagsAgeMaleAll <- ProportionMale(hivSetAll, analysisYear, TRUE,
        targetGender = targetGender)
    }
  }
  
  # Annual notifications and proportions
  annualDiags <- AnnualDiagnoses(hivSet, hivSetExcluded, 
    hivSetUnknown, allYears, doAge)
  
  hivResults <- annualDiags[[1]]
  hivResultsAge <- annualDiags[[2]]
  
  if (interState || doAge) {
    annualDiagsAll <- AnnualDiagnoses(hivSetAll, 
      hivSetExcludedAll, hivSetUnknownAll, allYears, doAge)
    
    hivResultsAll <- annualDiagsAll[[1]]
    hivResultsAgeAll <- annualDiagsAll[[2]]
  }

}

```

```{r Generate base and adjustment estimates}
# Now get the death rates, base migration rates, and proportion stay rates
# Migration rates are now calculated using GetMigrate
subsetRates <- GetAdjustments(hivBase, hivAdjustments, 
  "all", targetGender, targetExposure, targetCob, targetAtsi, 
  targetLocalRegion, targetState, targetGlobalRegion) 

# Get the annual proportion unique
if (doUnique) {
  subsetRates$cumunique <- uniqueNotifications$cumunique 
  subsetRates$annunique <- uniqueNotifications$annunique
} 

# Get migration rate adjustments 
relMigration <- GetMigrate(analysisYear, cleanNom, "all",
  targetGender, targetExposure, targetCob, targetAtsi, targetLocalRegion,
  targetState, targetGlobalRegion, propMale = propDiagsMale)

# Adjust migration rate for Indigenous population if required
# Potentially move into GetMigrate
if (targetAtsi == "indigenous" && length(targetCob) == 1 &&
    targetCob[1] == "Australia") {
  relMigration <- 0
} else if ((targetAtsi == "non_indigenous" &&
    targetCob[1] == "Australia")|| targetGlobalRegion[1] != "all" ||
    (targetCob[1] != "all" && targetCob[1] != "Australia")) {
  relMigration <- relMigration *
    hivAdjustments$non_aborig_migration
}

# Final migration rates
subsetRates$mrate <- relMigration * hivBase$migrationrate
subsetRates$mrate_lower <- relMigration * hivBase$migrationrate_lower
subsetRates$mrate_upper <- relMigration * hivBase$migrationrate_upper

# Initialize interstate movement rates
subsetRates$inter_arriverate <- 0
subsetRates$inter_departrate <- 0

if (interState) {
  # For interstate calculations also need overall population estimates
  subsetRatesAll <- GetAdjustments(hivBase, hivAdjustments,
    "all", targetGender, targetExposure, targetCob, targetAtsi, 
    targetLocalRegion, "all", targetGlobalRegion)  
  
  if (doUnique) {
    print("HI")
    subsetRatesAll$cumunique <- uniqueNotificationsAll$cumunique 
    subsetRatesAll$annunique <- uniqueNotificationsAll$annunique
  }
  
  # Get migration rate adjustments 
  relMigrationAll <- GetMigrate(analysisYear, cleanNom, "all",
    targetGender, targetExposure, targetCob, targetAtsi,
    targetLocalRegion, "all", targetGlobalRegion, 
    propMale = propDiagsMale)
  
  # Adjust migration rate for Indigenous population if required
  # Potentially move into GetMigrate
  if (targetAtsi == "indigenous" && length(targetCob) == 1 &&
      targetCob[1] == "Australia") {
    relMigrationAll <- 0
  } else if ((targetAtsi == "non_indigenous" &&
      targetCob[1] == "Australia")|| targetGlobalRegion[1] != "all" ||
      (targetCob[1] != "all" && targetCob[1] != "Australia")) {
    relMigrationAll <- relMigrationAll *
      hivAdjustments$non_aborig_migration
  }
  
  # Final migration rates
  subsetRatesAll$mrate <- relMigrationAll * hivBase$migrationrate
  subsetRatesAll$mrate_lower <- relMigrationAll *
    hivBase$migrationrate_lower
  subsetRatesAll$mrate_upper <- relMigrationAll *
    hivBase$migrationrate_upper
  
  # Get interregion rates - only have date since 1982 assume zero rate for
  # 1980-81. 
  interRegionRates <- GetInterRegion(analysisYear, cleanNom, 
    absInterstate, NULL, "all", "all", targetState, targetLocalRegion,
    assumeAdult = TRUE)
  
  subsetRates$inter_arriverate <- interRegionRates$arriverate
  subsetRates$inter_departrate <- interRegionRates$departrate
}

if (doAge) {
  # No get relative migration and death rates by age. 
  # Death rates are assumed to be the same for overall and 
  # interstate/interegion
  
  # Relative death rates - based on overall data
  relAgeDeath <- hivAgeDeath %>%
    filter(population == targetGender, year <= analysisYear) %>%
    select(year, age, reldeathrate) %>%
    spread(year, reldeathrate) %>%
    select(-age)
  colnames(relAgeDeath) <- yearList
  rownames(relAgeDeath) <- ageList
  
  # Relative migration rates
  relAgeMigrate <- GetMigrateAge(analysisYear, cleanNom, targetGender, 
    targetExposure, targetCob, targetAtsi, targetLocalRegion, targetState, 
    targetGlobalRegion, propMale = propDiagsAgeMale)
  
  colnames(relAgeMigrate) <- yearList
  rownames(relAgeMigrate) <- ageList
  
  if (interState) {
    # Need overall relative migration rates as well
    relAgeMigrateAll <- GetMigrateAge(analysisYear, cleanNom, targetGender, 
    targetExposure, targetCob, targetAtsi, targetLocalRegion, "all", 
    targetGlobalRegion, propMale = propDiagsAgeMaleAll)
    
    # Get interregion rates by age
    interRegionAge <- GetInterRegionAge(analysisYear, cleanNom, 
      absInterstate, NULL, "all", targetState, targetLocalRegion)
    
    interDepartrateAge <- interRegionAge[[1]]
    interArriverateAge <- interRegionAge[[2]]
  }
}

```

```{r Calculate PLDHIV}
# This chunk fianlly calculates the number of people living with diagnosed
# HIV

if (interState) {
  # A bit more work to do if we do inter-regional migration
  if (doAge) {
    # Do age based interstate calculations
    # Calculate overall national PLDHIV estimates for interstate miogration
    pldhivOverallAll <- LivingDiagnosed(hivResultsAll$notifications,
      subsetRatesAll$annunique, 
      subsetRatesAll$deathrate,
      subsetRatesAll$mrate,
      subsetRatesAll$propstay) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallAllMin <- LivingDiagnosed(hivResultsAll$notifications,
      subsetRatesAll$annunique,  
      subsetRatesAll$deathrate_upper,
      subsetRatesAll$mrate_upper,
      subsetRatesAll$propstay_lower) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallAllMax <- LivingDiagnosed(hivResultsAll$notifications,
      subsetRatesAll$annunique,  
      subsetRatesAll$deathrate_lower,
      subsetRatesAll$mrate_lower,
      subsetRatesAll$propstay_upper) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    # Calculate National pldhiv by age
    pldhivAgeAll <- LivingDiagnosedAge(hivResultsAgeAll,
      subsetRatesAll$annunique, 
      subsetRatesAll$deathrate,
      hivBase$migrationrate, 
      subsetRatesAll$propstay,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrateAll,
      normalize = pldhivOverallAll$pldhiv)
    
     pldhivAgeAllMin <- LivingDiagnosedAge(hivResultsAgeAll,
      subsetRatesAll$annunique, 
      subsetRatesAll$deathrate_upper,
      hivBase$migrationrate_upper, 
      subsetRatesAll$propstay_lower,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      normalize = pldhivOverallAllMin$pldhiv)
    
    pldhivAgeAllMax <- LivingDiagnosedAge(hivResultsAgeAll,
      subsetRatesAll$annunique, 
      subsetRatesAll$deathrate_lower,
      hivBase$migrationrate_lower, 
      subsetRatesAll$propstay_upper,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      normalize = pldhivOverallAllMax$pldhiv)
    
    # Calculate overall (non-age) PLDHIV state stimates for normalization
    pldhivOverall <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique, 
      subsetRates$deathrate,
      subsetRates$mrate,
      subsetRates$propstay) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
   pldhivOverallMin <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique,  
      subsetRates$deathrate_upper,
      subsetRates$mrate_upper,
      subsetRates$propstay_lower) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallMax <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique,  
      subsetRates$deathrate_lower,
      subsetRates$mrate_lower,
      subsetRates$propstay_upper) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    # Calculate state estimaets by age
    # NOTE: use base migration rate as mrate is calculated assuming people
    # are aged > 15 years
    pldhivAll <- LivingDiagnosedAge(hivResultsAge,
      subsetRates$annunique, 
      subsetRates$deathrate,
      hivBase$migrationrate, 
      subsetRates$propstay,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      arrivals = interArriverateAge,
      departs = interDepartrateAge,
      pldhiv =  pldhivAgeAll, 
      normalize = pldhivOverall$pldhiv)
    
    pldhivAllMin <- LivingDiagnosedAge(hivResultsAge,
      subsetRates$annunique, 
      subsetRates$deathrate_upper,
      hivBase$migrationrate_upper, 
      subsetRates$propstay_lower,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      arrivals = interArriverateAge,
      departs = interDepartrateAge,
      pldhiv =  pldhivAgeAllMin,
      normalize = pldhivOverallMin$pldhiv)
    
    pldhivAllMax <- LivingDiagnosedAge(hivResultsAge,
      subsetRates$annunique, 
      subsetRates$deathrate_lower,
      hivBase$migrationrate_lower, 
      subsetRates$propstay_upper,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      arrivals = interArriverateAge,
      departs = interDepartrateAge,
      pldhiv =  pldhivAgeAllMax,
      normalize = pldhivOverallMax$pldhiv)
    
  } else {
    # Calculate overall first for inter-regional migration
    pldhivOverall <- LivingDiagnosed(hivResultsAll$notifications,
      subsetRatesAll$annunique, 
      subsetRatesAll$deathrate,
      subsetRatesAll$mrate,
      subsetRatesAll$propstay) %>%
      mutate(year = allYears) %>% 
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallMin <- LivingDiagnosed(hivResultsAll$notifications,
      subsetRatesAll$annunique,  
      subsetRatesAll$deathrate_upper,
      subsetRatesAll$mrate_upper,
      subsetRatesAll$propstay_lower) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallMax <- LivingDiagnosed(hivResultsAll$notifications,
      subsetRatesAll$annunique,  
      subsetRatesAll$deathrate_lower,
      subsetRatesAll$mrate_lower,
      subsetRatesAll$propstay_upper) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    # Now do regional migration
    pldhivAll <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique, 
      subsetRates$deathrate, 
      subsetRates$mrate,
      subsetRates$propstay,
      arrivals = subsetRates$inter_arriverate, 
      departs = subsetRates$inter_departrate, 
      pldhiv = pldhivOverall$pldhiv) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    # Use best estimate overall for min and max
    pldhivAllMin <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique,  
      subsetRates$deathrate_upper,
      subsetRates$mrate_upper,
      subsetRates$propstay_lower,
      arrivals = subsetRates$inter_arriverate,
      departs = subsetRates$inter_departrate,
      pldhiv = pldhivOverall$pldhiv) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivAllMax <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique,  
      subsetRates$deathrate_lower,
      subsetRates$mrate_lower,
      subsetRates$propstay_upper,
      arrivals = subsetRates$inter_arriverate,
      departs = subsetRates$inter_departrate,
      pldhiv = pldhivOverall$pldhiv) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
  } 
} else {
  
  # Do overall calculations only
  if (doAge) {
    # Do age based calculations - age group estimates should almost 
    # always be normalized to the overall estimates as differences in 
    # death rates and migration rates can produce inconsistenices across
    # the age groups. Normalization can be turned off for testing to make
    # sure the results are not too different (comapring 
    # pldhivOverall$pldhiv vs colSums(pldhivAll). 
    
    # Calculate overall (non-age) PLDHIV estimates for normalization
    pldhivOverall <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique, 
      subsetRates$deathrate,
      subsetRates$mrate,
      subsetRates$propstay) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallMin <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique,  
      subsetRates$deathrate_upper,
      subsetRates$mrate_upper,
      subsetRates$propstay_lower) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallMax <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique,  
      subsetRates$deathrate_lower,
      subsetRates$mrate_lower,
      subsetRates$propstay_upper) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    # Calculate age group estimates 
    # NOTE: use base migration rate as mrate is calculated assuming people
    # are aged > 15 years
    pldhivAll <- LivingDiagnosedAge(hivResultsAge,
      subsetRates$annunique, 
      subsetRates$deathrate,
      hivBase$migrationrate, 
      subsetRates$propstay,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      normalize = pldhivOverall$pldhiv) 
    
    pldhivAllMin <- LivingDiagnosedAge(hivResultsAge,
      subsetRates$annunique, 
      subsetRates$deathrate_upper,
      hivBase$migrationrate_upper, 
      subsetRates$propstay_lower,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      normalize = pldhivOverallMin$pldhiv)
    
    pldhivAllMax <- LivingDiagnosedAge(hivResultsAge,
      subsetRates$annunique, 
      subsetRates$deathrate_lower,
      hivBase$migrationrate_lower, 
      subsetRates$propstay_upper,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      normalize = pldhivOverallMax$pldhiv)
    
  } else {
    pldhivAll <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique, 
      subsetRates$deathrate,
      subsetRates$mrate,
      subsetRates$propstay) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivAllMin <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique,  
      subsetRates$deathrate_upper,
      subsetRates$mrate_upper,
      subsetRates$propstay_lower) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivAllMax <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique,  
      subsetRates$deathrate_lower,
      subsetRates$mrate_lower,
      subsetRates$propstay_upper) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
  }
}

# Store results
if (doAge) {
  # Store estimates by year and age
  pldhivDf <- as.data.frame(pldhivAll) %>% 
    rownames_to_column(var = "agebin") %>%
    gather("year", "pldhiv", 2:ncol(.)) %>%
    select(year, everything()) %>%
    mutate(year = as.integer(str_sub(year, 2))) %>%
    as_tibble()
  
  pldhivDfMin <- as.data.frame(pldhivAllMin) %>% 
    rownames_to_column(var = "agebin") %>%
    gather("year", "pldhiv", 2:ncol(.)) %>%
    select(year, everything()) %>%
    mutate(year = as.integer(str_sub(year, 2))) %>%
    as_tibble()
  
  pldhivDfMax <- as.data.frame(pldhivAllMax) %>% 
    rownames_to_column(var = "agebin") %>%
    gather("year", "pldhiv", 2:ncol(.)) %>%
    select(year, everything()) %>%
    mutate(year = as.integer(str_sub(year, 2))) %>%
    as_tibble()
  
  hivDiagnosed <- data.frame(stage = "pldhiv",
    year = pldhivDf$year,
    agebin = pldhivDf$agebin,
    value = pldhivDf$pldhiv,
    lower = pldhivDfMin$pldhiv,
    upper = pldhivDfMax$pldhiv) %>%
    as_tibble()
  
} else {
  # Don't need to store age
  hivDiagnosed <- data.frame(stage = "pldhiv",
    year = allYears,
    value = pldhivAll$pldhiv,
    lower = pldhivAllMin$pldhiv,
    upper = pldhivAllMax$pldhiv)
}

```

```{r ECDC Outputs}
# ECDC calculations-------------------------------------------------------
if (ecdcData) {
  
  if (useImputed) {
    normalizeFactor <- rep(1, length(allYears))
    ecdcImputeSets <- nImputedSets
  } else {
    normalizeFactor <-  annualDiags[[1]]$ecdc_normalization
    normalizeFactor[is.nan(normalizeFactor)] <- 1
    ecdcImputeSets <- 1
  }  
  
  # Folder for ECDC output
  ecdcFolder <- file.path(outputFolder, projectOutput)
  
  # ECDC data set
  if (useImputed) {
    hivSetEcdc <- imputeHivSet
  } else {
    hivSetEcdc <- hivSet %>%
      mutate(expgroup = ifelse(is.na(expgroup), "unknown", expgroup))
  }
  
  if (excludeOS) {
    # excluding OS diagnosis
    dataAll <- EcdcFolders(ecdcFolder, ecdcModel, 
      includeOS = FALSE)
    EcdcFiles(hivSetEcdc, dataAll, propUnique = subsetRates$cumunique,
      propKnown = normalizeFactor, nDataSets = ecdcImputeSets)
  } else {
    # including OS diagnosis
    dataAll <- EcdcFolders(ecdcFolder, ecdcModel)
    EcdcFiles(hivSetEcdc, dataAll, propUnique = subsetRates$cumunique,
      propKnown = normalizeFactor, nDataSets = ecdcImputeSets) 
  }
  
  # Create output directory
  resultsEcdcPath <- file.path(ecdcFolder, "ECDC_models", cascadeName)
  
  #save parameters 
  saveStringParams <- file.path(resultsEcdcPath, "Parameters")
  
  # Write to csv
  write_csv(hivParams, paste0(saveStringParams, ".csv"))
  
  # Save deaths and emigrants into ECDC
  
  # All deaths
  deaths <- pldhivAll %>%
    select(year, deaths) %>%
    rename(all = deaths)
  EcdcWrite(deaths, dataAll[[1]], "deaths")
  
  # All emigrants
  if (interState) {
    emigrants <- pldhivAll %>% 
      select(year, emigrants, diag_departs, inter_departs,
        inter_arrivals) %>%
      mutate(total = emigrants + diag_departs + inter_departs -
          inter_arrivals) %>%
      select(year, total) %>%
      rename(all = total)
  } else {
    emigrants <- pldhivAll %>% 
      select(year, emigrants, diag_departs) %>%
      mutate(total = emigrants + diag_departs) %>%
      select(year, total) %>%
      rename(all = total)
  }
  
  EcdcWrite(emigrants, dataAll[[1]], "emigrants")
  
  hivExpCum <- hivSetEcdc %>% 
    filter(is.na(previ_diag_overseas)) %>%
    group_by(expgroup, yeardiagnosis) %>% 
    summarise(notifications = n() / ecdcImputeSets) %>% 
    ungroup() %>% 
    group_by(expgroup) %>% 
    mutate(cumnotifications = cumsum(notifications)) %>%
    ungroup() %>% 
    select(-notifications) %>%
    spread(expgroup, cumnotifications) 
  
  if (!("hetero" %in% names(hivExpCum))) hivExpCum$hetero <- 0
  if (!("msm" %in% names(hivExpCum))) hivExpCum$msm <- 0
  if (!("otherexp" %in% names(hivExpCum))) hivExpCum$otherexp <- 0
  if (!("pwid" %in% names(hivExpCum))) hivExpCum$pwid <- 0
  if (!("unknown" %in% names(hivExpCum))) hivExpCum$unknown <- 0
  
  hivExpCum <- hivExpCum %>% 
    select(-unknown) %>%
    gather("expgroup", "cumnotifications", 2:5) %>%
    mutate(cumnotifications = ifelse(is.na(cumnotifications), 0, 
      cumnotifications)) %>%
    group_by(yeardiagnosis) %>% 
    mutate(propnotifications = cumnotifications /
        sum(cumnotifications)) %>%
    mutate(propnotifications = ifelse(is.na(propnotifications), 0, 
      propnotifications)) %>%
    select(-cumnotifications) %>%
    ungroup() %>% 
    spread(expgroup, propnotifications) %>%
    rename(year = yeardiagnosis) 
  hivExpCum$msm[2] <- 1.0
  
  expDeaths <- FillDataFrame(1980:analysisYear, hivExpCum, 
    cumulative = TRUE)
  expDeaths[, 2:5] <- expDeaths[, 2:5] * 
    matrix(rep(pldhivAll$deaths, 4), ncol = 4)
  
  EcdcWrite(expDeaths, dataAll[[2]], "deaths")
  
  expEmig <- FillDataFrame(1980:analysisYear, hivExpCum, 
    cumulative = TRUE)
  expEmig[, 2:5] <- expEmig[, 2:5] * 
    matrix(rep(emigrants$all, 4), ncol = 4)
  
  EcdcWrite(expEmig, dataAll[[2]], "emigrants")
  
}

```

```{r Append retained}
if (doRetained) {
  # Perform and append retained in care calculations
  source(file.path(HIVcode, "RetainedCare.R"))
  
  # Load retained in care data - Use McMahon et al data for 2013 onwards
  # Hardcoded: value, lower, upper.  Lower and upper ranges correspond 
  # to the range for the percentage retained after follow-up in McMahon 
  # et al., Clinic Network Collaboration and Patient Tracing to Maximize 
  # Retention in HIV Care, PLOS One, May 26, 2015.
  hivParameters <- read.csv(file.path(dataFolder, 
    "individualHIVparameters.csv"), as.is = 1)
  hivParameters <- select(hivParameters, parameter, value)
  
  for (ii in 1:nrow(hivParameters)) {
    assign(hivParameters$parameter[ii], hivParameters$value[ii])
  }
  
  retained <- vicClinicRetained
  retainedLower <- vicClinicRetainedLower
  retainedUpper <- vicClinicRetainedUpper
  
  hivRetained <- RetainedCare(hivDiagnosed, retained, retainedLower,
    retainedUpper, retainedYears)
  
  # Merge with hivDiagnosed
  hivDiagnosed <- bind_rows(hivDiagnosed, hivRetained)
  
}
```

```{r Save cascade results}
if (saveResults) {
  # Create output directory
  resultsPath <- file.path(outputFolder, projectOutput, cascadeName)
  dir.create(resultsPath, showWarnings = FALSE, recursive = TRUE)
  
  # Save all estimates
  if (doAge) {
    saveStringDetails <- file.path(resultsPath, 
      paste0("pldhiv-", toString(analysisYear), "-age-"))
    write_csv(rownames_to_column(as.data.frame(pldhivAll), var = "agebin"),
      paste0(saveStringDetails, "all.csv"))
    write_csv(rownames_to_column(as.data.frame(pldhivAllMin), 
      var = "agebin"), paste0(saveStringDetails, "min.csv"))
    write_csv(rownames_to_column(as.data.frame(pldhivAllMax), 
      var = "agebin"), paste0(saveStringDetails, "max.csv"))
  } else {
    saveStringDetails <- file.path(resultsPath, 
      paste0("pldhiv-", toString(analysisYear), "-"))
    write_csv(pldhivAll, paste0(saveStringDetails, "all.csv"))
    write_csv(pldhivAllMin, paste0(saveStringDetails, "min.csv"))
    write_csv(pldhivAllMax, paste0(saveStringDetails, "max.csv"))
  }
  
  # Save main results
  saveStringPldhiv <- file.path(resultsPath, 
    paste0("HIVpldhivEstimates-", toString(analysisYear)))
  if (doAge) {
    saveStringPldhiv <- paste0(saveStringPldhiv, "-age")
  }
  write_csv(hivDiagnosed, paste0(saveStringPldhiv, ".csv"))
  
  #save parameters 
  saveStringParams <- file.path(resultsPath, "PldhivParameters")
  
  # Write to csv
  write_csv(hivParams, paste0(saveStringParams, ".csv"))
  
  # Write uniqueNotifications to file
  if (doUnique) {
    saveStringUnique <- file.path(resultsPath, "UniqueNotifications")
    write_csv(uniqueNotifications, paste0(saveStringUnique, ".csv"))
  }
}

```

```{r Projections}
# This chunk is used for generating projections of the number of people 
# living with diagnosed HIV. To do the projections we simply make
# assumptions about the future changes to annual diagnoses, deathrates, 
# migration rates into a specified future period.  
# 
# Any change in inputs to LivingDiagnosed function can be manually 
# specified the default is to keep everything the same as the analysis 
# year.
# 
# Any counterfactual or future projection scenario can be manually 
# specified.

if (projectPldhiv) { 
  
  # Manually set final year for projections and projection name
  projectYear <- analysisYear + 10  
  projectName <- "future_sq"
  
  # Specifiy projection option for future diagnoses
  projectOption <- "status-quo" #status-quo, linear, reduce 
  projectDecrease <- 0 # 0, 0.65 (35% reduction), 0.5 (50% 
                          # reduction), 0.35 (65% reduction) 
                          # relative reduction!
  
  saveProjResults <- saveResults 
  
  # Functions for setting up vectors
  End <- function(vector) return(tail(vector, 1))
  ProjVec <- function(vector, nyears) return(c(vector, 
    rep(End(vector), nyears)))
  
  # Setup projection years
  projectYears <- (analysisYear + 1):projectYear
  nprojYears <- length(projectYears)
  totalYears <- c(allYears, projectYears)
  
  # Setup Projection relative decrease (linear over projectYears)
  projectDecreaseFuture <- seq(1, projectDecrease, length = (nprojYears+1))
  projectDecreaseAll <- c(rep(1, nyears), 
    tail(projectDecreaseFuture, nprojYears))
  
  # Default vectors for projections assume everything stays the same.
  # Keeping the number of diagnoses and annUnique the same as the 
  # analysis year value means the same number of unique diagnoses will
  # occur each year. SELECT STANDARD OPTION OR MANUALLY CHANGE TO RUN
  #  ALTERNATE SCENARIOS.
  
  # Diagnoses options
  if (projectOption == "status-quo") {
    diagnosesFuture <- ProjVec(hivResults$notifications, nprojYears)
  } else if (projectOption == "linear") {
    # Trend diagnoses (using trend over last 5 years)
    trendlm <- lm(diagnoses ~ year, 
      data.frame(year = (analysisYear - 4):analysisYear, 
        diagnoses = tail(hivResults$notifications, 5)))
    trendDiags <- predict(trendlm, data.frame(year = projectYears))
    diagnosesFuture <- c(hivResults$notifications, trendDiags)
  } else if(projectOption == "reduce") {
    diagnosesFuture <- projectDecreaseAll * 
      ProjVec(hivResults$notifications, nprojYears)
  } else {
    # MANUALLY CHANGE HERE TO RUN ALTERNATE SCENARIOS
  }
  
  # Use trend diagnoses as default - not need different emigration 
  # rates for overall and age calculations because the overall rate assumes
  # all PLDHIV are adults and to align with estimates above up to 
  # analysis year.
  diagnoses <- diagnosesFuture
  annUnique <- ProjVec(subsetRates$annunique, nprojYears)
  deathrate <- ProjVec(subsetRates$deathrate, nprojYears)
  osrateOverall <- ProjVec(subsetRates$mrate, nprojYears)
  osrateAge <- ProjVec(hivBase$migrationrate, nprojYears)
  propStay <- ProjVec(subsetRates$propstay, nprojYears)   
  
  # CHANGE DEFAULTS HERE
  # 
  # Example showing counterfactual to calculate number living 
  # diagnosed before 1996 etc
  # diagnoses[totalYears > 1996] <- 0 
  # projectName <- "pre1996"
  # Example looking at future impact of PrEP after 2016 assuming 
  # 50% reduction in diagnoses
  # diagnoses[totalYears > 2016] <- 0.5 * diagnoses[totalYears > 2016]
  
  # Do future projections
  pldhivAllFuture <- LivingDiagnosed(diagnoses,
    annUnique, 
    deathrate,
    osrateOverall,
    propStay) %>%
    mutate(year = totalYears) %>%
    select(year, everything())
  
  # Do a similar process for each age group if doing age and run in 
  # Living DiagnosedAge(). To do past 5 years age trends we need to loop
  # cross age groups to generate estimates.
  if (doAge) {
    
    # Setup hivResultsAge for future. Most are the same as for the non-age
    # calculations except diagnoses, relAgeDeath, and relAgeMigrate need to
    # be extended into the future
    
    
    # Status quo diagnoses and relative reductions can be applied across
    # the age groups
    
    if (projectOption == "status-quo") {
      hivResultsAgeFuture <- cbind(hivResultsAge,
        matrix(rep(hivResultsAge[,ncol(hivResultsAge-1)], nprojYears), 
          ncol = nprojYears))
      colnames(hivResultsAgeFuture) <- paste0("y", 
        as.character(totalYears))
    } else if (projectOption == "linear") {
      # Project each age group independently
      hivResultsAgeFuture <- cbind(hivResultsAge,
        matrix(0, ncol = nprojYears, nrow = nages))
      colnames(hivResultsAgeFuture) <- paste0("y", 
        as.character(totalYears))
      for (age in 1:nages) {
        # Extract age group diagnoses
        ageDiagnoses <- hivResultsAge[age, ]
        
        # Estimate trends
        trendlm <- lm(diagnoses ~ year, 
          data.frame(year = (analysisYear - 4):analysisYear, 
            diagnoses = tail(ageDiagnoses, 5)))
        trendDiags <- predict(trendlm, data.frame(year = projectYears))
        
        # Make sure diagnoses are at least zero (okay as normalization 
        # should fix this.
        trendDiags[trendDiags < 0] <- 0
        
        # Store final age trends
        hivResultsAgeFuture[age, ] <- c(ageDiagnoses, trendDiags)
      } 
    } else if(projectOption == "reduce") {
      # Assume same reduction across all age groups
      hivResultsAgeFuture <- cbind(hivResultsAge,
        matrix(0, ncol = nprojYears, nrow = nages))
      colnames(hivResultsAgeFuture) <- paste0("y", 
        as.character(totalYears))
      for (age in 1:nages) {
        # Extract age group diagnoses
        ageDiagnoses <- hivResultsAge[age, ]
        
        # Reduce future diagnoses
        diagnosesFuture <- projectDecreaseAll * ProjVec(ageDiagnoses, 
          nprojYears)
        
        # Store final age trends
        hivResultsAgeFuture[age, ] <- diagnosesFuture
      }
    } else {
      # MANUALLY CHANGE HERE TO RUN ALTERNATE SCENARIOS
    }
    
    # Set aged diagnoses option
    diagnosesAge <- hivResultsAgeFuture
    
    # Deaths is a bit tricky because the final row is zero
    relAgeDeathFuture <- cbind(relAgeDeath[, 1:(ncol(relAgeDeath)-1)], 
      matrix(rep(relAgeDeath[, (ncol(relAgeDeath)-1)], nprojYears), 
        ncol = nprojYears), relAgeDeath[, ncol(relAgeDeath)])
    colnames(relAgeDeathFuture) <- paste0("y", as.character(totalYears))
    
    # Migration is straight forward
    relAgeMigrateFuture <- cbind(relAgeMigrate,
      matrix(rep(relAgeMigrate[,ncol(relAgeMigrate-1)], nprojYears), 
        ncol = nprojYears))
    colnames(relAgeMigrateFuture) <- paste0("y", as.character(totalYears))
    
    # Now run projections
    pldhivAgeFuture <- LivingDiagnosedAge(diagnosesAge,
      annUnique, 
      deathrate,
      osrateAge, 
      propStay, 
      agedeath = relAgeDeathFuture,
      agemigrate = relAgeMigrateFuture,
      normalize = pldhivAllFuture$pldhiv)
    
    # COnvert to along data frame
    hivDiagnosedFuture <- as.data.frame(pldhivAgeFuture) %>% 
      rownames_to_column(var = "agebin") %>%
      gather("year", "pldhiv", 2:ncol(.)) %>%
      select(year, everything()) %>%
      mutate(year = as.integer(str_sub(year, 2))) %>%
      as_tibble()
  }
  
  # Save results ----------------------------------------------------------
  if (saveResults) {
    # Create output directory
    resultsPath <- file.path(outputFolder, projectOutput, cascadeName)
    dir.create(resultsPath, showWarnings = FALSE, recursive = TRUE)
    
    # Set up files
    if (doAge) {
      saveStringDetails <- file.path(resultsPath, 
        paste0("pldhiv-", toString(analysisYear), "-age-"))
    } else {
      saveStringDetails <- file.path(resultsPath, 
        paste0("pldhiv-", toString(analysisYear), "-"))
    }
    
    # Save main results
    saveStringPldhiv <- file.path(resultsPath, 
      paste0("HIVpldhivEstimates-", toString(analysisYear)))
    if (doAge) {
      saveStringPldhiv <- paste0(saveStringPldhiv, "-age")
    }
    
    # Save results
    if (doAge) {
      write_csv(rownames_to_column(as.data.frame(pldhivAgeFuture), 
        var = "agebin"), paste0(saveStringDetails, projectName,
          ".csv")) 
      write_csv(hivDiagnosedFuture, paste0(saveStringPldhiv, "-",
        projectName, ".csv"))
      write_csv(pldhivAllFuture, paste0(saveStringDetails, projectName,
        "_overall.csv"))
    } else {
      write_csv(pldhivAllFuture, paste0(saveStringDetails, projectName,
        ".csv"))
    }
  }
  
}
```
