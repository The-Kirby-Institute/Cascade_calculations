Calculation for number of people living with diagnosed HIV
==========================================================

Neil Bretana and Richard T. Gray

This script is used for calculating the number of people 
living with diagnosed HIV in Australia. This is one of the key steps for
producing the estimates of the Australian HIV diagnosis and care cascade. 

This script is part of a project containing version 3.0 of the HIV cascade
calculation scripts. 

```{r Initialization}
# Chunk to setup everything

# Open as a project (setting working directory to source and restarting R)

# Setup directories
basePath <- getwd()
Rcode <- file.path(dirname(basePath), "code") # All cascades code
HIVcode <- file.path(basePath, "code") 
dataFolder <- file.path(basePath, "data")
outputFolder <- file.path(basePath, "output")
figuresFolder <- file.path(basePath, "output", "figures")

# Notifications folder is a private secure folder 
notificationsFolder <- file.path("/", "SVR-NAS", "Public", "SERP", "Data", 
  "National HIV Registry", "2017", "National", "Hamish & Richard")

# Load standard libraries and options ------------------------------------
source(file.path(Rcode, "LoadLibrary.R"))
LoadLibrary(tidyverse)
```

The following chunck specifies all the parameters for producing the
estimates of PLHIV previously diagnosed. Result files are saved to the
specified project folder and have a cascade file handle. 

*Current projects*
- ASR_2016, ASR_2017, ASR_2018 (cascades for the Annual Surveillance 
Report(ASR))
- ASR_2018_Ageing (age estimates of PLDHIV for ASR)
- CALD_Cascades
- HIV_Cascade_Paper
- Ageing_Paper

```{r Script parameters}
# Chunk to enter all the script parameters we will use
analysisYear <- 2017
saveResults <- FALSE

# Set HIV cascade parameters----------------------------------
# Overarching project where all cascades will be stored
projectOutput <- "Test_Cascades" # "." for main output folder 
                            # "HIV_Cascade_Paper" for paper
numCascades <- 1
                            
# Cascade options----------------------------------------------------------
# The following variables specify the charactersitsics and hence the 
# notifications that will be included in the cascade. For some variables a # combination of categories can used by specifying a vector. Other 
# variables can only be specified as a single value.
# 
# When calculating multiple cascades these are entered as a list (of 
# vectors) for variables that can be combined or as vectors for single
# variables. All lists and vectors need to be the same length (equal to
# numCascades).
# 
# # Note: These often have same value across all cascades in 
# a project so use rep() by default. These can then be manually changed as 
# required. 
# 
##***********************************************************************##
## WARNING -- Selecting multile selections for subsetting notififcations 
## needs care when categories with lots of missing data are included. 
## To subset notifications with these categories will likely need 
## imputation which has yet to be implemented. In the mean time care
## is required to ensure the number of notfications included in the 
## calculations is accurate. 
##***********************************************************************##

cascadeName <- "NSW-2017-Age" # (single)
targetGender <- rep("all", numCascades) # all, male, female (single)
targetAge <- rep("split", numCascades) # all or split (single)
# Note regarding ageing: The calculations don't specifically target 
# specific ages.  Rather this simply chooses whether age is considered or 
# not."all" means there is no division by age whereas "split" means teh 
# calculations are doen for all agegroups specified as a0_4, a5_9, 
# a10_14,...,a85+ (5 year age bins). To estimate for specific age run with
# split and then filter out age estimates as required essentially turns on 
# doAge below. 
targetCob <- rep("all", numCascades) # all=including n/a, Thailand, etc.
  # (combination)
targetExposure <- rep("all", numCascades) #msm, hetero, pwid, otherexp 
  # (combination)
targetAtsi <- rep("all", numCascades) # all, indigenous or non_indigenous. 
  # Only used if country is Australia (single)

# TODO: Merge these variables into one. 
targetState <- rep("nsw", numCascades) # nsw, sa, nt, qld, vic, wa, act
  # tas (combination)
targetLocalRegion <- rep("all", numCascades) #tbd (combination)

targetGlobalRegion <- rep("all", numCascades) # South-East Asia, 
  # Sub-Saharan Africa, Oceania, South American, Other cob, etc 
  # (combination)

# Script options-----------------------------------------------------------
# The following variables specify the various calculation options. 
# When calculating multiple cascades these are entered as a vector. All
# vectors need to be the same length (equal to numCascades).
# 
# Note: These are generally given the same value across all cascades in 
# a project so use rep() by default. These can then be manually changed as 
# required. 
excludeAborig <- rep(FALSE, numCascades)
doRetained <- rep(TRUE, numCascades) # TRUE for appending retained in care

# Settings for doing deduplication analysis
doUnique <- rep(TRUE, numCascades)
yearUnique <- rep(2017, numCascades) #Use NULL or year 2100 to turn off
saveUnique <- rep(FALSE, numCascades)

# Settings for generating ECDC model inputs
ecdcData <- rep(TRUE, numCascades)
ecdcVersion <- rep("1.3.0", numCascades) # Has to be the same
excludeOS <- rep(FALSE, numCascades)

# Leave projections chunk turned off so it is not called unless required. 
# Simply run projections from within the chunk. 
projectPldhiv <- rep(FALSE, numCascades) 

```



```{r Error and option checking}
# Error checking and changes in options based on cascade parameters
# Check lengths of all cascade variables and options
if (sum(c(targetGender, targetAge, targetCob, targetExposure, targetAtsi, 
  targetState, targetLocalRegion, targetGlobalRegion) != "all") > 1) {
  warning("Multiple selections for subsetting: SubHivSet() and reallocation
    may not work correctly if selections with lots of missing data are 
    included")
}

# Some error checking 

# TODO: check lengths of all the variables and make sure they equal 
# numCascades

if ((length(targetGender) > 1) || (length(targetAtsi) > 1)) {
  stop("Error: targetGender or targetAtsi not a single value") 
}

if (targetAtsi != "all" && targetCob[1] != "Australia" &&
    length(targetCob) != 1) {
  stop("Error: indigenous status only valid for Australian born")   
}

# Change script options based on cascade parameters and other options------
interState <- ifelse(targetState[1] != "all", TRUE, FALSE)
doAge <- ifelse(targetAge == "split", TRUE, FALSE) # TRUE for ageing
doRetained <- ifelse(doAge, FALSE, doRetained) # Turn off for ageing
if (doRetained) {
  # Need to specify years for reatined in care calculations
  # This is simply a proportion based on James McMahon's paper
  # which suggested 92-98% of PLDHIV were retained in care. 
  retainedYears <- 2013:analysisYear
}

# Settings for doing deduplication analysis--------------------------------
doUnique <- ifelse(targetAtsi == "indigenous", FALSE, doUnique)
yearUnique <- ifelse(is.null(yearUnique), 2100, yearUnique) # Well past now
saveUnique <- ifelse(!saveResults, FALSE, saveUnique)
  
# Settings for generating ECDC model inputs--------------------------------
ecdcData <- ifelse(doAge, FALSE, ecdcData) # Turn off for ageing
excludeOS <- ifelse(!ecdcData, FALSE, excludeOS) # Turn off
ecdcModel <- cascadeName # name
if (excludeOS) {
  # If excludeOS don't save the pldhiv estimates as we are only using this
  # for ECDC calculations
  saveResults <- FALSE
  doRetained <- FALSE
}

# Store paramaters for saving----------------------------------------------
hivParams <- data.frame(cascadeName, targetGender, targetAge, targetCob,
  targetExposure, targetAtsi, targetState, targetLocalRegion,
  targetGlobalRegion, interState, doAge, excludeAborig, doRetained,
  doUnique, yearUnique, ecdcData, ecdcVersion, excludeOS, projectPldhiv)

```

```{r Functions}
# Load functions used for analysis 

# Source functions for filling in missing data
source(file.path(Rcode, "FillMissing.R"))
source(file.path(Rcode, "FillDataFrame.R"))

# Load function to calculate number living with diagnosed HIV
source(file.path(HIVcode,"LivingDiagnosed.R"))
source(file.path(HIVcode,"LivingDiagnosedAge.R"))

# Function to easily extract sub-populations of interest 
source(file.path(HIVcode, "SubHivSet.R"))

# Functions for removing duplicates annually
source(file.path(HIVcode, "DeduplicationFunctions.R"))

# Function to replace estimates
source(file.path(HIVcode, "ReplaceEstimates.R"))

# Function to tidy notifications
source(file.path(HIVcode, "TidyNotifications.R"))

# Functions to output ECDC model data
source(file.path(HIVcode, "EcdcCalculations.R"))
source(file.path(HIVcode, "EcdcFiles.R"))

# Functions for subsetting and annual notifications
source(file.path(HIVcode, "ProportionMale.R"))
source(file.path(HIVcode, "AnnualDiagnoses.R"))

# Functions for adjustments
source(file.path(HIVcode, "GetAdjustments.R"))
source(file.path(HIVcode, "GetMigrate.R"))
source(file.path(HIVcode, "GetInterRegion.R"))

```

```{r Clean notifications}
# This chunk loads the national notifications and subsets based on the
# specified criteria in Script paramaters

# Load cleaned notifications data from storage
origHivData <- read.csv(file.path(notificationsFolder, 
  paste0("cascadeHIVnotifications-clean-", toString(analysisYear), 
    ".csv"))) 

# Read in country code data
countryCodes <- read.csv(file.path(dataFolder, "countryRegionCodes.csv"))

# Tidy up notifications for calculations
hivData <- TidyNotifications(origHivData, analysisYear, countryCodes)

# Data checks-------------------------------------------------------------

# Quick check that we are not doing analysis outside of the data
if (max(hivData$yeardiagnosis) < analysisYear) {
  stop("No data specified for final year of analysis.")
}

# HIV data variables------------------------------------------------------

# Setup variables for overarching analysis                  
allYears <- min(hivData$yeardiagnosis):analysisYear # all years of data

```

```{r Load base and adjustment data}
# This loads the adjustment files for adjusting the death rates and
# migration rates  
hivBase <- read.csv(file.path(dataFolder, paste0("HIVbaseEstimates-",
  toString(analysisYear), ".csv")))
hivAdjustments <- read.csv(file.path(dataFolder,
  paste0("HIVadjustments-",
    toString(analysisYear), ".csv")))
# hivInterstate <- read.csv(file.path(dataFolder,
#   paste0("HIVinterstateEstimates-",
#     toString(analysisYear), ".csv")))

mainDataFolder <- file.path(dirname(getwd()), "data")
# absMigration <- read.csv(file.path(mainDataFolder,
#   paste0("ABS_migration_clean-", toString(analysisYear), ".csv")),
#   as.is = 1)

# Load cleaned NOM data variable (cleanNom)
load(file = file.path(mainDataFolder, "cleaned_ABS_nom_data.R"))
 
absInterstate <- read_csv(file.path(mainDataFolder, 
  paste0("ABS_interstate_age_sex_clean-", toString(analysisYear), ".csv")))

if (doAge) {
  # Specifications and deaths data by age
  
  # Set-up age matrix names
  ageList <- c("a0_4", "a5_9","a10_14", "a15_19", "a20_24", "a25_29", 
    "a30_34", "a35_39", "a40_44", "a45_49", "a50_54", "a55_59", 
    "a60_64", "a65_69", "a70_74", "a75_79", "a80_84", "a85+")
  
  yearList <- paste0("y", as.character(allYears))
  
  # Load age based relative deathrates 
  hivAgeDeath <- read.csv(file.path(dataFolder, paste0("HIVageEstimates-",
      toString(analysisYear), ".csv")))
}

```

```{r Subset notifications}
# Create subsetted notifications dataframe. May have to do this multiple
# times to get the extact number of specific category and those excluded
# for inter-regional movement. E.g. MSM only in NSW as excluded will have
# non-MSM and non-NSW

if (excludeOS) {
  hivData <- filter(hivData, is.na(previ_diag_overseas))
}

hivSetAll <- filter(hivData, yeardiagnosis <= analysisYear)
annDiagsOrig <- hivSetAll %>% 
  group_by(yeardiagnosis) %>%
  summarise(notifications = n()) %>%
  mutate(totalnotifications = cumsum(notifications)) %>%
  ungroup() 

# May not need to do this anymore.
if (excludeAborig) {
  # Set indigenous aside separately to add on later if required
  hivSetIndigenous <- filter(hivSetAll, aboriggroup == 'indigenous')
  hivSetAll <- filter(hivSetAll, aboriggroup == 'non_indigenous')
}

# Extract subset of notifications we want

##*********************************************************************##
## WARNING -- The following function can produce incorrect estimates for the 
## number unknown and the num ber excluded when it uses a combination of 
## selections that includes selection with lots of missing data.  
## To subset notifications with these categories will likely need 
## imputation which has yet to be implemented. In the mean time care
## is required and temporary hardcoded hacks might be required to ensure 
## the number of notfications included in the calculations is accurate.
##*********************************************************************## 

hivSetReturn <- SubHivSet(hivSetAll, "all", targetGender,
  targetExposure, targetCob, targetAtsi,
  targetState, targetGlobalRegion)

hivSet <- hivSetReturn[[1]]
hivSetExcluded <- hivSetReturn[[2]]
hivSetUnknown <- hivSetReturn[[3]]

if (interState && doAge) {
  hivSetReturnAll <- SubHivSet(hivSetAll, "all", targetGender,
  targetExposure, targetCob, targetAtsi,
  "all", targetGlobalRegion)

  hivSetAll <- hivSetReturnAll[[1]]
  hivSetExcludedAll <- hivSetReturnAll[[2]]
  hivSetUnknownAll <- hivSetReturnAll[[3]]
}

# TEMPORARY HACK for state cascades to fix subsetting issues for 
# multiple selections with country of birth
# hivSetExcluded <- filter(hivSetExcluded, state == targetState)

# Calculate unique notifications and duplicates for the known set.
if (doUnique) {
  hivSetUnique <- SubHivSet(hivSet, "all", targetGender,
    targetExposure, "all", "all",
    targetState, "all")
  
  uniqueNotifications <- GetUnique(hivSetUnique[[1]], allYears, 
    yearUnique = yearUnique)
  
  # For Interstate Calculations we need overall national estimates
  if (interState) {
    hivSetUniqueAll <- SubHivSet(hivSet, "all", targetGender,
      targetExposure, "all", "all",
      "all", "all")
    
    uniqueNotificationsAll <- GetUnique(hivSetUniqueAll[[1]], 
      allYears, yearUnique = yearUnique)
  }
} 

# Calculation cumulative proportion male. This is used for gender weighted
# migration rates
propDiagsMale <- ProportionMale(hivSet, analysisYear, FALSE)
propDiagsMaleAll <- ProportionMale(hivSetAll, analysisYear, FALSE)

if (doAge) {
  propDiagsAgeMale <- ProportionMale(hivSet, analysisYear, TRUE)
  propDiagsAgeMaleAll <- ProportionMale(hivSetAll, analysisYear, TRUE)
}

```

```{r Annual notifications and proportions}

annualDiags <- AnnualDiagnoses(hivSet, hivSetExcluded, 
  hivSetUnknown, allYears, doAge)

hivResults <- annualDiags[[1]]
hivResultsAge <- annualDiags[[2]]

if (interState && doAge) {
  annualDiagsAll <- AnnualDiagnoses(hivSetAll, 
    hivSetExcludedAll, hivSetUnknownAll, allYears, doAge)
  
  hivResultsAll <- annualDiagsAll[[1]]
  hivResultsAgeAll <- annualDiagsAll[[2]]
}

```

```{r Generate base and adjustment estimates}
# Now get the death rates, base migration rates, and proportion stay rates
# Migration rates are now calculated using GetMigrate
subsetRates <- GetAdjustments(hivBase, hivAdjustments, 
  "all", targetGender, targetExposure, targetCob, targetAtsi, 
  targetLocalRegion, targetState, targetGlobalRegion) 

# Get the annual proportion unique
if (doUnique) {
  subsetRates$cumunique <- uniqueNotifications$cumunique 
  subsetRates$ annunique <- uniqueNotifications$annunique
  
  if (interState) {
     subsetRatesAll$cumunique <- uniqueNotificationsAll$cumunique 
     subsetRatesAll$ annunique <- uniqueNotificationsAll$annunique
  }
} 

# Get migration rate adjustments 
relMigration <- GetMigrate(analysisYear, cleanNom, "all",
  targetGender, targetExposure, targetCob, targetAtsi, targetLocalRegion,
  targetState, targetGlobalRegion, propMale = propDiagsMale)

# Adjust migration rate for Indigenous population if required
# Potentially move into GetMigrate
if (targetAtsi == "indigenous" && length(targetCob) == 1 &&
    targetCob[1] == "Australia") {
  relMigration <- 0
} else if ((targetAtsi == "non_indigenous" &&
    targetCob[1] == "Australia")|| targetGlobalRegion[1] != "all" ||
    (targetCob[1] != "all" && targetCob[1] != "Australia")) {
  relMigration <- relMigration *
    hivAdjustments$non_aborig_migration
}

# Final migration rates
subsetRates$mrate <- relMigration * hivBase$migrationrate
subsetRates$mrate_lower <- relMigration * hivBase$migrationrate_lower
subsetRates$mrate_upper <- relMigration * hivBase$migrationrate_upper

# Initialize interstate movement rates
subsetRates$inter_arriverate <- 0
subsetRates$inter_departrate <- 0

if (interState) {
  # For interstate calculations also need overall population estimates
  subsetRatesAll <- GetAdjustments(hivBase, hivAdjustments,
    "all", targetGender, targetExposure, targetCob, targetAtsi, 
    targetLocalRegion, "all", targetGlobalRegion)  
  
  if (doUnique) {
      subsetRatesAll$cumunique <- uniqueNotificationsAll$cumunique 
      subsetRatesAll$ annunique <- uniqueNotificationsAll$annunique
    }
  
  # Get migration rate adjustments 
  relMigrationAll <- GetMigrate(analysisYear, cleanNom, "all",
    targetGender, targetExposure, targetCob, targetAtsi,
    targetLocalRegion, "all", targetGlobalRegion, 
    propMale = propDiagsMale)
  
  # Adjust migration rate for Indigenous population if required
  # Potentially move into GetMigrate
  if (targetAtsi == "indigenous" && length(targetCob) == 1 &&
      targetCob[1] == "Australia") {
    relMigrationAll <- 0
  } else if ((targetAtsi == "non_indigenous" &&
      targetCob[1] == "Australia")|| targetGlobalRegion[1] != "all" ||
      (targetCob[1] != "all" && targetCob[1] != "Australia")) {
    relMigrationAll <- relMigrationAll *
      hivAdjustments$non_aborig_migration
  }
  
  # Final migration rates
  subsetRatesAll$mrate <- relMigrationAll * hivBase$migrationrate
  subsetRatesAll$mrate_lower <- relMigrationAll *
    hivBase$migrationrate_lower
  subsetRatesAll$mrate_upper <- relMigrationAll *
    hivBase$migrationrate_upper
  
  # Get interregion rates - only have date since 1982 assume zero rate for
  # 1980-81. 
  interRegionRates <- GetInterRegion(analysisYear, cleanNom, 
    absInterstate, NULL, "all", "all", targetState, targetLocalRegion,
    assumeAdult = TRUE)
  
  subsetRates$inter_arriverate <- interRegionRates$arriverate
  subsetRates$inter_departrate <- interRegionRates$departrate
}

if (doAge) {
  # No get relative migration and death rates by age. 
  # Death rates are assumed to be the same for overall and 
  # interstate/interegion
  
  # Relative death rates - based on overall data
  relAgeDeath <- hivAgeDeath %>%
    filter(population == targetGender, year <= analysisYear) %>%
    select(year, age, reldeathrate) %>%
    spread(year, reldeathrate) %>%
    select(-age)
  colnames(relAgeDeath) <- yearList
  rownames(relAgeDeath) <- ageList
  
  # Relative migration rates
  relAgeMigrate <- GetMigrateAge(analysisYear, cleanNom, targetGender, 
    targetExposure, targetCob, targetAtsi, targetLocalRegion, targetState, 
    targetGlobalRegion, propMale = propDiagsAgeMale)
  
  colnames(relAgeMigrate) <- yearList
  rownames(relAgeMigrate) <- ageList
  
  if (interState) {
    # Need overall relative migration rates as well
    relAgeMigrateAll <- GetMigrateAge(analysisYear, cleanNom, targetGender, 
    targetExposure, targetCob, targetAtsi, targetLocalRegion, "all", 
    targetGlobalRegion, propMale = propDiagsAgeMaleAll)
    
    # Get interregion rates by age
    interRegionAge <- GetInterRegionAge(analysisYear, cleanNom, 
      absInterstate, NULL, "all", targetState, targetLocalRegion)
    
    interDepartrateAge <- interRegionAge[[1]]
    interArriverateAge <- interRegionAge[[2]]
  }
}

```

```{r Calculate PLDHIV}
# This chunk fianlly calculates the number of people living with diagnosed
# HIV

if (interState) {
  # A bit more work to do if we do inter-regional migration
  if (doAge) {
    # Do age based interstate calculations
    # Calculate overall national PLDHIV estimates for interstate miogration
    pldhivOverallAll <- LivingDiagnosed(hivResultsAll$notifications,
      subsetRatesAll$annunique, 
      subsetRatesAll$deathrate,
      subsetRatesAll$mrate,
      subsetRatesAll$propstay) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallAllMin <- LivingDiagnosed(hivResultsAll$notifications,
      subsetRatesAll$annunique,  
      subsetRatesAll$deathrate_upper,
      subsetRatesAll$mrate_upper,
      subsetRatesAll$propstay_lower) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallAllMax <- LivingDiagnosed(hivResultsAll$notifications,
      subsetRatesAll$annunique,  
      subsetRatesAll$deathrate_lower,
      subsetRatesAll$mrate_lower,
      subsetRatesAll$propstay_upper) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    # Calculate National pldhiv by age
    pldhivAgeAll <- LivingDiagnosedAge(hivResultsAgeAll,
      subsetRatesAll$annunique, 
      subsetRatesAll$deathrate,
      hivBase$migrationrate, 
      subsetRatesAll$propstay,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrateAll,
      normalize = pldhivOverallAll$pldhiv)
    
     pldhivAgeAllMin <- LivingDiagnosedAge(hivResultsAgeAll,
      subsetRatesAll$annunique, 
      subsetRatesAll$deathrate_upper,
      hivBase$migrationrate_upper, 
      subsetRatesAll$propstay_lower,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      normalize = pldhivOverallAllMin$pldhiv)
    
    pldhivAgeAllMax <- LivingDiagnosedAge(hivResultsAgeAll,
      subsetRatesAll$annunique, 
      subsetRatesAll$deathrate_lower,
      hivBase$migrationrate_lower, 
      subsetRatesAll$propstay_upper,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      normalize = pldhivOverallAllMax$pldhiv)
    
    # Calculate overall (non-age) PLDHIV state stimates for normalization
    pldhivOverall <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique, 
      subsetRates$deathrate,
      subsetRates$mrate,
      subsetRates$propstay) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
   pldhivOverallMin <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique,  
      subsetRates$deathrate_upper,
      subsetRates$mrate_upper,
      subsetRates$propstay_lower) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallMax <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique,  
      subsetRates$deathrate_lower,
      subsetRates$mrate_lower,
      subsetRates$propstay_upper) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    # Calculate state estimaets by age
    # NOTE: use base migration rate as mrate is calculated assuming people
    # are aged > 15 years
    pldhivAll <- LivingDiagnosedAge(hivResultsAge,
      subsetRates$annunique, 
      subsetRates$deathrate,
      hivBase$migrationrate, 
      subsetRates$propstay,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      arrivals = interArriverateAge,
      departs = interDepartrateAge,
      pldhiv =  pldhivAgeAll, 
      normalize = pldhivOverall$pldhiv)
    
    pldhivAllMin <- LivingDiagnosedAge(hivResultsAge,
      subsetRates$annunique, 
      subsetRates$deathrate_upper,
      hivBase$migrationrate_upper, 
      subsetRates$propstay_lower,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      arrivals = interArriverateAge,
      departs = interDepartrateAge,
      pldhiv =  pldhivAgeAllMin,
      normalize = pldhivOverallMin$pldhiv)
    
    pldhivAllMax <- LivingDiagnosedAge(hivResultsAge,
      subsetRates$annunique, 
      subsetRates$deathrate_lower,
      hivBase$migrationrate_lower, 
      subsetRates$propstay_upper,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      arrivals = interArriverateAge,
      departs = interDepartrateAge,
      pldhiv =  pldhivAgeAllMax,
      normalize = pldhivOverallMax$pldhiv)
    
  } else {
    # Calculate overall first for inter-regional migration
    pldhivOverall <- LivingDiagnosed(hivResults$all_notifications,
      subsetRatesAll$annunique, 
      subsetRatesAll$deathrate,
      subsetRatesAll$mrate,
      subsetRatesAll$propstay) %>%
      mutate(year = allYears) %>% 
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallMin <- LivingDiagnosed(hivResults$all_notifications,
      subsetRatesAll$annunique,  
      subsetRatesAll$deathrate_upper,
      subsetRatesAll$mrate_upper,
      subsetRatesAll$propstay_lower) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallMax <- LivingDiagnosed(hivResults$all_notifications,
      subsetRatesAll$annunique,  
      subsetRatesAll$deathrate_lower,
      subsetRatesAll$mrate_lower,
      subsetRatesAll$propstay_upper) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    # Now do regional migration
    pldhivAll <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique, 
      subsetRates$deathrate, 
      subsetRates$mrate,
      subsetRates$propstay,
      arrivals = subsetRates$inter_arriverate, 
      departs = subsetRates$inter_departrate, 
      pldhiv = pldhivOverall$pldhiv) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    # Use best estimate overall for min and max
    pldhivAllMin <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique,  
      subsetRates$deathrate_upper,
      subsetRates$mrate_upper,
      subsetRates$propstay_lower,
      arrivals = subsetRates$inter_arriverate,
      departs = subsetRates$inter_departrate,
      pldhiv = pldhivOverall$pldhiv) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivAllMax <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique,  
      subsetRates$deathrate_lower,
      subsetRates$mrate_lower,
      subsetRates$propstay_upper,
      arrivals = subsetRates$inter_arriverate,
      departs = subsetRates$inter_departrate,
      pldhiv = pldhivOverall$pldhiv) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
  } 
} else {
  
  # Do overall calculations only
  if (doAge) {
    # Do age based calculations - age group estimates should almost 
    # always be normalized to the overall estimates as differences in 
    # death rates and migration rates can produce inconsistenices across
    # the age groups. Normalization can be turned off for testing to make
    # sure the results are not too different (comapring 
    # pldhivOverall$pldhiv vs colSums(pldhivAll). 
    
    # Calculate overall (non-age) PLDHIV estimates for normalization
    pldhivOverall <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique, 
      subsetRates$deathrate,
      subsetRates$mrate,
      subsetRates$propstay) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallMin <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique,  
      subsetRates$deathrate_upper,
      subsetRates$mrate_upper,
      subsetRates$propstay_lower) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivOverallMax <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique,  
      subsetRates$deathrate_lower,
      subsetRates$mrate_lower,
      subsetRates$propstay_upper) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    # Calculate age group estimates 
    # NOTE: use base migration rate as mrate is calculated assuming people
    # are aged > 15 years
    pldhivAll <- LivingDiagnosedAge(hivResultsAge,
      subsetRates$annunique, 
      subsetRates$deathrate,
      hivBase$migrationrate, 
      subsetRates$propstay,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      normalize = pldhivOverall$pldhiv) 
    
    pldhivAllMin <- LivingDiagnosedAge(hivResultsAge,
      subsetRates$annunique, 
      subsetRates$deathrate_upper,
      hivBase$migrationrate_upper, 
      subsetRates$propstay_lower,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      normalize = pldhivOverallMin$pldhiv)
    
    pldhivAllMax <- LivingDiagnosedAge(hivResultsAge,
      subsetRates$annunique, 
      subsetRates$deathrate_lower,
      hivBase$migrationrate_lower, 
      subsetRates$propstay_upper,
      agedeath = relAgeDeath,
      agemigrate = relAgeMigrate,
      normalize = pldhivOverallMax$pldhiv)
    
  } else {
    pldhivAll <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique, 
      subsetRates$deathrate,
      subsetRates$mrate,
      subsetRates$propstay) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivAllMin <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique,  
      subsetRates$deathrate_upper,
      subsetRates$mrate_upper,
      subsetRates$propstay_lower) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
    
    pldhivAllMax <- LivingDiagnosed(hivResults$notifications,
      subsetRates$annunique,  
      subsetRates$deathrate_lower,
      subsetRates$mrate_lower,
      subsetRates$propstay_upper) %>%
      mutate(year = allYears) %>%
      select(year, everything()) %>%
      as_tibble()
  }
}

# Store results
if (doAge) {
  # Store estimates by year and age
  pldhivDf <- as.data.frame(pldhivAll) %>% 
    rownames_to_column(var = "agebin") %>%
    gather("year", "pldhiv", 2:ncol(.)) %>%
    select(year, everything()) %>%
    mutate(year = as.integer(str_sub(year, 2))) %>%
    as_tibble()
  
  pldhivDfMin <- as.data.frame(pldhivAllMin) %>% 
    rownames_to_column(var = "agebin") %>%
    gather("year", "pldhiv", 2:ncol(.)) %>%
    select(year, everything()) %>%
    mutate(year = as.integer(str_sub(year, 2))) %>%
    as_tibble()
  
  pldhivDfMax <- as.data.frame(pldhivAllMax) %>% 
    rownames_to_column(var = "agebin") %>%
    gather("year", "pldhiv", 2:ncol(.)) %>%
    select(year, everything()) %>%
    mutate(year = as.integer(str_sub(year, 2))) %>%
    as_tibble()
  
  hivDiagnosed <- data.frame(stage = "pldhiv",
    year = pldhivDf$year,
    agebin = pldhivDf$agebin,
    value = pldhivDf$pldhiv,
    lower = pldhivDfMin$pldhiv,
    upper = pldhivDfMax$pldhiv) %>%
    as_tibble()
  
} else {
  # Don't need to store age
  hivDiagnosed <- data.frame(stage = "pldhiv",
    year = allYears,
    value = pldhivAll$pldhiv,
    lower = pldhivAllMin$pldhiv,
    upper = pldhivAllMax$pldhiv)
}

```

```{r ECDC Outputs}
# ECDC calculations-------------------------------------------------------
if (ecdcData) {
  normalizeFactor <- adjustDiags$included / 
    adjustDiags$adjusted_included
  normalizeFactor[is.nan(normalizeFactor)] <- 1
  
  # Folder for ECDC output
  ecdcFolder <- file.path(outputFolder, projectOutput)
  
  if (excludeOS) {
    # excluding OS diagnosis
    dataAll <- EcdcFolders(ecdcFolder, ecdcModel, 
      includeOS = FALSE)
    EcdcFiles(hivSet, dataAll, propUnique = subsetRates$cumunique,
      propKnown = normalizeFactor)
  } else {
    # including OS diagnosis
    dataAll <- EcdcFolders(ecdcFolder, ecdcModel)
    EcdcFiles(hivSet, dataAll, propUnique = subsetRates$cumunique,
      propKnown = normalizeFactor) 
  }
  
  # Create output directory
  resultsEcdcPath <- file.path(ecdcFolder, "ECDC_models", cascadeName)
  
  #save parameters 
  saveStringParams <- file.path(resultsEcdcPath, "Parameters")
  
  # Write to csv
  write_csv(hivParams, paste0(saveStringParams, ".csv"))
  
  # Save deaths and emigrants into ECDC
  
  # All deaths
  deaths <- pldhivAll %>%
    select(year, deaths) %>%
    rename(all = deaths)
  EcdcWrite(deaths, dataAll[[1]], "deaths")
  
  # All emigrants
  if (interState) {
    emigrants <- pldhivAll %>% 
      select(year, emigrants, diag_departs, inter_departs,
        inter_arrivals) %>%
      mutate(total = emigrants + diag_departs + inter_departs -
          inter_arrivals) %>%
      select(year, total) %>%
      rename(all = total)
  } else {
    emigrants <- pldhivAll %>% 
      select(year, emigrants, diag_departs) %>%
      mutate(total = emigrants + diag_departs) %>%
      select(year, total) %>%
      rename(all = total)
  }
  
  EcdcWrite(emigrants, dataAll[[1]], "emigrants")
  
  hivExpCum <- hivSet %>% 
    filter(is.na(previ_diag_overseas)) %>%
    group_by(expgroup, yeardiagnosis) %>% 
    summarise(notifications = n()) %>% 
    ungroup() %>% 
    group_by(expgroup) %>% 
    mutate(cumnotifications = cumsum(notifications)) %>%
    ungroup() %>% 
    select(-notifications) %>%
    spread(expgroup, cumnotifications) 
  
  if (!("hetero" %in% names(hivExpCum))) hivExpCum$hetero <- 0
  if (!("msm" %in% names(hivExpCum))) hivExpCum$msm <- 0
  if (!("otherexp" %in% names(hivExpCum))) hivExpCum$otherexp <- 0
  if (!("pwid" %in% names(hivExpCum))) hivExpCum$pwid <- 0
  if (!("unknown" %in% names(hivExpCum))) hivExpCum$unknown <- 0
  
  hivExpCum <- hivExpCum %>% select(-unknown) %>%
    gather("expgroup", "cumnotifications", 2:5) %>%
    mutate(cumnotifications = ifelse(is.na(cumnotifications), 0, 
      cumnotifications)) %>%
    group_by(yeardiagnosis) %>% 
    mutate(propnotifications = cumnotifications /
        sum(cumnotifications)) %>%
    mutate(propnotifications = ifelse(is.na(propnotifications), 0, 
      propnotifications)) %>%
    select(-cumnotifications) %>%
    ungroup() %>% 
    spread(expgroup, propnotifications) %>%
    rename(year = yeardiagnosis) 
  hivExpCum$msm[2] <- 1.0
  
  expDeaths <- FillDataFrame(1980:analysisYear, hivExpCum, 
    cumulative = TRUE)
  expDeaths[, 2:5] <- expDeaths[, 2:5] * 
    matrix(rep(pldhivAll$deaths, 4), ncol = 4)
  
  EcdcWrite(expDeaths, dataAll[[2]], "deaths")
  
  expEmig <- FillDataFrame(1980:analysisYear, hivExpCum, 
    cumulative = TRUE)
  expEmig[, 2:5] <- expEmig[, 2:5] * 
    matrix(rep(emigrants$all, 4), ncol = 4)
  
  EcdcWrite(expEmig, dataAll[[2]], "emigrants")
  
}

```

```{r Append retained}
if (doRetained) {
  # Perform and append retained in care calculations
  source(file.path(HIVcode, "RetainedCare.R"))
  
  # Load retained in care data - Use McMahon et al data for 2013 onwards
  # Hardcoded: value, lower, upper.  Lower and upper ranges correspond 
  # to the range for the percentage retained after follow-up in McMahon 
  # et al., Clinic Network Collaboration and Patient Tracing to Maximize 
  # Retention in HIV Care, PLOS One, May 26, 2015.
  hivParameters <- read.csv(file.path(dataFolder, 
    "individualHIVparameters.csv"), as.is = 1)
  hivParameters <- select(hivParameters, parameter, value)
  
  for (ii in 1:nrow(hivParameters)) {
    assign(hivParameters$parameter[ii], hivParameters$value[ii])
  }
  
  retained <- vicClinicRetained
  retainedLower <- vicClinicRetainedLower
  retainedUpper <- vicClinicRetainedUpper
  
  hivRetained <- RetainedCare(hivDiagnosed, retained, retainedLower,
    retainedUpper, retainedYears)
  
  # Merge with hivDiagnosed
  hivDiagnosed <- bind_rows(hivDiagnosed, hivRetained)
  
}
```

```{r Save results}
if (saveResults) {
  # Create output directory
  resultsPath <- file.path(outputFolder, projectOutput, cascadeName)
  dir.create(resultsPath, showWarnings = FALSE, recursive = TRUE)
  
  # Save all estimates
  if (doAge) {
    saveStringDetails <- file.path(resultsPath, 
      paste0("pldhiv-", toString(analysisYear), "-age-"))
    write_csv(rownames_to_column(as.data.frame(pldhivAll), var = "agebin"),
      paste0(saveStringDetails, "all.csv"))
    write_csv(rownames_to_column(as.data.frame(pldhivAllMin), 
      var = "agebin"), paste0(saveStringDetails, "min.csv"))
    write_csv(rownames_to_column(as.data.frame(pldhivAllMax), 
      var = "agebin"), paste0(saveStringDetails, "max.csv"))
  } else {
    saveStringDetails <- file.path(resultsPath, 
      paste0("pldhiv-", toString(analysisYear), "-"))
    write_csv(pldhivAll, paste0(saveStringDetails, "all.csv"))
    write_csv(pldhivAllMin, paste0(saveStringDetails, "min.csv"))
    write_csv(pldhivAllMax, paste0(saveStringDetails, "max.csv"))
  }
  
  # Save main results
  saveStringPldhiv <- file.path(resultsPath, 
    paste0("HIVpldhivEstimates-", toString(analysisYear)))
  if (doAge) {
    saveStringPldhiv <- paste0(saveStringPldhiv, "-age")
  }
  write_csv(hivDiagnosed, paste0(saveStringPldhiv, ".csv"))
  
  #save parameters 
  saveStringParams <- file.path(resultsPath, "PldhivParameters")
  
  # Write to csv
  write_csv(hivParams, paste0(saveStringParams, ".csv"))
  
  # Write uniqueNotifications to file
  if (doUnique) {
    saveStringUnique <- file.path(resultsPath, "UniqueNotifications")
    write_csv(uniqueNotifications, paste0(saveStringUnique, ".csv"))
  }
  
}

```

```{r Projections}
# This chunk is used for generating projections of the number of people 
# living with diagnosed HIV. To do the projections we simply make
# assumptions about the future changes to annual diagnoses, deathrates, 
# migration rates into a specified future period.  
# 
# Any change in inputs to LivingDiagnosed function can be manually 
# specified the default is to keep everything the same as the analysis 
# year.
# 
# Any counterfactual or future projection scenario can be manually 
# specified.
# 
# Maybe move this into a separate function or script but fits nicely here.
# projectPldhiv <- TRUE
if (projectPldhiv) { 
  
  # Manually set final year for projections and projection name
  projectYear <- analysisYear + 10  
  projectName <- "future_sq"
  
  # Specifiy projection option for future diagnoses
  projectOption <- "status-quo" #status-quo, linear, reduce 
  projectDecrease <- 0 # 0, 0.65 (35% reduction), 0.5 (50% 
                          # reduction), 0.35 (65% reduction) 
                          # relative reduction!
  
  saveProjResults <- TRUE 
  
  
  # Reset if saving things overall
  saveProjResults <- ifelse(saveResults, TRUE, saveProjResults) 
  
  # Functions for setting up vectors
  End <- function(vector) return(tail(vector, 1))
  ProjVec <- function(vector, nyears) return(c(vector, 
    rep(End(vector), nyears)))
  
  # Setup projection years
  projectYears <- (analysisYear + 1):projectYear
  nprojYears <- length(projectYears)
  totalYears <- c(allYears, projectYears)
  
  # Setup Projection relative decrease (linear over projectYears)
  projectDecreaseFuture <- seq(1, projectDecrease, length = (nprojYears+1))
  projectDecreaseAll <- c(rep(1, nyears), 
    tail(projectDecreaseFuture, nprojYears))
  
  # Default vectors for projections assume everything stays the same.
  # Keeping the number of diagnoses and annUnique the same as the 
  # analysis year value means the same number of unique diagnoses will
  # occur each year. SELECT STANDARD OPTION OR MANUALLY CHANGE TO RUN
  #  ALTERNATE SCENARIOS.
  
  # Diagnoses options
  if (projectOption == "status-quo") {
    diagnosesFuture <- ProjVec(adjustDiags$adjusted_included, nprojYears)
  } else if (projectOption == "linear") {
    # Trend diagnoses (using trend over last 5 years)
    trendlm <- lm(diagnoses ~ year, 
      data.frame(year = (analysisYear - 4):analysisYear, 
        diagnoses = tail(adjustDiags$adjusted_included, 5)))
    trendDiags <- predict(trendlm, data.frame(year = projectYears))
    diagnosesFuture <- c(adjustDiags$adjusted_included, trendDiags)
  } else if(projectOption == "reduce") {
    diagnosesFuture <- projectDecreaseAll * 
      ProjVec(adjustDiags$adjusted_included, nprojYears)
  } else {
    # MANUALLY CHANGE HERE TO RUN ALTERNATE SCENARIOS
  }
  
  # Use trend diagnoses as default - not need different emigration 
  # rates for overall and age calculations because the overall rate assumes
  # all PLDHIV are adults and to align with estimates above up to 
  # analysis year.
  diagnoses <- diagnosesFuture
  annUnique <- ProjVec(subsetRates$annunique, nprojYears)
  deathrate <- ProjVec(subsetRates$deathrate, nprojYears)
  osrateOverall <- ProjVec(subsetRates$mrate, nprojYears)
  osrateAge <- ProjVec(hivBase$migrationrate, nprojYears)
  propStay <- ProjVec(subsetRates$propstay, nprojYears)   
  
  # CHANGE DEFAULTS HERE
  # 
  # Example showing counterfactual to calculate number living 
  # diagnosed before 1996 etc
  # diagnoses[totalYears > 1996] <- 0 
  # projectName <- "pre1996"
  # Example looking at future impact of PrEP after 2016 assuming 
  # 50% reduction in diagnoses
  # diagnoses[totalYears > 2016] <- 0.5 * diagnoses[totalYears > 2016]
  
  # Do future projections
  pldhivAllFuture <- LivingDiagnosed(diagnoses,
    annUnique, 
    deathrate,
    osrateOverall,
    propStay) %>%
    mutate(year = totalYears) %>%
    select(year, everything())
  
  # Do a similar process for each age group if doing age and run in 
  # Living DiagnosedAge(). To do past 5 years age trends we need to loop
  # cross age groups to generate estimates.
  if (doAge) {
    
    # Setup hivResultsAge for future. Most are the same as for the non-age
    # calculations except diagnoses, relAgeDeath, and relAgeMigrate need to
    # be extended into the future
    
    
    # Status quo diagnoses and relative reductions can be applied across
    # the age groups
    
    if (projectOption == "status-quo") {
      hivResultsAgeFuture <- cbind(hivResultsAge,
        matrix(rep(hivResultsAge[,ncol(hivResultsAge-1)], nprojYears), 
          ncol = nprojYears))
      colnames(hivResultsAgeFuture) <- paste0("y", 
        as.character(totalYears))
    } else if (projectOption == "linear") {
      # Project each age group independently
      hivResultsAgeFuture <- cbind(hivResultsAge,
        matrix(0, ncol = nprojYears, nrow = nages))
      colnames(hivResultsAgeFuture) <- paste0("y", 
        as.character(totalYears))
      for (age in 1:nages) {
        # Extract age group diagnoses
        ageDiagnoses <- hivResultsAge[age, ]
        
        # Estimate trends
        trendlm <- lm(diagnoses ~ year, 
          data.frame(year = (analysisYear - 4):analysisYear, 
            diagnoses = tail(ageDiagnoses, 5)))
        trendDiags <- predict(trendlm, data.frame(year = projectYears))
        
        # Make sure diagnoses are at least zero (okay as normalization 
        # should fix this.
        trendDiags[trendDiags < 0] <- 0
        
        # Store final age trends
        hivResultsAgeFuture[age, ] <- c(ageDiagnoses, trendDiags)
      } 
    } else if(projectOption == "reduce") {
      # Assume same reduction across all age groups
      hivResultsAgeFuture <- cbind(hivResultsAge,
        matrix(0, ncol = nprojYears, nrow = nages))
      colnames(hivResultsAgeFuture) <- paste0("y", 
        as.character(totalYears))
      for (age in 1:nages) {
        # Extract age group diagnoses
        ageDiagnoses <- hivResultsAge[age, ]
        
        # Reduce future diagnoses
        diagnosesFuture <- projectDecreaseAll * ProjVec(ageDiagnoses, 
          nprojYears)
        
        # Store final age trends
        hivResultsAgeFuture[age, ] <- diagnosesFuture
      }
    } else {
      # MANUALLY CHANGE HERE TO RUN ALTERNATE SCENARIOS
    }
    
    # Set aged diagnoses option
    diagnosesAge <- hivResultsAgeFuture
    
    # Deaths is a bit tricky because the final row is zero
    relAgeDeathFuture <- cbind(relAgeDeath[, 1:(ncol(relAgeDeath)-1)], 
      matrix(rep(relAgeDeath[, (ncol(relAgeDeath)-1)], nprojYears), 
        ncol = nprojYears), relAgeDeath[, ncol(relAgeDeath)])
    colnames(relAgeDeathFuture) <- paste0("y", as.character(totalYears))
    
    # Migration is straight forward
    relAgeMigrateFuture <- cbind(relAgeMigrate,
      matrix(rep(relAgeMigrate[,ncol(relAgeMigrate-1)], nprojYears), 
        ncol = nprojYears))
    colnames(relAgeMigrateFuture) <- paste0("y", as.character(totalYears))
    
    # Now run projections
    pldhivAgeFuture <- LivingDiagnosedAge(diagnosesAge,
      annUnique, 
      deathrate,
      osrateAge, 
      propStay, 
      agedeath = relAgeDeathFuture,
      agemigrate = relAgeMigrateFuture,
      normalize = pldhivAllFuture$pldhiv)
    
    # COnvert to along data frame
    hivDiagnosedFuture <- as.data.frame(pldhivAgeFuture) %>% 
      rownames_to_column(var = "agebin") %>%
      gather("year", "pldhiv", 2:ncol(.)) %>%
      select(year, everything()) %>%
      mutate(year = as.integer(str_sub(year, 2))) %>%
      as_tibble()
  }
  
  if (saveProjResults) {
    # Create output directory
    resultsPath <- file.path(outputFolder, projectOutput, cascadeName)
    dir.create(resultsPath, showWarnings = FALSE, recursive = TRUE)
    
    # Set up files
    if (doAge) {
      saveStringDetails <- file.path(resultsPath, 
        paste0("pldhiv-", toString(analysisYear), "-age-"))
    } else {
      saveStringDetails <- file.path(resultsPath, 
        paste0("pldhiv-", toString(analysisYear), "-"))
    }
    
    # Save main results
    saveStringPldhiv <- file.path(resultsPath, 
      paste0("HIVpldhivEstimates-", toString(analysisYear)))
    if (doAge) {
      saveStringPldhiv <- paste0(saveStringPldhiv, "-age")
    }
    
    # Save results
    if (doAge) {
      write_csv(rownames_to_column(as.data.frame(pldhivAgeFuture), 
        var = "agebin"), paste0(saveStringDetails, projectName,
          ".csv")) 
      write_csv(hivDiagnosedFuture, paste0(saveStringPldhiv, "-",
        projectName, ".csv"))
      write_csv(pldhivAllFuture, paste0(saveStringDetails, projectName,
        "_overall.csv"))
    } else {
      write_csv(pldhivAllFuture, paste0(saveStringDetails, projectName,
        ".csv"))
    }
  }
  
}
```
