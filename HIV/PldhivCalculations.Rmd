---
title: "PldhivCalculations"
output: html_notebook
author: Neil Bretana and Richard T. Gray
---

This is a draft [R Markdown](http://rmarkdown.rstudio.com) Notebook for 
calculating the number of people living with HIV in Australia. This is one of 
the key steps for producing the estimates of the Australian HIV diagnosis and 
care cascade. 

This notebook is currently in draft form for updating the HIV cascade 
calculation scripts to version 3.0

```{r Knitr options, include=FALSE} 
# This chunk may not be necessary
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE, 
                      include = FALSE) 
```

```{r Front matter}
# This chunk might not be necessary either
mainPackages <- c("dplyr", "tidyr", "ggplot2", "markdown", "cowplot", 
                  "gridExtra")
source(file.path(Rcode, "FrontMatter.R"), echo = TRUE)
fmStr <- FrontMatter(mainPackages, rstudio = "1.0.44")
cat(fmStr)

```

```{r Initialization}
# Chunk to setup everything
# Clear workspace
rm(list=ls()) 

# Setup directories
basePath <- file.path(dirname(getwd()), "HIV")

Rcode <- file.path(dirname(getwd()), "code") 
HIVcode <- file.path(basePath, "code") 
dataFolder <- file.path(basePath, "data")
outputFolder <- file.path(basePath, "output")
figuresFolder <- file.path(basePath, "output","figures")

# Set working directory
#setwd(basePath)

# Load standard libraries and options ----------------------------------
source(file.path(Rcode, "LoadLibrary.R"), echo=TRUE)
source(file.path(Rcode, "DataLibraries.R"), echo=TRUE)
source(file.path(Rcode, "PlotOptions.R"), echo=TRUE)

# Primary script parameters
currTime <- format(Sys.time(), "%y-%m-%d") # to append to files


```

```{r Script parameters}
# Chunk to enter all the script parameters we will use
analysisYear <- 2015
startYear <- 1990

plots <- FALSE       # TRUE if we want to plot things
bindCascade <- TRUE  # TRUE if we want to store all the cascade results 
                     # one data frame

saveCascade <- TRUE       # save final cascade dataframe
saveNotifications <- TRUE # save cleaned notifications set
saveResults <- TRUE       # save information national annual notifications
savePldhiv <- TRUE        # save PLDHIV estimates separately

# set hivSet function parameters
targetGender <- 'all' #M or F, Null both, add code for including/excluding NA's or missings 
targetAge <- 'all' #groups 0, 1, 2, 3, 4...
targetCob <- 'non-australia' #all=including n/a, Thailand, etc.
targetExposure <- 'all'
targetAtsi <- 'non-australia' #0 or 1
targetState <- 'all' #NSW, VIC, etc
targetLocalRegion <- 'all' #tbd
targetGlobalRegion <- 'all' #South-east Asia, Oceania, South American, etc.

# PLDHIV 
nationalUniques <- TRUE # use proportion from National estimates for 
                        # sub-population de-duplication

indigKnown <- FALSE  #TRUE # only use notifications with indigenous
                     # classification for indigenous estimates

permDeparts <- TRUE

# Overall
replaceValues <- TRUE # Replace with specific estimates

```

```{r Functions}
# Load and define useful functions for analysis 
# POTENTIALLY PUT SOME FUNCTIONS INTO A SEPARATE SCRIPT FOR SOURCING

# Load function to remove duplicates
source(file.path(Rcode,"RemoveDuplicates.R"), echo=TRUE)

# Load function to calculate number living with diagnosed HIV
source(file.path(Rcode,"LivingDiagnosed.R"), echo=TRUE)

# Source function for filling in missing data
source(file.path(Rcode, "FillMissing.R"), echo=TRUE)

# Function to easily extract sub-populations of interest 
source(file.path(Rcode, "Subset.R"), echo=TRUE)

# Function for removing duplicates annually
source(file.path(Rcode, "RemoveDuplicatesAnnually.R"), echo=TRUE)

# Function to create file name for deduplicted output
source(file.path(Rcode, "Deduplicate.R"), echo=TRUE)

# Function to create file name for deduplicted output
source(file.path(Rcode, "Deduplicate.R"), echo=TRUE)

# Function to replace estimates
source(file.path(Rcode, "ReplaceEstimates.R"), echo=TRUE)


```

```{r Subset notifications}
# This chunk loads the national notifications and subsets based on the
# specified criteria in Script paramaters

# Load notifications
hivData <- read.csv(file.path(dataFolder, paste("hivnotifications",
                    toString(analysisYear), ".csv", sep = ""))) 

if (replaceValues) {
  # Replace with hard coded estimates where necessary
  
  # Load hard coded estimates
  hardCodeValues <- read.csv(file.path(dataFolder,
                                       "Hard_coded_estimates.csv"))
}

# Setup overarching analysis                   
years <- startYear:analysisYear # Years to calculate and plot 

# Setup extra columns for analysis
hivData$yeardiagnosis <- as.numeric(substr(hivData$datediagnosis, 1, 4))
hivData$yeardeath <- as.numeric(substr(hivData$datedeath, 1, 4))

allYears <- min(hivData$yeardiagnosis):analysisYear # All years of data

# transfer cob to cobCode
hivData$cobcode <- hivData$cob

# load cob and region codes
crCodes <- read.csv(file.path(dataFolder, "countryRegionCodes.csv"))

# if cob is not in crCodes/NA, change to Not Reported 
hivData$cob[!(hivData$cobcode %in% crCodes$COUNTRY_CODE)] <- "Not Reported"

# change cob from code to String
hivData$cob <- crCodes$COUNTRY_NAME[match(hivData$cobcode, crCodes$COUNTRY_CODE)]

#add region
hivData$globalregion <- crCodes$REGION[match(hivData$cobcode, crCodes$COUNTRY_CODE)]
  
#clean aboriggroup
hivData$aboriggroup <- rep(NA,nrow(hivData))

if (analysisYear < 2015) {
  hivData$aboriggroup[hivData$cob!=1100|hivData$rob!=7] <- "othercob"
  hivData$aboriggroup[hivData$cob==0] <- NA
  hivData$aboriggroup[hivData$cob == 1100 & hivData$indigenous == "Aboriginal"] <- "indigenous"
  hivData$aboriggroup[hivData$cob == 1100 & hivData$indigenous == "Non indigenous"] <- "non-indigenous" 
} else {
  hivData$aboriggroup[hivData$cob!=1100|hivData$rob!=7] <- "othercob"
  hivData$aboriggroup[hivData$cob==0] <- NA
  hivData$aboriggroup[hivData$cob == 1100 & hivData$indigenous == "Aboriginal"] <- "indigenous"
  hivData$aboriggroup[hivData$cob == 1100 & hivData$indigenous == "Non indigenous"] <- "non-indigenous" 
}

# Quick checks that we are not doing analysis outside of the data.
if (max(hivData$yeardiagnosis) < analysisYear) {
  stop("No data specified for final year of analysis.")
}

if (min(hivData$yeardiagnosis) > startYear) {
  stop("No data specified for first year of analysis.")
}

# Source subset function
# Create subsetted notifications dataframe
hivSetOrig <- filter(hivData, yeardiagnosis <= analysisYear)
hivSet <- subhivset(hivSetOrig, targetAge, targetExposure, targetCob, targetAtsi, targetLocalRegion, targetGlobalRegion)

##get set of AU cob and unknowns to distribute proportion
hivSetKnown <- filter(hivData, yeardiagnosis <= analysisYear)
hivSetKnown <- subset(hivSetKnown, cob!="Not Reported")
hivSetKnown <- subset(hivSetKnown, !is.na(cob))
hivSetUnknown <- filter(hivData, yeardiagnosis <= analysisYear)
hivSetUnknown <- subset(hivSetUnknown, is.na(cob) | cob=="Not Reported")

```

```{r Annual notifications}
# This chunk creates a dataframe of the annual notifications for the specified 
# criteria.
origHivSet <- hivSetOrig %>%
  group_by(yeardiagnosis) %>% 
  summarise(notifications = n()) %>% 
  mutate(totalnotifications  = cumsum(notifications)) %>% 
  filter(yeardiagnosis <= analysisYear)   

hivResults <- hivSet %>% 
  group_by(yeardiagnosis) %>% 
  summarise(notifications = n()) %>% 
  mutate(totalnotifications  = cumsum(notifications)) %>% 
  filter(yeardiagnosis <= analysisYear) 

hivResultsKnown <- hivSetKnown %>% 
  group_by(yeardiagnosis) %>% 
  summarise(notifications = n()) %>% 
  mutate(totalnotifications  = cumsum(notifications)) %>% 
  filter(yeardiagnosis <= analysisYear) 

hivResultsUnknown <- hivSetUnknown %>% 
  group_by(yeardiagnosis) %>% 
  summarise(notifications = n()) %>% 
  mutate(totalnotifications  = cumsum(notifications)) %>% 
  filter(yeardiagnosis <= analysisYear)   


# Fill in missing data and years ----------------------------------------------
fillMissing <- as.data.frame(allYears) 
colnames(fillMissing) <- c("yeardiagnosis")
hivResults <- merge(fillMissing, hivResults, by="yeardiagnosis", all.x=TRUE)
hivResults[is.na(hivResults)] <- 0
hivResultsKnown <- merge(fillMissing, hivResultsKnown, by="yeardiagnosis", all.x=TRUE)
hivResultsKnown[is.na(hivResultsKnown)] <- 0
hivResultsUnknown <- merge(fillMissing, hivResultsUnknown, by="yeardiagnosis", all.x=TRUE)
hivResultsUnknown[is.na(hivResultsUnknown)] <- 0

#Get proportion of unknown 
proportion <- as.data.frame(allYears) 
colnames(proportion) <- c("yeardiagnosis")
proportion$proportion <- hivResults$notifications/hivResultsKnown$notifications
proportion$proportion[is.na(proportion$proportion)] <- 0
hivResults$notifications <- hivResults$notifications + floor(proportion$proportion*hivResultsUnknown$notifications)
hivResults$totalnotifications <- cumsum(hivResults$notifications)

```

```{r Load overall estimates}
# This chunk creates or loads the overall cascade estimates for proportion 
# unique, mortality, and overses migration
#Get proportion unique
# Function to estimate proportion unique
source(file.path(Rcode, "ProportionUnique.R"), echo=TRUE)
hivResults$propunique <- ProportionUnique(hivSetOrig, hivResults, origHivSet)
hivResults$uniquecases <- hivResults$totalnotifications*hivResults$propunique

# Function to estimate migration rate
source(file.path(Rcode, "EstimateMigration.R"), echo=TRUE)

#Function to estimate death rate
source(file.path(Rcode, "EstimateMortality.R"), echo=TRUE)

hivResults$osrate <- allMigrate$rate
hivResults$oslower <- allMigrate$lower
hivResults$osupper <- allMigrate$upper

hivResults$deathslinked <- deaths
hivResults$deathslower <- deaths_min
hivResults$deathsupper <- deaths_max

hivResults$deathrate <- deathRate
hivResults$drlower <- deathRate_min
hivResults$drupper <- deathRate_max

```

```{r Adjust parameters}
# This chuck is used to create adjusted mortality and migration rates for the 
# specified criteria

load("nonIndigenous_Adjustment.Rda")


 
```

```{r Calculate PLDHIV}
# This chunk fianlly calculates the number of people living with diagnosed HIV

if (analysisYear <= 2014) {
  propStay <- 1
  propStayLower <- 1
  propStayUpper <- 1
} else {
  propStay <- 0.98
  propStayLower <- 0.96
  propStayUpper <- 1
} 
# Initialize final results data frame
hivDiagnosed <- data.frame(stage = character(), 
                           year = double(),
                           population = character(),
                           estimate = double(),
                           lower = double(),
                           upper = double())

# First calculate overall number -----------------------------------------

# Setup all our vectors - first by filling in missing cumulative diagnoses
filledDiagnoses <- FillMissing(allYears, hivResults$yeardiagnosis, 
                                 hivResults$uniquecases)

cumDiagnoses <- filledDiagnoses$value

# All death rates used for all  populations
deathRate <- hivResults$deathrate
deathRateMin <- hivResults$drlower
deathRateMax <- hivResults$drupper

# National migration rates
migrationRate <- filter(hivMigrate, state == "all")$rate
migrationRateMin <- filter(hivMigrate, state == "all")$lower
migrationRateMax <- filter(hivMigrate, state == "all")$upper

# Calculate number living with diagnosed HIV and range
pldhivAll <- LivingDiagnosed(cumDiagnoses, nonAborigMortalityFactor * deathRate,
                             nonAborigMigrationFactor * migrationRate, ) # propStay)

# Use max rates for min estimate because they are removal rates 
# and vice versa
pldhivAllMin <- LivingDiagnosed(cumDiagnoses,
                                deathRateMax,
                                migrationRateMax,
                                propStayLower) 
pldhivAllMax <- LivingDiagnosed(cumDiagnoses,
                                deathRateMin,
                                migrationRateMin,
                                propStayUpper) 

# Store results
nyears <- length(allYears)
hivDiagnosed <- rbind(hivDiagnosed, 
                      data_frame(stage = "pldhiv", 
                            year = allYears, 
                            population = "all", 
                            value = pldhivAll,
                            lower = pldhivAllMin,
                            upper = pldhivAllMax))


# Finally bind to overall results -----------------------------------------
if (bindCascade) {
  hivCascade <- rbind(hivCascade, hivDiagnosed)
}

# Replace values with hard coded if necessary
if (replaceValues) {
  tempHardCode <- filter(hardCodeValues, stage == "pldhiv")
  if (nrow(tempHardCode) > 0) {
    hivCascade <- replaceEstimates(hivCascade, tempHardCode)
  }
}

```


