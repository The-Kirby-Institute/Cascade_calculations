---
title: "HIV Cascade Trends Exploration"
author: "Richard T. Gray"
date: Latest version - `r format(Sys.Date(), format="%B %d, %Y")`
---

This document is used to explore trends in the national Australian HIV 
Cascade.  

```{r setup}
# Open as a project (setting working directory to source and restarting R)

# Set up directories
basePath <- getwd()
Rcode <- file.path(dirname(getwd()), "code")
HIVcode <- file.path(basePath, "code") 
dataFolder <- file.path(basePath, "data")
resultsFolder <- file.path(basePath, "output")

# Notifications folder is a private secure folder 
notificationsFolder <- file.path("/", "SVR-NAS", "Public", "SERP", "Data", 
  "National HIV Registry", "Cascades")

# Load standard libraries and options ----------------------------------
source(file.path(Rcode, "LoadLibrary.R"))
source(file.path(Rcode, "PlotOptions.R"))
source(file.path(Rcode, "PlotColors.R"))
source(file.path(Rcode, "EveryNth.R"))
source(file.path(Rcode, "FormatData.R"))
source(file.path(HIVcode, "ResultsFunctions.R"))
LoadLibrary(tidyverse)
LoadLibrary(segmented)
LoadLibrary(MASS) # For negative binomial fitting - masks dply::select()
LoadLibrary(AER) # To test for over dispersion using dispersion() - https://biometry.github.io/APES/LectureNotes/2016-JAGS/Overdispersion/OverdispersionJAGS.pdf
LoadLibrary(scales)
LoadLibrary(cowplot) # Note this masks ggsave with save_plot
LoadLibrary(captioner)
LoadLibrary(stringr)
LoadLibrary(svglite)

# Functions to tidy notifications
source(file.path(Rcode, "AgeCat.R"))
source(file.path(HIVcode, "TidyNotifications.R"))

# Script parameters
resultsYear <- 2023  # year of cascade we will plot
minYear <- 20      # how long ago do we plot things
startYear <- resultsYear - minYear + 1 
savePlots <- TRUE
years <- startYear:resultsYear
expModelType <- "nb" # "nb" = negative binomial (default) or "poisson"

# Set up project and cascade to analyse
projectName <- "HIV_Cascade_Paper"  
resultsFolder <- file.path(resultsFolder, projectName)
cascadeName <- "All-2023"
cascadePop <- "all"

# New infections parameters
infectsCalculation <- "exclude" # "include", "exclude" or "middle"

# Specifications for each cascade step and indicator - primarily for plotting
allIndicators <- c("infected", "pldhiv", "retained", "numART", "suppressed",
  "undiagnosed", "noART", "unsuppressed", "diagnoses_exclude",
  "diagnoses_include", "infections", "propdiagnosed", "proptreated",
  "propsuppressed", "propoverall", "ydf", "cdr", "ipr", "imr")

indicatorNames <- c("infected" = "Living with HIV",
  "pldhiv" = "Diagnosed",
  "retained" = "Retained in care",
  "numART" = "Receiving ART",
  "suppressed" = "Suppressed virus",
  "undiagnosed" = "Undiagnosed",
  "noART" = "Diagnosed but untreated",
  "unsuppressed" = "On ART but unsuppressed",
  "diagnoses_exclude" = "Diagnoses excluding OS",
  "diagnoses_include" = "Diagnoses including OS",
  "infections" ="Annual new infections",
  "propdiagnosed" = "Percentage diagnosed",
  "proptreated" =  "Percentage diagnosed treated",
  "propsuppressed" = "Percentage treated suppressed",
  "propoverall" = "Percentage suppressed overall",
  "ydf" = "Yearly diagnosed fraction",
  "cdr" = "Case detection rate",
  "ipr" = "Incidence prevalence ratio",
  "imr" = "Incidence mortality ratio")

indicatorNamesNeat <- c("infected" = "Number living with HIV",
  "pldhiv" = "Number diagnosed",
  "retained" = "Number retained in care",
  "numART" = "Number on ART",
  "suppressed" = "Number suppressed\n(VL < 200 copies/ml)",
  "undiagnosed" = "Number living with HIV\nundiagnosed",
  "noART" = "Number diagnosed\n not on ART",
  "unsuppressed" = "Number unsuppressed\n(VL >= 200 copies/ml)",
  "diagnoses_exclude" = "Annual notifications\n(excluding OS diagnoses)",
  "diagnoses_include" = "Annual notifications\n(including OS diagnoses)",
  "infections" = "Annual new infections\n ",
  "propdiagnosed" = "Percentage of\nPLHIV diagnosed", 
  "proptreated" =  "Percentage diagnosed\non ART",
  "propsuppressed" =  "Percentage on\nART suppressed",
  "propoverall" = "Percentage overall\nsuppressed",
  "ydf" = "Yearly diagnosed fraction", 
  "cdr" = "Case detection rate",
  "ipr" = "Incidence prevalence ratio",
  "imr" = "Incidence mortality ratio")

# Create output directory and figure file format
saveFormat <- ".png" #".svg"
figFolder <- file.path(resultsFolder, "figures", resultsYear)
dir.create(figFolder, showWarnings = FALSE, recursive = TRUE)

runtests <- FALSE # run chunks that have testing code

# Captions
# figs <- captioner()
# tabs <- captioner(prefix = "Table")
captions <- list()

# Plot colours 
asrcols <- PlotColors("hivcascade5")

# Number of x-axis labels
xTicks <- 4

# Formatted decimal point in output tables
decimalMark <- "mid" # "low" or "mid" 

```

```{r loadresults}

# Load hiv cascade dataframe
inputFile <- file.path(resultsFolder, cascadeName,
  paste0("HIVcascadeEstimates-", resultsYear, ".csv"))
hivCascadeAll <- read.csv(inputFile)

# Exclude linked and retained in care
hivCascade <- filter(hivCascadeAll, stage != "linked", stage != "retained")

# Only look at the overall national cascade
resultsAll <- filter(hivCascade,
  population == cascadePop,
  year >= startYear)

# Load cleaned notifications data and tidy up for diagnoses trend calculations
origHivData <- read.csv(file.path(notificationsFolder, 
  paste0("cascadeHIVnotifications-clean-", resultsYear, 
    ".csv"))) |>
  filter(yearhiv <= resultsYear)

countryCodes <- read.csv(file.path(dataFolder, 
  "countryRegionCodes.csv"))
# Read in location of diagnosis coding
regionCodes <- read.csv(file.path(dataFolder, "postcodeRegionCodes.csv"))
hivSet <- TidyNotifications(origHivData, resultsYear, countryCodes,
  regionCodes)

# Load new infections estimates
inputFileInfections <- file.path(resultsFolder, cascadeName,
  paste0("newInfectionsEstimates-", resultsYear, ".csv"))
hivNewInfections <- read.csv(inputFileInfections) 
if (infectsCalculation == "include") {
  hivNewInfections <- hivNewInfections %>%
    filter(exclude == "no") %>% 
    dplyr::select(-exclude)
} else if (infectsCalculation == "exclude") {
  hivNewInfections <- hivNewInfections %>%
    filter(exclude == "yes") %>% 
    dplyr::select(-exclude)
} else {
  # Its "middle"
  infectsInclude <- hivNewInfections %>%
    filter(exclude == "no") %>% 
    dplyr::select(-exclude)
  infectsExclude <- hivNewInfections %>%
    filter(exclude == "yes") %>% 
    dplyr::select(-exclude)
  
  hivNewInfections <- tibble(year = infectsInclude$year,
    infections = (infectsInclude$infections + 
        infectsExclude$infections) / 2,
    infections_lower = infectsExclude$infections_lower,
    infections_upper = infectsInclude$infections_upper)
}

# Load cascade indicator estimates - might not need as we can recalculate 
# separately 
inputFileIndicators<- file.path(resultsFolder, cascadeName,
  paste0("cascadeIndicators.csv"))
hivCascadeIndicators <- read.csv(inputFileIndicators) %>%
  filter(year >= startYear)

```

# Simple trends of the cascade steps and gaps

We used a simple Poisson/Negative-binomial regression model with year as the 
independent covariate for the main cascade steps and indicators over 2004-2022. 
A more advanced trend analyses for the cascade steps was completed by co-author 
Hamish McMannus but we decided a simple regression of the best estimates would be 
sufficient. Hamish's analysis is available in the trend_analysis folder.

We aimed to produce a number of diagnostics of the regression fit. We considered
a pseudo R^2 calculation. The pseudo-R^2 uses the rsq package https://cran.r-project.org/web/packages/rsq/index.html
based on the calculation in the paper: Cameron & Windmeijer, An R-squared measure 
of goodness of fit for some common nonlinear regression model, Journal of 
Econometrics, 77 (1997) 329-342. However, this package does not seem to work in 
the latest versions of R so I decided to drop it. 

Considered test for heteroscedasticity in the residuals using the 
Breusch-Pagan test (P > 0.05 means it is okay) using bptest() from the 
lmtest package https://cran.r-project.org/web/packages/rsq/index.html 
(but I don't think it is valid for Poisson models). Also the standard in built 
Chi-squared test isn't valid for Poisson based on this blog post: http://thestatsgeek.com/2014/04/26/deviance-goodness-of-fit-test-for-poisson-regression/
So I dropped these tests. 

In the end I decided not to produce a goodness-of-fit value. Rather just rely on
visual inspection and BIC when comparing models. 

```{r simple trends}
# This chunk is used to do some simple trend analysis of the cascade
# and other indicator estimates over 2004-2020. Throughout coefficients of 
# Poisson/Negative-binomial models are exponentiated to represent a rate ratio. 
# Trends for the cascade percentages and cascade indicators are done in the next 
# chunk because they need an offset as they are proportions/ratios. 

plotTrends <- FALSE # add overall trend lines to plots

# Notifications ----------------------------------------------------------

# Notifications including and excluding people previously diagnosed overseas
diagsDataExclude <- hivSet %>%
  filter(is.na(previ_diag_overseas)) %>%
  group_by(yeardiagnosis) %>%
  summarise(diags = n()) %>%
  rename(year = yeardiagnosis) %>%
  filter(year >= startYear) %>%
  mutate(overseas = "no")

diagsDataInclude <- hivSet %>%
  group_by(yeardiagnosis) %>%
  summarise(diags = n()) %>%
  rename(year = yeardiagnosis) %>%
  filter(year >= startYear) %>%
  mutate(overseas = "yes")

diagsDataOS <- hivSet %>%
  filter(!is.na(previ_diag_overseas)) %>%
  group_by(yeardiagnosis) %>%
  summarise(diags = n()) %>%
  rename(year = yeardiagnosis) %>%
  filter(year >= startYear) %>%
  mutate(overseas = "only")

diagsData <- dplyr::bind_rows(diagsDataExclude, diagsDataInclude, diagsDataOS)

if (expModelType == "nb") {
  trendDiagsExclude <- glm.nb(diags ~ year, data = diagsDataExclude)
  trendDiagsInclude <- glm.nb(diags ~ year, data = diagsDataInclude)
  trendDiagsOS <- glm.nb(diags ~ year, data = diagsDataOS)
} else {
  trendDiagsExclude <- glm(diags ~ year, data = diagsDataExclude,
    family = "poisson")
  trendDiagsInclude <- glm(diags ~ year, data = diagsDataInclude,
    family = "poisson")
  trendDiagsOS <- glm(diags ~ year, data = diagsDataOS,
    family = "poisson")
}

coeffDiagsExclude <- exp(coef(trendDiagsExclude)[2])
p_valueDiagsExclude  <- summary(trendDiagsExclude)$coefficients["year", "Pr(>|z|)"]
intervalDiagsExclude  <- exp(confint(trendDiagsExclude, "year", type = "Wald"))

coeffDiagsInclude <- exp(coef(trendDiagsInclude)[2])
p_valueDiagsInclude <- summary(trendDiagsInclude)$coefficients["year", "Pr(>|z|)"]
intervalDiagsInclude <- exp(confint(trendDiagsInclude, "year", type = "Wald"))

coeffDiagsOS <- exp(coef(trendDiagsOS)[2])
p_valueDiagsOS <- summary(trendDiagsOS)$coefficients["year", "Pr(>|z|)"]
intervalDiagsOS <- exp(confint(trendDiagsOS, "year", type = "Wald"))

diagsPlot <- ggplot(data = diagsDataExclude, aes(x = year)) +
  geom_line(aes(y = diags, colour = "exclude")) + 
  geom_point(aes(y = diags), colour = "blue") +
  geom_line(data = diagsDataInclude, aes(y = diags, colour = "include")) + 
  geom_point(data = diagsDataInclude, aes(y = diags), colour = "red") +
  geom_line(data = diagsDataOS, aes(y = diags, colour = "gap")) + 
  geom_point(data = diagsDataOS, aes(y = diags), colour = "black") +
  scale_colour_manual(name = "", values = c("red", "blue", "black"),
    breaks = c("include", "exclude", "gap"), 
    labels = c("Including previously diagnosed overseas", 
      "Excluding previously diagnosed overses", 
      "Previously diagnosed overseas (difference)"),
    guide = guide_legend(nrow = 3)) +
  scale_y_continuous(labels = comma, limits = c(0, 1500)) +
  scale_x_continuous(breaks = seq(startYear, resultsYear),
    labels =  rev(EveryNth(seq(resultsYear, startYear), xTicks, inverse = TRUE)),
    limits = c(startYear, resultsYear)) +
  ylab("Annual notifications") + xlab("Year") +
  PlotOptions() 

diagsPlot

if (savePlots) {
  ggsave(file.path(figFolder, paste0("HIVcascade-Diagnoses_",
    startYear, "-", resultsYear, saveFormat)),
    plot = diagsPlot, width = 12, height = 9, units = "cm")
}

# Get new infections
newInfects <- hivNewInfections %>%
  filter(year >= startYear) %>%
  mutate(infections = round(infections),
    infections_lower = round(infections_lower),
    infections_upper = round(infections_upper))

# Gaps between steps -----------------------------------------------------------
diffsData <- tibble(year = diagsDataExclude$year)
diffsData$undiagnosed <- filter(resultsAll, stage == "infected")$value - 
  filter(resultsAll, stage == "pldhiv")$value
diffsData$noART <- filter(resultsAll, stage == "pldhiv")$value - 
  filter(resultsAll, stage == "numART")$value
diffsData$unsuppressed <- filter(resultsAll, stage == "numART")$value - 
  filter(resultsAll, stage == "suppressed")$value

diffSteps <- names(diffsData)[-1]

diffsData <- gather(diffsData, "stage", "value", 2:4)

diffsData$lower <- NA
diffsData$upper <- NA

trendData <- bind_rows(dplyr::select(resultsAll, year, stage, value,
  lower, upper), diffsData) %>%
  as_tibble()

# Add diagnoses and infections data --------------------------------------------
trendData <- bind_rows(trendData,
  diagsDataExclude %>% 
    mutate(stage = "diagnoses_exclude", lower = NA, upper = NA) %>% 
    dplyr::select(year, stage, value = diags, lower, upper),
  diagsDataInclude %>% 
    mutate(stage = "diagnoses_include", lower = NA, upper = NA) %>% 
    dplyr::select(year, stage, value = diags, lower, upper), 
  newInfects %>% 
    mutate(stage = "infections") %>% 
    dplyr::select(year, stage, value = infections, lower = infections_lower, 
      upper = infections_upper))

# Trends ----------------------------------------------------
steps <- unique(trendData$stage)

trendCascade <- tibble(stage = character(length(steps)), 
  coeff = numeric(length(steps)),
  pvalue = numeric(length(steps)),
  lower = numeric(length(steps)),
  upper = numeric(length(steps)))

# Set up to save all the models and plots
trendModels <- list()
trendPlots <- list()

for (ii in 1:length(steps)) {
  tempData <- filter(trendData, stage == unique(trendData$stage)[ii])
  
  if (expModelType == "nb") {
    temp <- glm.nb(round(value) ~ year, data = tempData)
  } else {
    temp <- glm(round(value) ~ year, data = tempData, family = "poisson")
  }

  trendCascade$stage[ii] <- steps[ii]
  trendCascade$coeff[ii] <- exp(coef(temp)[2])
  trendCascade$pvalue[ii] <- summary(temp)$coefficients["year",
    "Pr(>|z|)"]
  tempInterval <- exp(confint(temp, "year", type = "Wald"))
  trendCascade$lower[ii] <- tempInterval[1]
  trendCascade$upper[ii] <- tempInterval[2]
  
  trendModels[[steps[ii]]] <- temp
}

# Simple Trend plots -----------------------------------------------------------

yLabels <- indicatorNamesNeat

# Function to produce plots of data versus trend
PlotTrend <- function(data, models, indicator, trend = TRUE) {
  model <- models[[indicator]]
  tempData <- filter(data, stage == indicator)
  tempPlot <- ggplot(data = tempData, aes(x = year, y = value)) +
    geom_ribbon(aes(ymin = lower, ymax = upper), 
      fill = asrcols[2], alpha = 0.4) +
    geom_line(color = asrcols[2]) + 
    geom_point(color = asrcols[2]) +
    scale_x_continuous(breaks = seq(startYear, resultsYear),
      labels =  rev(EveryNth(seq(resultsYear, startYear), xTicks, inverse = TRUE)),
      limits = c(startYear, resultsYear)) +
    ylab(yLabels[indicator]) + xlab("Year") +  
    scale_y_continuous(labels = comma, limits = c(0, NA)) +
    PlotOptions() 
  
  if (trend) {
    tempPlot <- tempPlot +
      geom_line(aes(y = predict(model, type = "response")),
        colour = "black")
  }
  
  # Save the current plot
  if (savePlots) {
    ggsave(file.path(figFolder, paste0("HIVcascade-Trends-", indicator, "_",
      toString(startYear), "-",
      toString(resultsYear),
      saveFormat)),
      plot = tempPlot, width = 12, height = 9, 
      units = "cm")
  }
  
  return(tempPlot)
}

# Apply to all steps - note will get warnings for steps where lower and upper 
# are NA
trendPlots <- lapply(steps, PlotTrend, data = trendData, 
  models = trendModels, trend = plotTrends)
names(trendPlots) <- steps

# Create group plots -----------------------------------------------------------

# Cascade steps
stagesTrendPlot <- plot_grid(trendPlots[[1]], trendPlots[[2]],
  trendPlots[[3]], trendPlots[[4]],
  labels = c("A", "B", "C", "D"), ncol = 2, 
  nrow = 2, align = "v")

# Cascade gaps
stagesDiffsPlot <- plot_grid(trendPlots[[5]], trendPlots[[6]],
  trendPlots[[7]],
  labels = c("A", "B", "C"), ncol = 2, 
  nrow = 2, align = "v")

# Save the current plots
if (savePlots) {
  ggsave(file.path(figFolder, paste("HIVcascade-Stages-Trends_",
    toString(startYear), "-",
    toString(resultsYear),
    saveFormat, sep = "")),
    plot = stagesTrendPlot, width = 18, height = 15, units = "cm")
  
  ggsave(file.path(figFolder, paste("HIVcascade-Differences-Trends_",
    toString(startYear), "-",
    toString(resultsYear),
    saveFormat, sep = "")),
    plot = stagesDiffsPlot, width = 18, height = 15, units = "cm")
}

```

# Trends in the UNAIDS 95-95-95 targets and Cascade Indicators

This section looks at the trends in the UNAIDS 95-95-95 targets and other
cascade indicators which are proportions or ratios. We used a 
Poisson/negative-binomial model with an offset to get a rate ratio. For each gap 
we obtain linear, logistic, and exponential trends for comparison but used the 
exponential models for ease of interpretability. 

```{r Trends 95-95-95}
# This chunk looks at the trends in the UNAIDS 95-95-95 targets.

# Produce the proportions
diagnosedProp <- filter(trendData, stage == "pldhiv")$value / 
  filter(trendData, stage == "infected")$value
artProp <- filter(trendData, stage == "numART")$value / 
  filter(trendData, stage == "pldhiv")$value
supProp <- filter(trendData, stage == "suppressed")$value / 
  filter(trendData, stage == "numART")$value
overallProp <- filter(trendData, stage == "suppressed")$value / 
  filter(trendData, stage == "infected")$value

year <- startYear:resultsYear

# Add to trend data and save
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "propdiagnosed", value = diagnosedProp, lower = NA, upper = NA))
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "proptreated", value = artProp, lower = NA, upper = NA))
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "propsuppressed", value = supProp, lower = NA, upper = NA))
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "propoverall", value = overallProp, lower = NA, upper = NA))

# Linear models -----------------------------------------------------------
# First simple linear models which allow us to estimate the percentage 
# point increase each year
diagslmModel <- lm(diagnosedProp ~ year)
treatedlmModel <- lm(artProp ~ year)
suppressedlmModel <- lm(supProp ~ year)
overalllmModel <- lm(overallProp ~ year)

# Coefficients for annual change
coefflmdiags <- coef(diagslmModel)["year"]
coefflmart <- coef(treatedlmModel)["year"]
coefflmsuppressed <- coef(suppressedlmModel)["year"]
coefflmoverall <- coef(overalllmModel)["year"]

# P-values for annual change
p_valuelmdiags <- summary(diagslmModel)$coefficients["year", "Pr(>|t|)"]
p_valuelmart <- summary(treatedlmModel)$coefficients["year", "Pr(>|t|)"]
p_valuelmsuppressed <- summary(suppressedlmModel)$coefficients["year",
  "Pr(>|t|)"]
p_valuelmoverall <- summary(overalllmModel)$coefficients["year",
  "Pr(>|t|)"]

# Confidence interval for annual change
intervallmdiags <- confint(diagslmModel, "year", type = "Wald")
intervallmart <- confint(treatedlmModel, "year", type = "Wald")
intervallmsuppressed <- confint(suppressedlmModel, "year", type = "Wald")
intervallmoverall <- confint(overalllmModel, "year", type = "Wald")

# Logistic models ---------------------------------------------------------
# Fit logistic curve to each trend to see if it produces a better fit. Feel
# a logistic curve is the best fit for proportions to account for 
# saturation, however, hard to interpret. Used here for comparison to the
# linear and exponential models.

diagnosedTrials <- cbind(round(filter(trendData, 
  stage == "pldhiv")$value), round(filter(trendData, 
    stage == "undiagnosed")$value))
artTrials <- cbind(round(filter(trendData, 
  stage == "numART")$value), round(filter(trendData, 
    stage == "noART")$value))
suppressedTrials <- cbind(round(filter(trendData, 
  stage == "suppressed")$value), round(filter(trendData, 
    stage == "unsuppressed")$value))
overallTrials <- cbind(round(filter(trendData, 
  stage == "suppressed")$value), round(filter(trendData, 
    stage == "infected")$value - filter(trendData, 
      stage == "suppressed")$value))

diagsModel <- glm(diagnosedTrials ~ year, 
  family = binomial(link = "logit"))
treatedModel <- glm(artTrials ~ year, 
  family = binomial(link = "logit"))
suppressedModel <- glm(suppressedTrials ~ year, 
  family = binomial(link = "logit"))
overallModel <- glm(overallTrials ~ year, 
  family = binomial(link = "logit"))

# Calculate p-values
p_diags <- summary(diagsModel)$coefficients["year", "Pr(>|z|)"]
p_art <- summary(treatedModel)$coefficients["year", "Pr(>|z|)"]
p_suppressed <- summary(suppressedModel)$coefficients["year", "Pr(>|z|)"]
p_overall <- summary(overallModel)$coefficients["year", "Pr(>|z|)"]

# Negative binomial/Poisson models ---------------------------------------------
# Use a Negative binomial/Poisson model with an offset to produce a rate ratio 
# for the change in the proportion. These are the main models we will use. 

trendModelsProp <- list()
trendPlotsProp <- list()

# Set-up data for Poisson/negative-binomial exponential models
expTrendData <- trendData %>% 
  dplyr::select(year, stage, value) %>% 
  mutate(value = round(value)) %>%
  tidyr::spread(stage, value)

# Models - using denominator as an offset 
if (expModelType == "nb") {
  # For diagnosed proportion get warnings about iteration limit and
  # a very large theta using glm.nb however still seem to get a good fit
  diagsExpModel <- glm.nb(pldhiv ~ year + offset(log(infected)), 
    data = expTrendData)  
  
  treatedExpModel  <- glm.nb(numART ~ year +offset(log(pldhiv)), 
    data = expTrendData)
  suppressedExpModel  <- glm.nb(suppressed ~ year + offset(log(numART)), 
    data = expTrendData)
  overallExpModel  <- glm.nb(suppressed ~ year + offset(log(infected)), 
    data = expTrendData)
} else {
  diagsExpModel <- glm(pldhiv ~ year, offset = log(infected),
    data = expTrendData, family = "poisson")
  treatedExpModel  <- glm(numART ~ year, offset = log(pldhiv),
    data = expTrendData, family = "poisson")
  suppressedExpModel  <- glm(suppressed ~ year, offset = log(numART),
    data = expTrendData, family = "poisson")
  overallExpModel  <- glm(suppressed ~ year, offset = log(infected),
    data = expTrendData, family = "poisson")

}

trendModelsProp[["propdiagnosed"]] <- diagsExpModel
trendModelsProp[["proptreated"]] <- treatedExpModel
trendModelsProp[["propsuppressed"]] <- suppressedExpModel
trendModelsProp[["propoverall"]] <- overallExpModel

# Coefficients for annual change (as rate ratio)
coeffExpdiags <- exp(coef(diagsExpModel)["year"])
coeffExpart <- exp(coef(treatedExpModel)["year"])
coeffExpsuppressed <- exp(coef(suppressedExpModel)["year"])
coeffExpoverall <- exp(coef(overallExpModel)["year"])

# P-values for annual change
p_valueExpdiags <- summary(diagsExpModel)$coefficients["year", "Pr(>|z|)"]
p_valueExpart <- summary(treatedExpModel)$coefficients["year", "Pr(>|z|)"]
p_valueExpsuppressed <- summary(suppressedExpModel)$coefficients["year",
  "Pr(>|z|)"]
p_valueExpoverall <- summary(overallExpModel)$coefficients["year",
  "Pr(>|z|)"]

# Confidence interval for annual change (as a rate ratio)
intervalExpdiags <- exp(confint(diagsExpModel, "year", type = "Wald"))
intervalExpart <- exp(confint(treatedExpModel, "year", type = "Wald"))
intervalExpsuppressed <- exp(confint(suppressedExpModel, "year", 
  type = "Wald"))
intervalExpoverall <- exp(confint(overallExpModel, "year", type = "Wald"))

# Plots of estimates and trends ------------------------------------------------

# Plot the proportion, linear model and logistic model for comparison

# Functions for plotting
plotPropFull <- function(proportion, lmmodel, logmodel, expmodel, expoffset,
  label, ymax = 1) {
  propPlot <- ggplot(data = data.frame(year = year), aes(x = year)) + 
    geom_line(aes(y = proportion, color = "prop")) + 
    geom_point(aes(y = proportion), color = asrcols[2]) +
    geom_line(aes(y = fitted(lmmodel), colour = "linear")) +
    geom_line(aes(y = fitted(logmodel), colour = "logistic")) +
    geom_line(aes(y = fitted(expmodel)/expoffset, colour = "exponential")) +
    scale_colour_manual(name = "",
      limits = c("prop", "linear", "logistic", "exponential"), 
      values = c(asrcols[2], "black", "blue", "dark green"),
      labels = c("Estimated proportion", "Linear model", 
        "Logistic model", "Exponential model")) + 
    scale_x_continuous(breaks = seq(startYear, resultsYear),
      labels =  rev(EveryNth(seq(resultsYear, startYear), xTicks, inverse = TRUE)),
      limits = c(startYear, resultsYear)) +
    scale_y_continuous(labels = percent, limits = c(0, ymax)) + 
    ylab(label) + xlab("Year") +  
    PlotOptions() 
  
  return(propPlot)
}

plotProp <- function(proportion, expmodel, expoffset, label, ymax = 1, 
  trend = TRUE) {
  propPlot <- ggplot(data = data.frame(year = year), aes(x = year)) + 
    geom_line(aes(y = proportion), color = asrcols[2]) + 
    geom_point(aes(y = proportion), color = asrcols[2]) +
    scale_x_continuous(breaks = seq(startYear, resultsYear),
      labels =  rev(EveryNth(seq(resultsYear, startYear), xTicks, inverse = TRUE)),
      limits = c(startYear, resultsYear)) +
    scale_y_continuous(labels = percent, limits = c(0, ymax)) + 
    ylab(label) + xlab("Year") +  
    PlotOptions() 
  
  if (trend) {
    propPlot <- propPlot + 
      geom_line(aes(y = fitted(expmodel)/expoffset), colour = "black")
  }
  
  return(propPlot)
}

# Produce plots
diagsPropPlotFull <- plotPropFull(diagnosedProp, diagslmModel, diagsModel, 
  diagsExpModel, expTrendData$infected, yLabels["propdiagnosed"])
treatedPropPlotFull <- plotPropFull(artProp, treatedlmModel, treatedModel,
  treatedExpModel, expTrendData$pldhiv, yLabels["proptreated"])
suppressedPropPlotFull <- plotPropFull(supProp, suppressedlmModel, 
  suppressedModel, suppressedExpModel, expTrendData$numART,
  yLabels["propsuppressed"])
overallPropPlotFull <- plotPropFull(overallProp, overalllmModel, 
  overallModel, overallExpModel, expTrendData$infected, 
  yLabels["propoverall"])

diagsPropPlot <- plotProp(diagnosedProp, diagsExpModel, 
  expTrendData$infected,  yLabels["propdiagnosed"], 
  trend = plotTrends)
treatedPropPlot <- plotProp(artProp, treatedExpModel, 
  expTrendData$pldhiv,  yLabels["proptreated"], 
  trend = plotTrends)
suppressedPropPlot <- plotProp(supProp, suppressedExpModel, 
  expTrendData$numART,  yLabels["propsuppressed"], 
  trend = plotTrends)
overallPropPlot <- plotProp(overallProp, overallExpModel,
  expTrendData$infected,  yLabels["propoverall"], 
  trend = plotTrends)

trendPlotsProp[["propdiagnosed"]] <- diagsPropPlot
trendPlotsProp[["proptreated"]] <- treatedPropPlot
trendPlotsProp[["propsuppressed"]] <- suppressedPropPlot
trendPlotsProp[["propoverall"]] <- overallPropPlot

# Add linear and Poisson model results to trendCascade
propTrends <- tibble(stage = c("propdiagnosed", "proptreated",
  "propsuppressed", "propoverall"),
  coeff = c(coefflmdiags, coefflmart, coefflmsuppressed, coefflmoverall),
  pvalue = c(p_valuelmdiags, p_valuelmart, p_valuelmsuppressed,
    p_valuelmoverall),
  lower = c(intervallmdiags[1], intervallmart[1], intervallmsuppressed[1],
    intervallmoverall[1]),
  upper = c(intervallmdiags[2], intervallmart[2], intervallmsuppressed[2],
    intervallmoverall[2]),
  model = "linear")

expModelString <- ifelse(expModelType == "nb", "negative-binomial-offset", 
  "poisson-offset")

propTrendsExp <- tibble(stage = c("propdiagnosed", "proptreated",
  "propsuppressed", "propoverall"),
  coeff = c(coeffExpdiags, coeffExpart, coeffExpsuppressed, coeffExpoverall),
  pvalue = c(p_valueExpdiags, p_valueExpart, p_valueExpsuppressed,
    p_valueExpoverall),
  lower = c(intervalExpdiags[1], intervalExpart[1], intervalExpsuppressed[1],
    intervalExpoverall[1]),
  upper = c(intervalExpdiags[2], intervalExpart[2], intervalExpsuppressed[2],
    intervalExpoverall[2]),
  model = expModelString)

trendCascadeProp <- bind_rows(propTrends, propTrendsExp)

# Save plots --------------------------------------------------------------
# Create a group 90-90-90 plot with trend lines
legend <- get_legend(diagsPropPlot)

# Update group plot
combinedPropPlot <- plot_grid(
  diagsPropPlot + theme(legend.position="none"), 
  treatedPropPlot + theme(legend.position="none"),
  suppressedPropPlot + theme(legend.position="none"), 
  overallPropPlot + theme(legend.position="none"), 
  ncol = 2, nrow = 2, 
  labels = c("A", "B", "C", "D")) 

if (savePlots) {
  ggsave(file.path(figFolder,
    paste("HIVcascade_Proportion_Trends_",
      toString(startYear), "-",
      toString(resultsYear),
      saveFormat, sep = "")),
    plot = combinedPropPlot, width = 18, height = 15, units = "cm")
}

```

```{r Trends indicators}
# This chunk looks at the trends in cascade indicators: yearly diagnosed 
# fraction (ydf), case detection rate (cdr), incidence prevalence ratio 
# (ipr), and incidence mortality ratio (imr)

year <- startYear:resultsYear

ydf <- hivCascadeIndicators$ydf
cdr <- hivCascadeIndicators$cdr
ipr <- hivCascadeIndicators$ipr
imr <- hivCascadeIndicators$imr

# Add to trend data and save
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "ydf", 
  value = hivCascadeIndicators$ydf, 
  lower = hivCascadeIndicators$ydf_lower, 
  upper = hivCascadeIndicators$ydf_upper))
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "cdr", 
  value = hivCascadeIndicators$cdr, 
  lower = hivCascadeIndicators$cdr_lower, 
  upper = hivCascadeIndicators$cdr_upper))
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "ipr", 
  value = hivCascadeIndicators$ipr, 
  lower = hivCascadeIndicators$ipr_lower, 
  upper = hivCascadeIndicators$ipr_upper))
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "imr", 
  value = hivCascadeIndicators$imr, 
  lower = hivCascadeIndicators$imr_lower, 
  upper = hivCascadeIndicators$imr_upper))

# Diagnoses used to calculate ydf and cdt are different to the 
# diagnoses_exclude data above # because of different adjustments in the 
# calculations (specifically removal of duplicates addition of seroconvertors)
# These need to be stored to set-up offsets for model the trends models for
# these indicators
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "diagnoses_indicators", 
  value = hivCascadeIndicators$diagnoses, 
  lower = hivCascadeIndicators$diagnoses_lower, 
  upper = hivCascadeIndicators$diagnoses_upper))

trendData <- bind_rows(trendData, tibble(year = year,
  stage = "ydfoffest", 
  value = hivCascadeIndicators$undiag + hivCascadeIndicators$diagnoses, 
  lower = hivCascadeIndicators$undiag_lower + hivCascadeIndicators$diagnoses_lower, 
  upper = hivCascadeIndicators$undiag_upper + hivCascadeIndicators$diagnoses_upper))
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "iproffset",
  # IPR is calculated using the plhiv number from the start of each year
  value = hivCascadeIndicators$start_plhiv,
  lower = hivCascadeIndicators$start_plhiv_lower,
  upper = hivCascadeIndicators$start_plhiv_upper))
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "imroffset",
  value = hivCascadeIndicators$deaths,
  lower = hivCascadeIndicators$deaths_lower,
  upper = hivCascadeIndicators$deaths_upper))

# Negative-binomial/Poisson models ---------------------------------------------
# Use a negative-binomial/Poisson model with an offset to produce a rate ratio 
# for the change in the proportion. These are the main models we will use.

# Set-up data for exponential models
expTrendData <- trendData %>% 
  dplyr::select(year, stage, value) %>% 
  mutate(value = round(value)) %>%
  tidyr::spread(stage, value)

# Models - using denominator as an offset - explicitly add location of of 
# offset so segmented fits work: https://stackoverflow.com/questions/19034403/r-package-segmented-with-an-offset-term

if (expModelType == "nb") {
  ydfModel <- glm.nb(diagnoses_indicators ~ year + offset(log(ydfoffest)), 
    data = expTrendData)
  cdrModel  <- glm.nb(diagnoses_indicators ~ year + offset(log(infections)),
    data = expTrendData)
  iprModel  <- glm.nb(infections ~ year + offset(log(iproffset)), 
    data = expTrendData)
  imrModel  <- glm.nb(infections ~ year + offset(log(imroffset)), 
    data = expTrendData)
} else {
  ydfModel <- glm(diagnoses_indicators ~ year, offset = log(ydfoffest),
    data = expTrendData, family = "poisson")
  cdrModel  <- glm(diagnoses_indicators ~ year, offset = log(infections),
    data = expTrendData, family = "poisson")
  iprModel  <- glm(infections ~ year, offset = log(iproffset),
    data = expTrendData, family = "poisson")
  imrModel  <- glm(infections ~ year, offset = log(imroffset),
    data = expTrendData, family = "poisson")
} 

trendModelsProp[["ydf"]] <- ydfModel
trendModelsProp[["cdr"]] <- cdrModel
trendModelsProp[["ipr"]] <- iprModel
trendModelsProp[["imr"]] <- imrModel

# Coefficients for annual change (as rate ratio)
coeffydf <- exp(coef(ydfModel)["year"])
coeffcdr <- exp(coef(cdrModel)["year"])
coeffipr <- exp(coef(iprModel)["year"])
coeffimr <- exp(coef(imrModel)["year"])

# P-values for annual change
p_valueydf <- summary(ydfModel)$coefficients["year", "Pr(>|z|)"]
p_valuecdr <- summary(cdrModel)$coefficients["year", "Pr(>|z|)"]
p_valueipr <- summary(iprModel)$coefficients["year",   "Pr(>|z|)"]
p_valueimr <- summary(imrModel)$coefficients["year",   "Pr(>|z|)"]

# Confidence interval for annual change (as a rate ratio)
intervalydf <- exp(confint(ydfModel, "year", type = "Wald"))
intervalcdr <- exp(confint(cdrModel, "year", type = "Wald"))
intervalipr <- exp(confint(iprModel, "year", type = "Wald"))
intervalimr <- exp(confint(imrModel, "year", type = "Wald"))

# Plots of estimates and trends ------------------------------------------------

ydfPlot <- plotProp(ydf, ydfModel, expTrendData$ydfoffest, yLabels["ydf"], 
  trend = plotTrends) +
  # Fix up y axis - will get warnings about replacement
  scale_y_continuous(labels = number, limits = c(0, 1)) +
  geom_ribbon(data = filter(trendData, stage == "ydf"),
    aes(ymin = lower, ymax = upper), fill = asrcols[2], alpha = 0.4)

cdrPropPlot <- plotProp(cdr, cdrModel, 
  expTrendData$infections, yLabels["cdr"], 
  trend = plotTrends) +
  # Fix up y axis - will get warnings about replacement
  scale_y_continuous(labels = number, limits = c(0, NA)) +
  geom_ribbon(data = filter(trendData, stage == "cdr"),
    aes(ymin = lower, ymax = upper), fill = asrcols[2], alpha = 0.4)

iprPlot <- plotProp(ipr, iprModel, 
  expTrendData$iproffset, yLabels["ipr"], 
  trend = plotTrends, ymax = 0.1) +
  # Fix up y axis - will get warnings about replacement
  scale_y_continuous(labels = number, limits = c(0, 0.1)) +
  geom_ribbon(data = filter(trendData, stage == "ipr"),
    aes(ymin = lower, ymax = upper), fill = asrcols[2], alpha = 0.4)

imrPlot <- plotProp(imr, imrModel, 
  expTrendData$imroffset, yLabels["imr"], 
  trend = plotTrends) +
  # Fix up y axis - will get warnings about replacement
  scale_y_continuous(labels = number, limits = c(0, NA)) +
  geom_ribbon(data = filter(trendData, stage == "imr"),
    aes(ymin = lower, ymax = upper), fill = asrcols[2], alpha = 0.4)

trendPlotsProp[["ydf"]] <- ydfPlot
trendPlotsProp[["cdr"]] <- cdrPropPlot
trendPlotsProp[["ipr"]] <- iprPlot
trendPlotsProp[["imr"]] <- imrPlot

# Model results to trendCascadeProp
propTrendsIndicators <- tibble(stage = c("ydf", "cdr", "ipr", "imr"),
  coeff = c(coeffydf, coeffcdr, coeffipr, coeffimr),
  pvalue = c(p_valueydf, p_valuecdr, p_valueipr, p_valueimr),
  lower = c(intervalydf[1], intervalcdr[1], intervalipr[1], intervalimr[1]),
  upper = c(intervalydf[2], intervalcdr[2], intervalipr[2], intervalimr[2]),
  model = expModelString)

trendCascadeProp <- bind_rows(trendCascadeProp, propTrendsIndicators)

# Create a group indicator plot ------------------------------------------------
legend <- get_legend(trendPlots$diagnoses_include)

# Update group plot
combinedIndicatorPlot <- plot_grid(
  trendPlots$diagnoses_include + theme(legend.position="none"), 
  trendPlots$diagnoses_exclude + theme(legend.position="none"),
  trendPlots$infections + theme(legend.position="none"),
  trendPlotsProp$ydf + theme(legend.position="none"), 
  trendPlotsProp$cdr + theme(legend.position="none"), 
  trendPlotsProp$ipr + theme(legend.position="none"), 
  trendPlotsProp$imr + theme(legend.position="none"), 
  ncol = 2, nrow = 4, 
  labels = c("A", "B", "C", "D", "E", "F", "G")) 

if (savePlots) {
  ggsave(file.path(figFolder,
    paste("HIVcascade_Indicators_Trends_",
      toString(startYear), "-",
      toString(resultsYear),
      saveFormat, sep = "")),
    plot = combinedIndicatorPlot, width = 18, height = 32, units = "cm")
}

```

```{r Save trends objects}
# Save main trend storage variables for ease of loading later
save(trendData,
  file = file.path(figFolder, "CascadeTrendData.Rda"))
save(trendCascade, trendModels, trendCascadeProp, trendModelsProp, 
  file = file.path(figFolder, "CascadeTrendModels.Rda"))
save(trendPlots, trendModelsProp,
  file = file.path(figFolder, "CascadeTrendPlots.Rda"))
```

```{r Trends table}

# Create a formatted trends data table ---------------------------------------------
# Replace missing lower and upper bounds with zero
trendData[is.na(trendData)] <- 0

formatTrendData <- tibble(year = trendData$year, indicator = trendData$stage)
formatTrendData$value <- FormatData(trendData$value,
  trendData$lower, trendData$upper, places = -1,
  decimal = decimalMark)

# Need to overwrite percentage and proportion estimates so they are not rounded
# and have the right number of decimal places

propIndices <- which(formatTrendData$indicator %in% c("ydf", "cdr", "imr"))

percentIndices <- which(formatTrendData$indicator %in% c("propdiagnosed", 
  "proptreated" , "propsuppressed", "propoverall", "ipr"))

formatTrendData$value[propIndices]  <- FormatData(
  trendData$value[propIndices],
  trendData$lower[propIndices], 
  trendData$upper[propIndices], 
  places = 2, decimal = decimalMark)

formatTrendData$value[percentIndices]  <- FormatData(
  100*trendData$value[percentIndices],
  100*trendData$lower[percentIndices],
  100*trendData$upper[percentIndices], 
  places = 1, decimal = decimalMark, suffix = "%")

# Write the trends data and diagnostics to file
if (savePlots) {
  
  write_excel_csv(trendData, file.path(figFolder, paste0("HIVcascade_Trend_data_",
    toString(startYear), "-", toString(resultsYear), ".csv")))
  
  write_excel_csv(formatTrendData, file.path(figFolder, paste0("HIVcascade_Trend_data_",
    toString(startYear), "-", toString(resultsYear), "-Formatted.csv")))
  
  trendCascade$model <- ifelse(expModelType == "nb", "negative-binomial", "poison")
  trendCascade <- bind_rows(trendCascade, trendCascadeProp)
  
  write_excel_csv(trendCascade, file.path(figFolder, 
    paste0("HIVcascade_trends_", 
      toString(startYear), "-", toString(resultsYear), ".csv")))

}
```

# Exploration of breakpoints

In this section we start exploring the annual estimates for each cascade 
step and indicator for the presence for change or break points. 

We first tried the approach within the changepoint package. This was not 
really useful for trends that are increasing or decreasing as it looks 
forchanges in mean (or variance) rather than slope. Here we just look for
one changepoint using the mean.

The main analysis was done using the breakpoints() function in the 
strucchange package. As there are only 20 time points of data we have to 
set h = 3 (the minimal number of points in each segment for a linear 
regression to be fitted) for the function to work. Given there are only 20 data
points any models with > 3 breakpoints are unlikely to be statistically 
robust and are more likely reflect over-fitting. 

*Note* the following chunks produce errors for some indicators. Given this is just
break point exploration we have chosen to simply ignore these problematic 
indicators. 

```{r Breakpoints}
# This chunk is used to explore if structural break points might be 
# present. The packages here use linear regression. Poisson regression is more
# appropriate but the results give a good summary of where breakpoints might
# occur and can inform initial assumptions for the segmented Poisson approach
# below. 

# Load key libraries
LoadLibrary(tseries)
LoadLibrary(forecast)
LoadLibrary(strucchange)
LoadLibrary(ggfortify) # enable timeseries in autoplot
LoadLibrary(changepoint) # Not really used

# Set up data ------------------------------------------------------------------
# Covert everything into a time series which is more useful in the strucchange 
# package functions. This means results are rounded to the nearest year

tots <- function(indicator) {
  return(ts(filter(trendData, stage == indicator)$value,
    start = c(startYear, 1), end = c(resultsYear, 1),
    frequency = 1)) 
}

infectedts <- tots("infected")
pldhivts <- tots("pldhiv")
numARTts <- tots("numART")
suppressedts <- tots("suppressed")
undiagnosedts <- tots("undiagnosed")
noARTts <- tots("noART")
unsuppressedts <- tots("unsuppressed")
diagnoses_excludets <- tots("diagnoses_exclude")
diagnoses_includets <- tots("diagnoses_include")
infectionsts <- tots("infections")
propdiagnosedts <- tots("propdiagnosed")
proptreatedts <- tots("proptreated")
propsuppressedts <- tots("propsuppressed")
propoverallts <- tots("propoverall")
ydfts <- tots("ydf")
cdrts <- tots("cdr")
iprts <- tots("ipr")
imrts <- tots("imr")

data <- cbind(infectedts, pldhivts, numARTts, suppressedts, undiagnosedts,
  noARTts, unsuppressedts, diagnoses_excludets, diagnoses_includets,
  infectionsts, propdiagnosedts, proptreatedts, propsuppressedts, propoverallts,
  ydfts, cdrts, iprts, imrts)
colnames(data) <- c("infected", "pldhiv", "numART", "suppressed",
  "undiagnosed","noART", "unsuppressed", "diagnoses_exclude",
  "diagnoses_include", "infections", "propdiagnosed", "proptreated",
  "propsuppressed", "propoverall", "ydf", "cdr", "ipr", "imr")
data <- window(data, start = c(startYear, 1), end = c(resultsYear, 1))

# Search for changepoints ------------------------------------------------------
# Using the changepoint package. 
autoplot(cpt.mean(infectedts))
autoplot(cpt.mean(pldhivts))
autoplot(cpt.mean(numARTts))
autoplot(cpt.mean(suppressedts))
autoplot(cpt.mean(undiagnosedts))
autoplot(cpt.mean(noARTts))
autoplot(cpt.mean(unsuppressedts))
autoplot(cpt.mean(diagnoses_excludets))
autoplot(cpt.mean(diagnoses_includets))
autoplot(cpt.mean(propdiagnosedts))
autoplot(cpt.mean(proptreatedts))
autoplot(cpt.mean(propsuppressedts))
autoplot(cpt.mean(propoverallts))
autoplot(cpt.mean(ydfts))
autoplot(cpt.mean(cdrts))
autoplot(cpt.mean(iprts))
autoplot(cpt.mean(imrts))

# Search for breakpoints -------------------------------------------------------
# The following code looks for breakpoints in each indicator using the 
# breakpoints() function in the strucchange package which uses linear 
# regression.  

BPindicator <- function(indicator, tsdata) {
  bpIndicator <- breakpoints(data[, indicator] ~ years, data = data, h = 3)
  print(summary(bpIndicator))
  
  autoplot(bpIndicator)
  plot(bpIndicator)
  plot(tsdata)
  lines(bpIndicator)
  try(lines(confint(bpIndicator))) # CIs might not be able to be calculated
  lines(fitted(bpIndicator, breaks = 1), col = 4)
  lines(fitted(bpIndicator, breaks = 2), col = 2)
  lines(fitted(bpIndicator, breaks = 3), col = 3)
  
  return(bpIndicator)
  
}

# Some of the indicators produce errors so I have commented them out and replaced
# with a NULL as this is just for exploration
bpInfected <- BPindicator("infected", infectedts)
bpPldhiv <- BPindicator("pldhiv", pldhivts)
bpNumART <- BPindicator("numART", numARTts) # get error with confidence intervals
bpSuppressed <- BPindicator("suppressed", suppressedts)
bpUndiagnosed <- NULL # BPindicator("undiagnosed", undiagnosedts)
bpNoART <- NULL # BPindicator("noART", noARTts)
bpUnsuppressed <- BPindicator("unsuppressed", unsuppressedts)
bpDiagnoses_exclude <- BPindicator("diagnoses_exclude", diagnoses_excludets)
bpDiagnoses_include <- BPindicator("diagnoses_include", diagnoses_includets)
bpInfections <- BPindicator("infections", infectionsts)
bpPropdiagnosed <- BPindicator("propdiagnosed", propdiagnosedts) # get error with confidence intervals
bpProptreated <- BPindicator("proptreated", proptreatedts) # get error with confidence intervals
bpPropsuppressed <- BPindicator("propsuppressed", propsuppressedts) # get error with confidence intervals
bpPropoverall <- NULL # BPindicator("propoverall", propoverallts) # get error with confidence intervals
bpYdf <- BPindicator("ydf", ydfts)
bpCdr <- BPindicator("cdr", cdrts)
bpIpr <- NULL # BPindicator("ipr", iprts)
bpImr <- BPindicator("imr", iprts)

```

```{r Breakpoints table}
# Create table of summary results ----------------------------------------
breakTable <- NULL

bpmodels <- list(
  bpInfected, 
  bpPldhiv, 
  bpNumART, 
  bpSuppressed, 
  bpUndiagnosed,
  bpNoART, 
  bpUnsuppressed, 
  bpDiagnoses_exclude, 
  bpDiagnoses_include, 
  bpInfections, 
  bpPropdiagnosed, 
  bpProptreated, 
  bpPropsuppressed, 
  bpPropoverall, 
  bpYdf, 
  bpCdr, 
  bpIpr, 
  bpImr
  )

modelNames <- colnames(data)
modelString <- c("Number infected",
  "Number diagnosed", 
  "Number on ART",
  "Number suppressed", 
  "Number undiagnosed",
  "Diagnosed but untreated",
  "On ART but unsuppressed",
  "Diagnoses excluding OS",
  "Diagnoses including OS",
  "Annual new infections",
  "Proportion diagnosed", 
  "Proportion diagnosed treated",
  "Proportion treated suppressed",
  "Proportion suppressed overall",
  "Yearly diagnosed fraction",
  "Case detection rate",
  "Incidence prevalence ratio", 
  "Incidence mortality ratio")

# NOTE: confidence interval calculation will produce lots of warnings if it
# can't be calculated (returns NA)

for (ii in 1:length(modelNames)) {
  
  tempbp <- bpmodels[[ii]]
  
  if (!is.null(tempbp)) {
    
    tempDf <- data.frame(step = character(5),
      indicator = character(5),
      break0 = integer(5),
      break1 = integer(5),
      break1ci = character(5),
      break2 = integer(5),
      break2ci = character(5),
      break3 = character(5),
      break3ci = character(5))
    
    tempDf$step <- rep(modelString[ii], 5)
    tempDf$indicator <- c("breakpoint1", "breakpoint2", "breakpoint3", "rss",
      "bic")
    
    tempDf$break0 <- c(NA, NA, NA, 
      breakpoints(tempbp, breaks = 1)$RSS,
      BIC(breakpoints(tempbp, breaks = 0)))
    
    tempDf$break1 <- c(years[breakpoints(tempbp, breaks = 1)$breakpoints],
      NA, NA,
      breakpoints(tempbp, breaks = 1)$RSS,
      BIC(breakpoints(tempbp, breaks = 1)))
    
    tempDf$break1ci <- c(paste0("(", 
      years[confint(tempbp, breaks = 1)$confint[1]],
      ", ",
      years[confint(tempbp, breaks = 1)$confint[3]],
      ")"), rep("NA", 4))
    
    tempDf$break2 <- c(years[breakpoints(tempbp, breaks = 2)$breakpoints],
      NA, 
      breakpoints(tempbp, breaks = 2)$RSS,
      BIC(breakpoints(tempbp, breaks = 2)))
    
    tempDf$break2ci <- c(paste0("(", 
      years[confint(tempbp, breaks = 2)$confint[1, 1]],
      ", ",
      years[confint(tempbp, breaks = 2)$confint[1, 3]],
      ")"), 
      paste0("(", 
        years[confint(tempbp, breaks = 2)$confint[2, 1]],
        ", ",
        years[confint(tempbp, breaks = 2)$confint[2, 3]],
        ")"),
      rep("NA", 3))
    
    tempDf$break3 <- c(years[breakpoints(tempbp, breaks = 3)$breakpoints],
      breakpoints(tempbp, breaks = 3)$RSS,
      BIC(breakpoints(tempbp, breaks = 3)))
    
    tempDf$break3ci <- c(paste0("(", 
      years[max(confint(tempbp, breaks = 3)$confint[1, 1], 1)], # Seem to get negative lower ranges sometimes
      ", ",
      years[confint(tempbp, breaks = 3)$confint[1, 3]],
      ")"), 
      paste0("(", 
        years[confint(tempbp, breaks = 3)$confint[2, 1]],
        ", ",
        years[confint(tempbp, breaks = 3)$confint[2, 3]],
        ")"),
      paste0("(", 
        years[confint(tempbp, breaks = 3)$confint[3, 1]],
        ", ",
        years[confint(tempbp, breaks = 3)$confint[3, 3]],
        ")"),
      rep("NA", 2))
    
    breakTable <- bind_rows(breakTable, tempDf)
    
  }
}

if (savePlots) {
  write_excel_csv(breakTable, file.path(figFolder, 
    paste0("HIVcascade_breakpoints_", 
      toString(startYear), "-", toString(resultsYear), ".csv")))
}

```

# Segmented trends

This section explores the trends in each step of the HIV cascade and 
notifications using a segmented negative-binomial/Poisson regression which 
allows the presence of a continuous change point. To perform this analysis 
requires an initial estimate for the location of the change point. We used the 
previous analyses and visual inspection to inform this estimate but also 
varied the initial estimate from 2007 to 2013. This produced no change in the 
fitted curve. 

```{r Segmented trends - Setup}
# This chuck is used to setup the analysis of the change in trends for each 
# cascade step, gap, and indicator. Some seem to have a change point. The 
# analysis preimary done by a complex function Segment(). 

LoadLibrary(segmented)

segmentStages <- c(names(trendModels), names(trendModelsProp))

allTrendModels <- c(trendModels, trendModelsProp)

# Function for finding minimum gaps between breakpoints ------------------------
# Assuming we ignore small gaps in the COVID period
minGapCOVID <- function(breakYears, start, end) {
  
  temp <- tibble(
    years = c(start, breakYears, end), 
    gaps = c(0, diff(c(start, breakYears, end))))
  
  minimum_gap <- min((temp |> filter(years > start, years < 2020))$gaps)
  
  return(minimum_gap)
  
} 

# Function for producing results -----------------------------------------------
# If there is an error in fitting one of the segmented models then the previous 
# model is used

Segment <- function(indicator, initialbp, ymax, yLabel, minimum = NA, 
  maximum = NA, offset = 1, 
  min_gap = 3, allow_end_gap = TRUE, yPercent = TRUE, save = FALSE) {
  
  tempData <- filter(trendData, stage == indicator)
  
  # Get original model
  pmodel <- allTrendModels[[indicator]]
  
  # Generate segmented models - if unable to find checkpoint then error is
  # found and model reverts to straight Poisson model (0 change points)
  segModel1 <- tryCatch(segmented(pmodel, seg.Z = ~year, 
    psi = list(year = initialbp[[1]])),
    error = function(err) {
      print(paste0(indicator, ": Error in segmented model 1"))
      segModel1 <- pmodel
    })
  
  segModel2 <- tryCatch(segmented(pmodel, seg.Z = ~year, 
    psi = list(year = initialbp[[2]])),
    error = function(err) {
      print(paste0(indicator, ": Error in segmented model 2"))
      segModel2 <- pmodel
    })  
  
  segModel3 <- tryCatch(segmented(pmodel, seg.Z = ~year, 
    psi = list(year = initialbp[[3]])),
    error = function(err) {
      print(paste0(indicator, ": Error in segmented model 3"))
      segModel3 <- pmodel
    })
  
  segModel4 <- tryCatch(segmented(pmodel, seg.Z = ~year, 
    psi = list(year = initialbp[[4]])),
    error = function(err) {
      print(paste0(indicator, ": Error in segmented model 4"))
      segModel4 <- pmodel
    })
  
  segModel5 <- tryCatch(segmented(pmodel, seg.Z = ~year, 
    psi = list(year = initialbp[[5]])),
    error = function(err) {
      print(paste0(indicator, ": Error in segmented model 5"))
      segModel5 <- pmodel
    })
  
  # Calculate and save breakpoints for each model
  modelBreakpoints <- tibble(
    model = c("pmodel", 
      "segModel1", 
      "segModel2", "segModel2", 
      "segModel3", "segModel3", "segModel3",
      "segModel4", "segModel4", "segModel4", "segModel4",
      "segModel5", "segModel5", "segModel5", "segModel5", "segModel5"),
    estimate = 0,
    lower = 0,
    upper = 0)
  
  if (class(segModel1)[1] == "segmented") {
    modelBreakpoints$estimate[2] <- unname(segModel1$psi[,"Est."])
    modelBreakpoints$lower[2] <- unname(confint.segmented(segModel1)[, "CI(95%).low"])
    modelBreakpoints$upper[2] <- unname(confint.segmented(segModel1)[, "CI(95%).up"])
  }
  if (class(segModel2)[1] == "segmented") {
    modelBreakpoints$estimate[3:4] <- unname(segModel2$psi[,"Est."])
    modelBreakpoints$lower[3:4] <- unname(confint.segmented(segModel2)[, "CI(95%).low"])
    modelBreakpoints$upper[3:4] <- unname(confint.segmented(segModel2)[, "CI(95%).up"])
  }
  if (class(segModel3)[1] == "segmented") {
    modelBreakpoints$estimate[5:7] <- unname(segModel3$psi[,"Est."])
    modelBreakpoints$lower[5:7] <- unname(confint.segmented(segModel3)[, "CI(95%).low"])
    modelBreakpoints$upper[5:7] <- unname(confint.segmented(segModel3)[, "CI(95%).up"])  
  }
  if (class(segModel4)[1] == "segmented") {
    modelBreakpoints$estimate[8:11] <- unname(segModel4$psi[,"Est."])
    modelBreakpoints$lower[8:11] <- unname(confint.segmented(segModel4)[, "CI(95%).low"])
    modelBreakpoints$upper[8:11] <- unname(confint.segmented(segModel4)[, "CI(95%).up"])
  }
  if (class(segModel5)[1] == "segmented") {
    modelBreakpoints$estimate[12:16] <- unname(segModel5$psi[,"Est."])
    modelBreakpoints$lower[12:16] <- unname(confint.segmented(segModel5)[, "CI(95%).low"])
    modelBreakpoints$upper[12:16] <- unname(confint.segmented(segModel5)[, "CI(95%).up"])
  }
  
  # Calculate minimum gap between breakpoints and ends
  
  if (allow_end_gap) {
    # Allow gaps at end to be less than min_gap. Means can potentially have a 
    # multiple change point after 2020 to account for potential changes during
    # acute phase of COVID and rebound. 

    modelBreakpointGaps <- tibble(model = c("pmodel", "segModel1", 
      "segModel2", "segModel3", "segModel4", "segModel5"),
      minimum_gap = c(Inf, # No breakpoints
        minGapCOVID(unname(segModel1$psi[, "Est."]), startYear, resultsYear), 
        minGapCOVID(unname(segModel2$psi[, "Est."]), startYear, resultsYear), 
        minGapCOVID(unname(segModel3$psi[, "Est."]), startYear, resultsYear), 
        minGapCOVID(unname(segModel4$psi[, "Est."]), startYear, resultsYear),
        minGapCOVID(unname(segModel5$psi[, "Est."]), startYear, resultsYear)))

  } else {
    modelBreakpointGaps <- tibble(model = c("pmodel", "segModel1", 
      "segModel2", "segModel3", "segModel4", "segModel5"),
      minimum_gap = c(Inf, # No breakpoints 
        min(diff(c(startYear, unname(segModel1$psi[, "Est."]), resultsYear))),
        min(diff(c(startYear, unname(segModel2$psi[, "Est."]), resultsYear))),
        min(diff(c(startYear, unname(segModel3$psi[, "Est."]), resultsYear))),
        min(diff(c(startYear, unname(segModel4$psi[, "Est."]), resultsYear))),
        min(diff(c(startYear, unname(segModel5$psi[, "Est."]), resultsYear)))))
  } 
  
  gapStr <- round(modelBreakpointGaps$minimum_gap, digits = 1)
  
  # Calculate and save slopes for each model
  modelSlopes <- tibble(
    model = c("pmodel", 
      "segModel1", "segModel1",
      "segModel2", "segModel2", "segModel2",
      "segModel3", "segModel3", "segModel3", "segModel3",
      "segModel4", "segModel4", "segModel4", "segModel4", "segModel4",
      "segModel5", "segModel5", "segModel5", "segModel5", "segModel5", "segModel5"),
    estimate = 0,
    lower = 0,
    upper = 0)
  
  modelSlopes$estimate[1] <- exp(unname(coef(pmodel)[2]))
  modelSlopes$lower[1] <- exp(confint(pmodel, "year", type = "Wald"))[1]
  modelSlopes$upper[1] <- exp(confint(pmodel, "year", type = "Wald"))[2]
  
  if (class(segModel1)[1] == "segmented") {
    modelSlopes$estimate[2:3] <- exp(slope(segModel1)$year[,1])
    modelSlopes$lower[2:3] <- exp(slope(segModel1)$year[,"CI(95%).l"])
    modelSlopes$upper[2:3] <- exp(slope(segModel1)$year[,"CI(95%).u"])
  }
  if (class(segModel2)[1] == "segmented") {
    modelSlopes$estimate[4:6] <- exp(slope(segModel2)$year[,1])
    modelSlopes$lower[4:6] <- exp(slope(segModel2)$year[,"CI(95%).l"])
    modelSlopes$upper[4:6] <- exp(slope(segModel2)$year[,"CI(95%).u"])
  }
  if (class(segModel3)[1] == "segmented") {
    modelSlopes$estimate[7:10] <- exp(slope(segModel3)$year[,1])
    modelSlopes$lower[7:10] <- exp(slope(segModel3)$year[,"CI(95%).l"])
    modelSlopes$upper[7:10] <- exp(slope(segModel3)$year[,"CI(95%).u"])
  }
  if (class(segModel4)[1] == "segmented") {
    modelSlopes$estimate[11:15] <- exp(slope(segModel4)$year[,1])
    modelSlopes$lower[11:15] <- exp(slope(segModel4)$year[,"CI(95%).l"])
    modelSlopes$upper[11:15] <- exp(slope(segModel4)$year[,"CI(95%).u"])
  }
  if (class(segModel5)[1] == "segmented") {
    modelSlopes$estimate[16:21] <- exp(slope(segModel5)$year[,1])
    modelSlopes$lower[16:21] <- exp(slope(segModel5)$year[,"CI(95%).l"])
    modelSlopes$upper[16:21] <- exp(slope(segModel5)$year[,"CI(95%).u"])
  }
  
  # Calculate and save AIC and BIC values
  aicValues <- c(AIC(pmodel), AIC(segModel1), AIC(segModel2), AIC(segModel3),
    AIC(segModel4), AIC(segModel5))
  bicValues <- c(BIC(pmodel), BIC(segModel1), BIC(segModel2), BIC(segModel3),
    BIC(segModel4), BIC(segModel5))
  bicStr <- round(bicValues, digits = 1)
  
  modelData <- data.frame(year = tempData$year, 
    overall = fitted(pmodel)/offset,
    segvalue1 = fitted(segModel1)/offset, 
    segvalue2 = fitted(segModel2)/offset,
    segvalue3 = fitted(segModel3)/offset,
    segvalue4 = fitted(segModel4)/offset,
    segvalue5 = fitted(segModel5)/offset)
  
  # If indicator is a percentage make sure predicted proportion doesn't go
  # over 1
  if (yPercent) {
    modelData <- modelData |>
      mutate(
        overall = ifelse(overall > 1, 1, overall), 
        segvalue1 = ifelse(segvalue1 > 1, 1, segvalue1),
        segvalue2 = ifelse(segvalue2 > 1, 1, segvalue2),
        segvalue3 = ifelse(segvalue3 > 1, 1, segvalue3),
        segvalue4 = ifelse(segvalue4 > 1, 1, segvalue4),
        segvalue5 = ifelse(segvalue5 > 1, 1, segvalue5)
      )
  }
  
  # Create plot
  segPlotAll <- ggplot(data = tempData, 
    aes(x = year, y = value)) + 
    geom_line(aes(color = "estimates")) + 
    geom_point(color = asrcols[2]) +
    geom_line(data = modelData, aes(y = overall,
      colour = "overall")) +
    geom_line(data = modelData, aes(y = segvalue1, 
      colour = "segment1")) + 
    geom_line(data = modelData, aes(y = segvalue2, 
      colour = "segment2")) + 
    geom_line(data = modelData, aes(y = segvalue3,
      colour = "segment3")) +
    geom_line(data = modelData, aes(y = segvalue4,
      colour = "segment4")) +
    geom_line(data = modelData, aes(y = segvalue5,
      colour = "segment5")) +
    scale_x_continuous(breaks = seq(startYear, resultsYear),
      labels =  rev(EveryNth(seq(resultsYear, startYear), xTicks, inverse = TRUE)),
      limits = c(startYear, resultsYear)) +
    scale_y_continuous(labels = comma, limits = c(0, ymax)) + 
    scale_colour_manual("", values = c(asrcols[2], "black", "blue", 
      "darkgreen", "purple", "orange2", "red4"),
      limits = c("estimates", "overall", "segment1", "segment2", "segment3",
        "segment4", "segment5"),
      labels = c("Estimates", "Overall", "One change point", 
        "Two change points", "Three change points", "Four change points",
        "Five change points")) +
    ylab(yLabel) + xlab("Year") +  
    PlotOptions() + theme(legend.position = "right") + 
    geom_text(x = 2012, y = 0.2 * ymax, 
      label = sprintf("BIC values\nOverall %s; One CP %s; Two CPs %s; 
        Three CPs %s; Four CPs %s; Five CPs %s.", 
        bicStr[1], bicStr[2], bicStr[3], bicStr[4], bicStr[5], bicStr[6]), size = 3) 
  
  if (allow_end_gap) {
    segPlotAll <- segPlotAll +
      geom_text(x = 2012, y = 0.05 * ymax, 
        label = sprintf("Minimum gaps (excluding COVID period)\nOverall %s; One CP %s; 
          Two CPs %s; Three CPs %s; Four CPs %s, Five CPs %s.", 
          gapStr[1], gapStr[2], gapStr[3], gapStr[4], gapStr[5], gapStr[6]), size = 3)
  } else {
    segPlotAll <- segPlotAll +
      geom_text(x = 2012, y = 0.05 * ymax, 
        label = sprintf("Minimum gaps\nOverall %s; One CP %s; Two CPs %s; 
          Three CPs %s; Four CPs %s, Five CPs %s.", 
          gapStr[1], gapStr[2], gapStr[3], gapStr[4], gapStr[5], gapStr[6]), size = 3)
  } 
  # Select the model with the lowest BIC but with minimum gap > min_gap
  # and plot
  segModels <- list(pmodel, segModel1, segModel2, segModel3, segModel4, segModel5)
  
  modelBreakpointGaps$bic <- bicValues
  modelBreakpointGaps$number <- 1:6
  
  eligible <- modelBreakpointGaps %>%
    filter(minimum_gap >= min_gap)
  
  bestIndex <- eligible[which.min(eligible$bic),]$number
  
  bestModel <- segModels[[bestIndex]]
  bestModelData <- dplyr::select(modelData, c(1, bestIndex + 1)) 
  colnames(bestModelData)[2] <- "value"
  
  segPlotBest <- ggplot(data = tempData, 
    aes(x = year, y = value)) + 
    geom_line(aes(color = "estimates")) + 
    geom_point(color = asrcols[2]) +
    geom_line(data = bestModelData, aes(y = value,
      colour = "best")) + 
    geom_vline(xintercept = unname(bestModel$psi[, "Est."]),
      linetype = "dashed") +
    scale_x_continuous(breaks = seq(startYear, resultsYear),
      labels =  rev(EveryNth(seq(resultsYear, startYear), xTicks, inverse = TRUE)),
      limits = c(startYear, resultsYear)) +
    scale_y_continuous(labels = comma, limits = c(0, ymax)) + 
    scale_colour_manual("", values = c(asrcols[2], "black"), 
      limits = c("estimates", "best"), 
      labels = c("Estimates", "Fitted trends")) + # adjust alignment
    ylab(yLabel) + xlab("Year") +  
    PlotOptions() 
  
  if (yPercent) {
    segPlotAll <- segPlotAll + 
      scale_y_continuous(labels = percent, limits = c(0, ymax))
    segPlotBest <- segPlotBest +
      scale_y_continuous(labels = percent, limits = c(0, ymax))
  }
  
  if (!is.na(minimum[1])) {
    segPlotBest <- segPlotBest +
      geom_ribbon(aes(ymin = minimum, ymax = maximum), fill = asrcols[2],
        alpha = 0.4)
  }
  
  if (save) {
    # Save the current plot as a combined plot
    legend1 <- get_legend(segPlotAll)
    legend2 <- get_legend(segPlotBest + theme(legend.position = "right"))
    
    segPlotCombine <- ggdraw() +
      draw_plot(segPlotAll + theme(legend.position="none"), 
        0, 0.5, 0.8, 0.5) +
      draw_plot(segPlotBest + theme(legend.position="none"),
        0, 0, 0.8, 0.5) +
      draw_plot(legend1, 0.8, 0.5, 0.2, 0.5) + 
      draw_plot(legend2, 0.8, 0, 0.2, 0.5) + 
      draw_plot_label(c("A", "B"), c(0, 0), c(1, 0.5), size = 12)
    
    ggsave(file.path(figFolder, paste0("HIVcascade-Trends-", indicator,
      "-Segment-All_",
      toString(startYear), "-",
      toString(resultsYear),
      saveFormat)),
      plot = segPlotCombine, width = 22, height = 24, units = "cm")
  }
  
  return(list(models = segModels,
    fitted = modelData, breakpoints = modelBreakpoints, 
    gaps = modelBreakpointGaps, slopes = modelSlopes, 
    aic = aicValues, bic = bicValues, bestIndex = bestIndex, 
    plotall = segPlotAll, plotBest = segPlotBest))
}

```

```{r Segmented trends}
# We try to find a change point for each stage using the segmented package and 
# with the negative-binomial/Poisson models. Note if one change point is not 
# found using the segmented package then the negative-binomial/Poisson model is 
# plotted instead (suggests it is a better model). 

# Set-up each indicator specifications -----------------------------------------

# Initial break point estimates - use trial and error based on breakpoints() 
# results and visual inspection and to test for sensitivity by varying.
initialbp <- list(2014, c(2010, 2016), c(2008, 2013, 2018),
  c(2007, 2012, 2016, 2019), c(2007, 2010, 2013, 2016, 2019))

# Y axis range for each model
ymax <- c("infected" = 40000,
  "pldhiv" = 40000,
  "numART" = 40000, 
  "suppressed" = 40000,
  "undiagnosed" = 4000, 
  "noART" = 7000, 
  "unsuppressed" = 4500,
  "diagnoses_exclude" = 1500,
  "diagnoses_include" = 1500,
  "infections" = 1500, 
  "propdiagnosed" = 1.0, 
  "proptreated" = 1.0,       
  "propsuppressed" = 1.0,
  "propoverall" = 1.0,
  "ydf" = 0.5,  
  "cdr"=  3.5,
  "ipr" = 0.1,
  "imr" = 20)

offsets <- list("infected" = 1,
  "pldhiv" = 1,
  "numART" = 1, 
  "suppressed" = 1,
  "undiagnosed" = 1, 
  "noART" = 1, 
  "unsuppressed" = 1,
  "diagnoses_exclude" = 1,
  "diagnoses_include" = 1,
  "infections" = 1, 
  "propdiagnosed" = expTrendData$infected,
  "proptreated" = expTrendData$pldhiv,       
  "propsuppressed" = expTrendData$numART,
  "propoverall" = expTrendData$infected,
  "ydf" = expTrendData$ydfoffest,
  "cdr"=  expTrendData$infections,
  "ipr" = expTrendData$iproffset,
  "imr" = expTrendData$imroffset)

yPercent <- c("infected" = FALSE,
  "pldhiv" = FALSE,
  "numART" = FALSE, 
  "suppressed" = FALSE,
  "undiagnosed" = FALSE, 
  "noART" = FALSE, 
  "unsuppressed" = FALSE,
  "diagnoses_exclude" = FALSE,
  "diagnoses_include" = FALSE,
  "infections" = FALSE, 
  "propdiagnosed" = TRUE, 
  "proptreated" = TRUE,       
  "propsuppressed" = TRUE,
  "propoverall" = TRUE,
  "ydf" = FALSE,  
  "cdr"=  FALSE,
  "ipr" = TRUE,
  "imr" = FALSE)

# Generate results -------------------------------------------------------------

steps <- names(ymax)
segResults <- list()

for (ii in steps) {
  print(ii)  
  segResults[[ii]] <- Segment(ii, initialbp, ymax[ii], 
    minimum =  filter(trendData, stage == ii)$lower,
    maximum = filter(trendData, stage == ii)$upper, 
    yLabels[ii], save = savePlots, offset = offsets[[ii]], 
    yPercent = yPercent[ii], min_gap = 4, allow_end_gap = TRUE)
}

save(segResults, file = file.path(figFolder, "CascadeSegmentedModels.Rda"))

```

```{r 95-95-95 and 2030 predictions}
# This chunk is used to estimate indicator values up to 2030. 

# Cascade steps
infectedPredict <- exp(predict(segResults$infected$models[[segResults$infected$bestIndex]], 
  newdata = data.frame(year = (resultsYear + 1):2030)))
diagnosedPredict <- exp(predict(segResults$pldhiv$models[[segResults$pldhiv$bestIndex]], 
  newdata = data.frame(year = (resultsYear + 1):2030)))
numARTPredict <- exp(predict(segResults$numART$models[[segResults$numART$bestIndex]], 
  newdata = data.frame(year = (resultsYear + 1):2030)))
suppressedPredict <- exp(predict(segResults$suppressed$models[[segResults$suppressed$bestIndex]], 
  newdata = data.frame(year = (resultsYear + 1):2030)))

# Predict values for cascade percentages using models with offsets
propdiagnosed95 <- exp(predict(segResults$propdiagnosed$models[[segResults$propdiagnosed$bestIndex]],
  newdata = data.frame(year = (resultsYear + 1):2030, infected = infectedPredict)))/infectedPredict
proptreated95 <- exp(predict(segResults$proptreated$models[[segResults$proptreated$bestIndex]],
  newdata = data.frame(year = (resultsYear + 1):2030, pldhiv = diagnosedPredict)))/diagnosedPredict
propsuppressed95 <- exp(predict(segResults$propsuppressed$models[[segResults$propsuppressed$bestIndex]],
  newdata = data.frame(year = (resultsYear + 1):2030, numART = numARTPredict)))/numARTPredict

# Direct calculations
diagnosedPredict/infectedPredict
numARTPredict/diagnosedPredict
suppressedPredict/numARTPredict

numARTPredict/infectedPredict # For Spectrum

# New infections predictions
infectionsPredict <-exp(predict(segResults$infections$models[[segResults$infections$bestIndex]], 
  newdata = data.frame(year = (resultsYear + 1):2030)))

infections2030 <- trendData |> 
  filter(stage == "infections") |>
  dplyr::select(year, value) |>
  bind_rows(
    tibble(
      year = (resultsYear + 1):2030, 
      value = infectionsPredict
      )
    ) %>%
  dplyr::mutate(relative = value/(filter(.,year == 2010)$value))

infections2030 |> tail(20)

```

```{r Produce combined plots} 

RmLegened <- function(plot) {
  return(plot + theme(legend.position = "none"))
}

# HIV Cascade in 2020 ----------------------------------------------------------
latestCascade <- filter(hivCascadeAll,
  population == cascadePop,
  year == resultsYear)

# Adjust diagnosed and retained estimates so the lower bound is not less than 
# the lower bound for ART
latestCascade$lower[latestCascade$stage == "pldhiv"] <-
  ifelse(latestCascade$lower[latestCascade$stage == "pldhiv"] < 
      latestCascade$lower[latestCascade$stage == "numART"], 
    latestCascade$lower[latestCascade$stage == "numART"], 
    latestCascade$lower[latestCascade$stage == "pldhiv"])

latestCascade$lower[latestCascade$stage == "retained"] <-
  ifelse(latestCascade$lower[latestCascade$stage == "retained"] < 
      latestCascade$lower[latestCascade$stage == "numART"], 
    latestCascade$lower[latestCascade$stage == "numART"], 
    latestCascade$lower[latestCascade$stage == "retained"])

plotCascadeAll <- PlotCascade(latestCascade, retained = TRUE, ymax = 35000,
  plotcolours = asrcols,  
  steplabels = c("Living\nwith HIV", "Diagnosed", "Retained\nin care",
    "Receiving\ntreatment", "Suppressed\n(VL < 200)"), 
  percentages = TRUE,
  targetlines = "95", targetlabels = FALSE) + 
  scale_y_continuous(breaks = seq(0, 40000, by = 10000),
    labels =  comma,
    limits = c(0, 35000))

# Stacked HIV cascade ----------------------------------------------------------
plotLabels <- c("Undiagnosed", 
  "Diagnosed untreated", 
  "On ART:  VL > 200 last test", 
  "On ART: VL < 200 last test")

plotCols <- asrcols[c(1, 2, 4, 5)]

# Set up data for plotting
stackResults <- hivCascadeAll %>%
  filter(stage != "retained", population == cascadePop,
    year >= startYear) %>%
  dplyr::select(year, stage, value) %>%
  spread(stage, value) %>%
  mutate(undiagnosed = infected - pldhiv,
    diagnosed = pldhiv - numART,
    unsuppressed = numART - suppressed) %>%
  dplyr::select(year, undiagnosed, diagnosed, unsuppressed, suppressed) %>%
  gather("stage", "value", 2:5) %>%
  mutate(stage = factor(stage, levels = c("undiagnosed", "diagnosed", 
    "unsuppressed", "suppressed"))) %>%
  arrange(stage)

# Create individual plots
stackPlotBase <- ggplot(data = stackResults, aes(x = year, y = value, 
  fill = stage)) + xlab("Year") +
  scale_fill_manual(values = plotCols, name = "", labels = plotLabels, 
    guide = guide_legend(nrow = 2)) +  
  scale_x_continuous(breaks = seq(startYear, resultsYear),
    labels =  rev(EveryNth(seq(resultsYear, startYear), xTicks, inverse = TRUE)),
    limits = c(startYear, resultsYear)) +
  PlotOptions() + 
  theme(legend.text = element_text(size = 8))

stackPlotNum <- stackPlotBase + geom_area(stat="identity") + 
  ylab("Number of PLHIV") + scale_y_continuous(labels = comma)
stackPlotProp <- stackPlotBase + geom_area(stat="identity", 
  position= "fill") + ylab("Percentage of PLHIV") +
  scale_y_continuous(labels = percent)

# Create a combined plot
legend <- get_legend(stackPlotNum)
stackPlotNum2 <- stackPlotNum + theme(legend.position="none")
stackPlotProp2 <- stackPlotProp + theme(legend.position="none")

plotStacked <- ggdraw() + 
  draw_plot(legend, 0, 0.8, 1, 0.2) +
  draw_plot(stackPlotNum2, 0, 0, 0.5, 0.8) +
  draw_plot(stackPlotProp2, 0.5, 0, 0.5, 0.8)

cascadeFullPlot <- ggdraw() +
  draw_plot(diagsPlot, 0, 0.5, 0.5, 0.5) +
  draw_plot(plotCascadeAll, 0.5, 0.5, 0.5, 0.5) +
  draw_plot(plotStacked, 0, 0, 1, 0.5) +
  draw_plot_label(c("A", "B", "C"), 
    c(0, 0.5, 0), c(1, 1, 0.5), 
    size = 12)

# Figure captions
captions[["cascadeFull"]] <- "HIV notifications in Australia and Australia's HIV cascade to the end of 2022. A) Annual notifications data. B) HIV cascade at end of 2022 including estimates for retained in care (note lower range of Diagnosed and Retained in care adjusted to equal lower range of number Receiving treatment). Horizontal lines show the UNAIDS 90-90-90 targets. C) Estimate numbers and percentages of people living with HIV in each step of the HIV cascade over 2004-2022.  "

# Cascade trends ---------------------------------------------------------------
legend <- get_legend(segResults[["infected"]]$plotBest)

cascadeTrendPlot <- ggdraw() + 
  draw_plot(legend, 0, 0.95, 1, 0.05) + 
  draw_plot(
    plot_grid(RmLegened(segResults[["infected"]]$plotBest),
      RmLegened(segResults[["pldhiv"]]$plotBest),
      RmLegened(segResults[["numART"]]$plotBest),
      RmLegened(segResults[["suppressed"]]$plotBest),
      ncol = 2, nrow = 2, align = "v",
      labels = c("A", "B", "C", "D", "E", "F")), 0, 0, 1, 0.95)

captions[["stepTrends"]] <- "Estimates and trends for each HIV cascade step over 2004-2022. Red lines and shading show the estimated values and range from the HIV cascade calculations. Black lines show the piecewise negative binomial model predictions. Vertical dashed lines show the location of detected change points. "

# Cascade gaps -----------------------------------------------------------------
legend <- get_legend(segResults[["undiagnosed"]]$plotBest)

gapsFullPlot <- ggdraw() +
  draw_plot(legend, 0, 0.95, 1, 0.05) + 
  draw_plot(
    plot_grid(
      RmLegened(segResults[["undiagnosed"]]$plotBest),
      RmLegened(segResults[["propdiagnosed"]]$plotBest),
      RmLegened(segResults[["noART"]]$plotBest),
      RmLegened(segResults[["proptreated"]]$plotBest),
      RmLegened(segResults[["unsuppressed"]]$plotBest),
      RmLegened(segResults[["propsuppressed"]]$plotBest),
      ncol = 2, nrow = 3, align = "v",
      labels = c("A", "B", "C", "D", "E", "F")), 0, 0, 1, 0.95)

captions[["cascadeGaps"]] <- "Trends in the estimated gaps of the HIV cascade over 2004-2022. Red lines show the estimated values from the HIV cascade calculations. Black lines show the best fitting piecewise negative binomial model predictions. Vertical dashed lines show the location of detected change points."

# Remaining cascade indicators --------------------------------------------------- 
legend <- get_legend(segResults[["diagnoses_include"]]$plotBest)

indicatorsFullPlot <-  ggdraw() +
  draw_plot(legend, 0, 0.95, 1, 0.05) +
  draw_plot(
    plot_grid(RmLegened(segResults[["diagnoses_include"]]$plotBest),
      RmLegened(segResults[["diagnoses_exclude"]]$plotBest),
      RmLegened(segResults[["infections"]]$plotBest),
      RmLegened(segResults[["ydf"]]$plotBest),
      RmLegened(segResults[["cdr"]]$plotBest),
      RmLegened(segResults[["ipr"]]$plotBest),
      RmLegened(segResults[["imr"]]$plotBest),
      ncol = 2, nrow = 4, align = "v",
      labels = c("A", "B", "C", "D", "E", "F", "G")), 0, 0, 1, 0.95)

captions[["cascadeIndicators"]] <- "Trends in cascade related indicators over 2004-2022. Red lines and shading show the estimated values and range from the HIV cascade calculations. Black lines show the best fitting piecewise negative binomial model predictions. Vertical dashed lines show the location of detected change points."

# Save combined plots ----------------------------------------------------------
if (savePlots) {
  ggsave(file.path(figFolder,
    paste("HIVcascade_Full_Plot_",
      toString(startYear), "-",
      toString(resultsYear),
      saveFormat, sep = "")),
    plot = cascadeFullPlot, width = 22, height = 16, units = "cm")
  
  ggsave(file.path(figFolder,
    paste("HIVtrends_Full_Plot_",
      toString(startYear), "-",
      toString(resultsYear),
      saveFormat, sep = "")),
    plot = cascadeTrendPlot, width = 22, height = 16, units = "cm")
  
  ggsave(file.path(figFolder,
    paste("HIVgaps_Full_Plot_",
      toString(startYear), "-",
      toString(resultsYear),
      saveFormat, sep = "")),
    plot = gapsFullPlot, width = 22, height = 25, units = "cm")
  
  ggsave(file.path(figFolder,
    paste("HIVindicators_Full_Plot_",
      toString(startYear), "-",
      toString(resultsYear),
      saveFormat, sep = "")),
    plot = indicatorsFullPlot, width = 22, height = 35, units = "cm")
  
}
```

```{r Combined table}
# Create table of overall results ----------------------------------------
resultsTable <- tibble(indicator = character(),
  breakpoints = double(),
  breakpoints_low = double(),
  breakpoints_up = double(),
  rate_ratio = double(),
  rate_ratio_low = double(),
  rate_ratio_up = double(),
  valueStart = double(),
  valueStart_low = double(),
  valueStart_up = double(),
  valueEnd = double(),
  valueEnd_low = double(),
  valueEnd_up = double())

for (ii in steps) {
  # Extract breakpoints and slopes for best model
  best <- segResults[[ii]]$bestIndex
  model <- segResults[[ii]]$models[[best]]
  
  
  if (class(model)[1] == "segmented") {
    bps <- confint(model)
    slopes <- slope(model)$year[, c(1, 4:5)]  
    
    nrows <- nrow(slopes)
    
    tempTable <- tibble(indicator = rep(unname(indicatorNames[ii]), nrows),
      breakpoints = unname(c(bps[, 1], 0)),
      breakpoints_low = unname(c(bps[, 2], 0)),
      breakpoints_up = unname(c(bps[, 3], 0)),
      rate_ratio = exp(unname(slopes[, 1])), 
      rate_ratio_low =  exp(unname(slopes[, 2])),
      rate_ratio_up =  exp(unname(slopes[, 3]))) 
  } else {
    nrows <- 1
    
    tempTable <- tibble(indicator = unname(indicatorNames[ii]),
      breakpoints = 0,
      breakpoints_low = 0,
      breakpoints_up = 0,
      rate_ratio = exp(unname(coef(model)[2])), 
      rate_ratio_low = exp(unname(confint(model)[2, "2.5 %"])),
      rate_ratio_up = exp(unname(confint(model)[2, "97.5 %"]))) 
  } 
  
  # Add data
  tempData <- filter(trendData, stage == ii)
  nyears <- nrow(tempData)
  
  tempTable$valueStart <- c(tempData$value[1], rep(0, nrows-1))
  tempTable$valueStart_low <- c(tempData$lower[1], rep(0, nrows-1))
  tempTable$valueStart_up <- c(tempData$upper[1], rep(0, nrows-1))
  
  tempTable$valueEnd <- c(tempData$value[nyears], rep(0, nrows-1))
  tempTable$valueEnd_low <- c(tempData$lower[nyears], rep(0, nrows-1))
  tempTable$valueEnd_up <- c(tempData$upper[nyears], rep(0, nrows-1))
  
  #Merge 
  
  resultsTable <- bind_rows(resultsTable, tempTable) 
  
}

# Replace missing lower and upper bounds with zero
resultsTable[is.na(resultsTable)] <- 0

# Create a formatted results table ---------------------------------------------

captions[["resultsTable"]] <- "Summary results"

formatTable <- tibble(indicator = resultsTable$indicator)
formatTable$valueStart <- FormatData(resultsTable$valueStart,
  resultsTable$valueStart_low, resultsTable$valueStart_up, places = -1,
  decimal = decimalMark)
formatTable$valueEnd <- FormatData(resultsTable$valueEnd,
  resultsTable$valueEnd_low, resultsTable$valueEnd_up, places = -1,
  decimal = decimalMark)

# Need to overwrite percentage and proportion estimates so they are not rounded
# and have the right number of decimal places

propIndices <- which(formatTable$indicator %in% c("Yearly diagnosed fraction", 
  "Case detection rate", "Incidence mortality ratio"))

percentIndices <- which(formatTable$indicator %in% c("Percentage diagnosed" , 
  "Percentage diagnosed treated" , "Percentage treated suppressed", 
  "Percentage suppressed overall", "Incidence prevalence ratio"))

formatTable$valueStart[propIndices]  <- FormatData(resultsTable$valueStart[propIndices],
  resultsTable$valueStart_low[propIndices], resultsTable$valueStart_up[propIndices], 
  places = 2, decimal = decimalMark)
formatTable$valueEnd[propIndices] <- FormatData(resultsTable$valueEnd[propIndices],
  resultsTable$valueEnd_low[propIndices], resultsTable$valueEnd_up[propIndices], 
  places = 2, decimal = decimalMark)

formatTable$valueStart[percentIndices]  <- FormatData(
  100*resultsTable$valueStart[percentIndices],
  100*resultsTable$valueStart_low[percentIndices],
  100*resultsTable$valueStart_up[percentIndices], 
  places = 1, decimal = decimalMark, suffix = "%")
formatTable$valueEnd[percentIndices] <- FormatData(
  100*resultsTable$valueEnd[percentIndices],
  100*resultsTable$valueEnd_low[percentIndices],
  100*resultsTable$valueEnd_up[percentIndices], 
  places = 1, decimal = decimalMark, suffix = "%")

formatTable$breakpoints <- FormatData(resultsTable$breakpoints,
  resultsTable$breakpoints_low, resultsTable$breakpoints_up, 
  thousands = "no", places = 1,
  decimal = decimalMark)
formatTable$rate_ratios <- FormatData(resultsTable$rate_ratio,
  resultsTable$rate_ratio_low, resultsTable$rate_ratio_up, places = 3,
  decimal = decimalMark)

if (savePlots) {
  write_excel_csv(resultsTable, file.path(figFolder, 
    paste0("HIVcascade_Summary_Table_", 
      startYear, "-", resultsYear, ".csv")))
  
  write_excel_csv(formatTable, file.path(figFolder, 
    paste0("HIVcascade_Formated_Table_", 
      startYear, "-", resultsYear, ".csv")))
}

```

```{r Save final figures and tables}
# This chunk saves the final figures, tables and results to produce 
# a Rmarkdown script of results

save(cascadeFullPlot, cascadeTrendPlot, gapsFullPlot, indicatorsFullPlot, 
  resultsTable, formatTable, captions,
  file = file.path(figFolder, "CascadeFinalResults.Rda"))

```

# Testing code ==============================================================

The following sections were primarily used for testing and deciding on the best
approach to evaluating the trends. They are mostly superfluous now but have been
kept in this script for storage and safe keeping in case the code becomes useful
at a later date

# Chow and interaction tests of detected change points (DEPRECATED)

This section applies some statistical tests for the segmented model to test 
for the robustness of any change points and produces a number of summary 
results. 

The main test is a Chow test (https://en.wikipedia.org/wiki/Chow_test) we 
calculate this from first principles based on the code from  
https://thetarzan.wordpress.com/2011/06/16/the-chow-test-in-r-a-case-study-of-yellowstones-old-faithful-geyser/

We also looked at the difference on the slopes before and after the change 
point using an interaction model and performed a Wald test on the slopes 
returning the p-value. This test only tests if the difference between the 
slope parameters is different to zero as decribed here:  
https://andrewpwheeler.wordpress.com/2016/10/19/testing-the-equality-of-two-regression-coefficients/

*NOTE:* While the script below runs the estimates seem a bit funny for some
indicators! I haven't explored the reasons for this because I have decided to 
use the BIC to obtain best fitting change point model.

```{r Chow and interaction tests, eval = runtests}
if (runtests) {
  
  # This chunk runs chow and interaction tests for each intermediate
  # cascade step. 
  LoadLibrary(aod)
  
  # Functions for testing segemented models ---------------------------------
  pchow <- function(overalldata, model, premodel, postmodel) {
    # Computes the Chow test statistic (F-test) and pvalue
    
    # Calculate sum of squared residuals for each regression
    SSR <- NULL
    SSR$all <- model$residuals^2
    SSR$pre <- premodel$residuals^2
    SSR$post <- postmodel$residuals^2
    
    # K is the number of regressors in our model
    k <-  model$rank
    
    # Computing the Chow test statistic (F-test):
    numerator = (sum(SSR$all) - (sum(SSR$pre) + sum(SSR$post))) / k
    denominator = (sum(SSR$pre) + sum(SSR$post)) / 
      (nrow(overalldata) - 2 * k)
    chow = numerator / denominator
    chow
    
    # Calculate P-value using F test
    pchow <- 1 - pf(chow, k, (nrow(overalldata) - 2 * k))
    return(pchow)
  } 
  
  pslopes <- function(overalldata, cutpoint) {
    # This function produces an interaction model and performs a Wald test 
    # on the slopes returning the p-value
    
    interactData <- overalldata %>%
      mutate(ypre = ifelse(year <= cutpoint, year, 0),
        ypost = ifelse(year > cutpoint, year, 0),
        ipre = ifelse(year <= cutpoint, 1, 0),
        ipost = ifelse(year > cutpoint, 1, 0))
    
    # Model 
    intModel <- glm(round(value) ~ ypre + ypost + ipre, #+ ipost gives NA
      data = interactData, 
      family = "poisson")
    
    
    # Calculate the Wald ststatistic and p-value
    theta <- coef(intModel)[2:3] # KEEP AS COEFFICIENTS
    v <- vcov(intModel)[2:3, 2:3]
    diff <- theta[1] - theta[2] # Difference in parameters
    varAB <- sqrt(v[1,1] + v[2,2] - 2 * v[2,1])
    wstat <- diff/varAB # Stat sig if abs > 2 (2 sided p-value treating 
    # wstat as z-score in normal distribution
    pwstat <- 2*pnorm(-abs(wstat)) # test stat from normal
    return(list(model = intModel, wstat = wstat, pwstat = pwstat))
  }
  
  selectBreakpoint <- function(indicator, nbreakpoints, breakpoint_number, 
    offset) {
    # This function simply retrieves the correct information for each 
    # breakpoint
    
    indicatorData <- trendData %>%
      filter(stage == indicator) %>% 
      select(year, value) %>%
      mutate(offset = 1)
    
    if (offset[1] > 0) {
      indicatorData$offset <- offset
    }
    
    breakpoint <- 0
    preData <- 0
    postData <- 0
    
    if (nbreakpoints == 1) {
      breakpoint <- filter(segResults[[indicator]]$breakpoints, 
        model == "segModel1")$estimate
      if (breakpoint != 0) {
        preData <- filter(indicatorData, year <= breakpoint)
        postData <- filter(indicatorData, year > breakpoint)
      } 
    } else if (nbreakpoints == 2) {
      breakpoint <- filter(segResults[[indicator]]$breakpoints, 
        model == "segModel2")$estimate
      if (breakpoint[1] != 0) {
        if (breakpoint_number == 1) {
          preData <- filter(indicatorData, year <= breakpoint[1])
          postData <- filter(indicatorData, year > breakpoint[1], 
            year <= breakpoint[2])
        } else {
          # Second breakpoint
          preData <- filter(indicatorData, year > breakpoint[1], 
            year <= breakpoint[2])
          postData <- filter(indicatorData, year > breakpoint[2])
        }
        breakpoint <- breakpoint[breakpoint_number]
      }
    } else if (nbreakpoints == 3) {
      breakpoint <- filter(segResults[[indicator]]$breakpoints, 
        model == "segModel3")$estimate
      
      if (breakpoint[1] != 0) {
        if (breakpoint_number == 1) {
          preData <- filter(indicatorData, year <= breakpoint[1])
          postData <- filter(indicatorData, year > breakpoint[1], 
            year <= breakpoint[2])
        } else if (breakpoint_number == 2) {
          preData <- filter(indicatorData, year > breakpoint[1], 
            year <= breakpoint[2])
          postData <- filter(indicatorData, year > breakpoint[2], 
            year <= breakpoint[3])
        } else {
          # Third breakpoint
          preData <- filter(indicatorData, year > breakpoint[2], 
            year <= breakpoint[3])
          postData <- filter(indicatorData, year > breakpoint[3])
        }
        breakpoint <- breakpoint[breakpoint_number]
      }
    } else if (nbreakpoints == 4) {
      breakpoint <- filter(segResults[[indicator]]$breakpoints, 
        model == "segModel4")$estimate
      
      if (breakpoint[1] != 0) {
        if (breakpoint_number == 1) {
          preData <- filter(indicatorData, year <= breakpoint[1])
          postData <- filter(indicatorData, year > breakpoint[1], 
            year <= breakpoint[2])
        } else if (breakpoint_number == 2) {
          preData <- filter(indicatorData, year > breakpoint[1], 
            year <= breakpoint[2])
          postData <- filter(indicatorData, year > breakpoint[2], 
            year <= breakpoint[3])
        } else if (breakpoint_number == 3) {
          # Third breakpoint
          preData <- filter(indicatorData, year > breakpoint[2], 
            year <= breakpoint[3])
          postData <- filter(indicatorData, year > breakpoint[3],
            year <= breakpoint[4])
        } else {
          # fourth breakpoint
          preData <- filter(indicatorData, year > breakpoint[3], 
            year <= breakpoint[4])
          postData <- filter(indicatorData, year > breakpoint[4])
        }
        
        breakpoint <- breakpoint[breakpoint_number]
      }
    }
    
    output <- list(indicator = indicator, breakpoint = breakpoint, 
      pre_data = preData, post_data = postData)
    
    return(output)
  }
  
  prepostModels <- function(preData, postData, offset) {
    # This function produces the independent pre and post models
    # for the chow test and other testing 
    segModelPre <- glm(round(value) ~ year, data = preData, 
      offset = log(offset),
      family = "poisson")
    segModelPost <- glm(round(value) ~ year, data = postData, 
      offset = log(offset),
      family = "poisson")
    
    return(list(premodel = segModelPre, postmodel = segModelPost))
  }
  
  # Loop over each step and breakpoint store -------------------------------------
  
  modelTable <- tibble()
  
  for (ii in steps) {
    print(ii)
    results <- segResults[[ii]]
    
    tempTable <- results$breakpoints %>%
      mutate(indicator = ii) %>%
      select(indicator, model, breakpoint = estimate)
    
    tempTable$pchow <- 0
    tempTable$pslopes <- 0
    
    for (jj in 2:nrow(tempTable)) {
      print(jj)
      if (jj == 2) {
        nbreaks <- 1
        nbreak <- 1
      } else if (jj == 3) {
        nbreaks <- 2
        nbreak <- 1
      } else if (jj == 4) {
        nbreaks <- 2
        nbreak <- 2
      } else if (jj == 5) {
        nbreaks <- 3
        nbreak <- 1
      } else if (jj == 6) {
        nbreaks <- 3
        nbreak <- 2
      } else if (jj == 7) { 
        nbreaks <- 3
        nbreak <- 3
      } else if (jj == 8) { 
        nbreaks <- 4
        nbreak <- 1
      } else if (jj == 9) { 
        nbreaks <- 4
        nbreak <- 2
      } else if (jj == 10) { 
        nbreaks <- 4
        nbreak <- 3
      } else if (jj == 11) { 
        nbreaks <- 4
        nbreak <- 4
      }
      
      temp <- selectBreakpoint(ii, nbreaks, nbreak, offsets[[ii]])
      if (temp$breakpoint[1] != 0) {
        chowModels <- prepostModels(temp$pre_data, temp$post_data, offsets[[ii]])
        
        overalldata <- bind_rows(temp$pre_data, temp$post_data)
        model <- glm(value ~ year, offset = log(offset), 
          data = overalldata, family = "poisson")
        
        tempTable$pchow[jj] <- pchow(overalldata, model, chowModels$premodel, 
          chowModels$postmodel)
        
        tempTable$pslopes[jj] <- pslopes(overalldata, temp$breakpoint)$pwstat
      }
    }
    
    modelTable <- bind_rows(modelTable, tempTable)
  }
  
  # Save as table -----------------------------------------------------------
  if (savePlots) {
    
    write_excel_csv(modelTable, file.path(figFolder,
      paste0("HIVcascade_trend_breakpoints_", 
        toString(startYear), "-", toString(resultsYear), ".csv")))
  }
}
```

# Sensitivity of diagnosed untreated changepoint

Given the diagnosed not on ART trends shows very clear change points we 
explored the robustness of the change points to assumptions about the number
on treatment. One detected change point is close to the point where the ART
estimates transition from AHOD to PBS based. 

In this section we explore the impact of varying the ART estimates for 
2011, prior to 2012 and overall on the segmented model and change point 
detected. 

```{r Test noART breakpoint, eval = runtests}
if (runtests) {
  # This chunk is used to look at the sensitivity of the noART changepoint
  # by using different estimates for the number on ART. 
  
  # Original estimates for noART
  noARTorig <- filter(resultsAll, stage == "pldhiv")$value - 
    filter(resultsAll, stage == "numART")$value
  
  # Load the ART_Estimates_2014 file with the various fit options for merging
  # the AHOD and PBS + temporary residents data. Need to specifiy which ART
  # estimates (specifically temporary estimates number) we are using in 
  # the treatment data merging.
  addTempRes <- TRUE # Add estimates for temporary residents on ART
  atrasTRest <- TRUE # Use ATRAS estimates, FALSE = NAPWHA estimates
  # See 0-ArtAnalysis.Rmd for details
  # FALSE for ASR and TRUE for paper
  
  if (addTempRes) {
    trString <- ifelse(atrasTRest,"ATRAS", "NAPWHA")
  } else {
    trString <- "PBS"
  }
  
  artEstimates <- read.csv(file.path(resultsFolder,"..",
    paste0("ART_Estimates-2017-",
      trString, ".csv")))
  
  artDiffs <- list()
  
  # Original estimates
  artDiffs[[1]] <- filter(resultsAll, stage == "pldhiv")$value - 
    filter(resultsAll, stage == "numART")$value
  
  # First test - replace 2011 ART value with fitted 2011 value
  artTest <- filter(resultsAll, stage == "numART")$value
  
  artTest[8] <- artEstimates$fitlog[12]
  
  artDiffs[[2]] <- filter(resultsAll, stage == "pldhiv")$value -
    artTest
  
  # Second test - replace all AHOD values with fitted values
  artTest <- filter(resultsAll, stage == "numART")$value
  artTest[1:8] <- artEstimates$fitlog[5:12]
  
  artDiffs[[3]] <- filter(resultsAll, stage == "pldhiv")$value -
    artTest
  
  # Third test - Use both fitted pldhiv and numART over 2004-2016
  artDiffs[[4]] <- fitted(trendModels[["pldhiv"]]) -
    fitted(trendModels[["numART"]])
  
  # Loop across stages and save plots 
  segTestPlot <- list()
  testCaption <- c("Replace 2011 on ART value 
  from AHOD with fitted estimate",
    "Replace AHOD estimates with 
  fitted estimates 2004-2012",
    "Use difference between fitted 
  PLDHIV and fitted on ART")
  
  for (ii in 1:4) {
    # Need to use local to prevent scope issues with predicted values
    local({
      ii <- ii
      artTrial <- data.frame(value = artDiffs[[ii]], year = 2004:resultsYear)
      
      # Regenerate original model in case of scope issues
      artmodel <- glm(round(value) ~ year, data = artTrial, 
        family = "poisson")
      
      # Now run segmented to produce a segmented Poisson model. Varying the
      # initial guess of the breakpoint from 2007 to 2013 seems to produce 
      # no change in the fitted curve. 
      segModeltest <- segmented(artmodel, seg.Z = ~year, 
        psi = list(year = 2008))
      
      segTestData <- data.frame(year = artTrial$year, 
        segvalue = fitted(segModeltest))
      
      plotMax <- 6500
      segTestPlot[[ii]] <<- ggplot(data = artTrial, 
        aes(x = year, y = value)) + 
        geom_line(aes(color = "estimates")) + 
        geom_point(color = asrcols[2]) +
        geom_line(aes(y = fitted(artmodel),
          colour = "overall")) +
        geom_line(data = segTestData, aes(y = segvalue, 
          colour = "segment")) + 
        scale_x_continuous(breaks = seq(startYear,                        
          resultsYear, by = 3)) +
        scale_y_continuous(labels = comma) + 
        scale_colour_manual("", values = c(asrcols[2], "black", "blue"),
          limits = c("estimates", "overall", "segment"),
          labels = c("Estimates", "Overall model",
            "Segmented model")) +
        coord_cartesian(xlim = c(2004, resultsYear), ylim = c(0, plotMax)) + 
        ylab("Number diagnosed\nnot on ART") + xlab("Year") +  
        PlotOptions() + theme(legend.position = "bottom") + 
        geom_vline(xintercept = segModeltest$psi[2], linetype = "dashed",
          colour = "blue") + 
        geom_errorbarh(aes(y = 0.975 * plotMax,
          xmin = segCI(segModeltest$psi[2],
            segModeltest$psi[3])[1],
          xmax = segCI(segModeltest$psi[2],
            segModeltest$psi[3])[2]),
          colour = "blue",
          height = 0.025 * plotMax) +
        ggtitle(testCaption[ii]) +
        theme(plot.title = element_text(hjust = 0.5, size = 10))
      
      if (savePlots) {
        # Save the current plot
        ggsave(file.path(figFolder, paste0("HIVcascade_noART_Test", 
          toString(ii), "_", 
          toString(startYear), "-",
          toString(resultsYear),
          saveFormat)),
          plot = segTestPlot[[ii]], width = 12, height = 9, units = "cm")
      }
    })
  }
  
  # Save a combined plot comparison -----------------------------------------
  
  # Figure caption
  figs("trendSensitivity", "Trends in the number diagnosed not on ART over 2004-2016 under varying assumptions for the number on ART.The red discs show the best estimates for the cascade. The black lines show the estimates from the overall fitted Poisson models. The blue lines show the estimates from the segmented fitted Poisson models.")
  
  legend <- get_legend(segTestPlot[[1]])
  
  # Add the original plot to the combination plot
  combinedTest <- grid.arrange(legend, 
    segTestPlot[[1]] + theme(legend.position="none",
      plot.title = element_text(hjust = 0.5, size = 10)) +
      labs(title = "Original\nestimates", 
        caption = figs("trendSensitivity")) +
      segTestPlot[[2]] + theme(legend.position="none"), 
    segTestPlot[[3]] + theme(legend.position="none"),
    segTestPlot[[4]] + theme(legend.position="none"), 
    ncol = 2, nrow = 3, 
    layout_matrix = rbind(c(1, 1), c(2, 3), c(4, 5)),
    widths = c(4, 4), heights = c(0.8, 3.1, 3.1))
  
  stagesDiffsPlot4 <- ggdraw() +
    draw_plot(combinedTest, 0, 0, 1, 1) +
    draw_plot_label(c("A", "B", "C", "D"), c(0, 0.5, 0, 0.5),
      c(0.9, 0.9, 0.45, 0.45), size = 12)
  
  if (savePlots) {
    ggsave(file.path(figFolder,
      paste("HIVcascade_noART_Segment_Test_",
        toString(startYear), "-",
        toString(resultsYear),
        saveFormat, sep = "")),
      plot = stagesDiffsPlot4, width = 18, height = 15, units = "cm")
  }
}
```

# Non-linear model (DEPRECATED)

This section was used to explore the explore a non-linear least squares fitting 
of a non-linear model which allows for an increase and decrease in values over
time. Fitting the model allows us to report a rise and decay rate ratio and time 
where the max of peak value occurs. A disadvantage is that it is less 
interpretable. 

This fitting was applied to the cascade gaps data where a single change point 
original seemed to produce a good fit. However, this has now been superseeded by 
the multiple change point approach. The code has been kept here for prosperity 
and future use. 

The model is based on the following formula:
$$
f(t) = \frac {ake^{(g-d)t}} {(k-a)+ae^{gt}}.
$$
where $a$ is the initial value at $x = 0$, $g$ is the growth rate, $d$ is 
the decay rate, and $k$ is a threshold parameter which specifies the 
maximum value the grwoth can achieve (when $d = 0$). This function has been 
used previously in: 

> RT Gray, et al. Modeling the Impact of Potential Vaccines on Epidemics of 
> Sexually Transmitted Chlamydia Trachomatis Infection.
> JID 2009;199(11):1680-88. https://doi.org/10.1086/598983.

and

> AJ Shattock, et al. In the Interests of Time: Improving HIV Allocative 
> Efficiency Modelling via Optimal Time-Varying Allocations.
> JIAS 2016;19(1):20627. http://dx.doi.org/10.7448/IAS.19.1.20627.

The function is a combination of a logistic growth function and an 
exponential decay function. For $t \approx 0$, $f(t) \approx ae^{(g-d)t}$ and the 
growth is proportional to $e^{(g-d)t}$. Similarly, when x is large $f(t)$
is proportional to $e^{-dt}$. This means we can describe a rate ratio (RR) 
for the growth and decay of the function when $t$ represents time. With the 
the growth RR equal to $e^{g-d}$ and the decay RR $e^{-d}$. 

Though algebraic manipulation functional forms for the maximum (minimum)
value and the corresponding $t$ value $t_p$ can be obtained:
$$
t_p = \frac {1} {g} ln{\Big[ \frac {(g-d)(k-a)} {da}\Big]}.
$$

To fit the model to the annual data for `r startYear` to `r resultsYear` we 
use non-linear least squares via the `nls()` function with $t$ starting at 
zero and then being mapped to the years. Using `nls()` requires careful 
specification of the initial values which is done via guess and check and
visual inspection. From the resulting model we obtain the standard 
statistics though we can't generate an $R^2$ estimate by rights for a 
non-linear model. We assess goodness of fit using the BIC. To produce 
uncertainty in the model fits and results we sample from the 95% CIs for 
the parameters and simulate. From the simulations we obtain IQRs and 95% 
ranges for the fits and RRs. 

```{r Non-linear model, eval = runtests}
if (runtests) {
  # This chunk uses nls() to fit the model to the gaps as well as diagnoses
  # and infections. 
  
  # Load results from previous chunck 
  # load(file.path(resultsFolder, cascadeName, "CascadeTrendData.Rda"))
  # load(file.path(resultsFolder, cascadeName, "CascadeTrendModels.Rda"))
  
  LoadLibrary(minpack.lm)
  
  # Options
  addSegment <- TRUE
  
  # Set-up the functions we will use ----------------------------------------
  
  # Main model
  FitModel <- function(x, a, g, d, k) {
    return(k * a * exp((g-d) * x) / ((k - a) +
        a*exp(g * x)))
  }
  
  FitModel2 <- function(x, a, g, d) {
    return(10 * a * exp((g-d) * x) / ((10 - a) +
        a*exp(g * x)))
  }
  
  # Time to peak in model
  TP <- function(a, g, d, k) {
    return((1/g) * log((g-d)*(k-a)/(d*a)))
  }
  
  fitIndicators <- c("undiagnosed", "noART", "unsuppressed", "infections",
    "diagnoses")
  
  xseq <- years - years[1] # time points
  
  yLabels[["diagnoses"]] <- "Annual diagnoses"
  yLabels[["infections"]] <- "Annual new infections"
  
  # Estimates for plots for each stage---------------------------------------
  fitPlots <- list()
  fitModels <- list()
  
  ymax <- c("undiagnosed" = 3500, 
    "noART" = 6500, 
    "unsuppressed" = 4500,
    "diagnoses" = 1200,
    "infections" = 1200)
  
  fitData <- trendData %>%
    select(year, stage, value)
  
  # Add diagnoses and infections
  fitDiagsData <- diagsData %>%
    select(-overseas) %>%
    mutate(stage = "diagnoses") %>%
    select(year, stage, value = diags)
  
  fitInfectsData <- newInfects %>%
    select(year, infections) %>%
    mutate(stage = "infections") %>%
    select(year, stage, value = infections)
  
  fitData <- bind_rows(fitData, fitDiagsData, fitInfectsData)
  
  # Set-up initial values for fits ------------------------------------------
  
  # Guess and check 
  ydataTest <- filter(fitData, stage == "noART")$value
  qplot(xseq, FitModel(xseq, 5800, 0.2, 0.135, 20000), 
    geom = "line", 
    ylim = c(0, NA), 
    ylab = "Value") + 
    geom_point(aes(y = ydataTest), colour = "black") +
    PlotOptions()
  
  # Store initial values
  initialParList <- list(
    "undiagnosed" = list(a= 2900, g = 0.2, d = 0.007, k = 3250),
    "noART" = list(a = 5800, g = 0.2, d = 0.133, k = 20000), 
    "unsuppressed" = list(a = 3000, g = 0.001, d = 0.05, k = 3000),
    "infections" = list(a = 900, g = 0.3, d = 0.01, k = 1100),
    "diagnoses" = list(a = 900, g = 0.43, d = 0.41, k = 1500000))
  
  # Run fits
  for (ii in fitIndicators) { 
    # Need to use local to prevent scope issues with predicted values
    local({
      print(ii)
      ii <- ii
      tempData <- filter(fitData, stage == ii)
      
      # Regenerate original Poisson model in case of scope issues
      pmodel <- glm(round(value) ~ year, data = tempData, 
        family = "poisson")
      
      # Now run nls() to produce a non-linear model. Use try in
      # case fit does not converge (which occurs for unsuppressed). 
      plotModel <- TRUE
      fitModel <- try(nlsLM(tempData$value ~ FitModel(xseq, a, g, d, k),
        start = initialParList[[ii]],
        control = nls.control(maxiter = 1000)))
      # weights = c(rep(0.2,8), rep(1, 9))))
      
      if ("try-error" %in% class(fitModel)) {
        print(paste("Unable to fit nls to",ii))
        fitModel <- pmodel #trendModels[[ii]]
        plotModel <- FALSE
      } 
      
      fitModel2 <- nlsLM(value ~ FitModel2(xseq, a, g, d), tempData, 
        start = initialParList[[ii]][1:3],
        control = nls.control(maxiter = 1000))
      
      
      fitModels[[ii]] <<- fitModel
      
      # Plot on top of trend plot
      fitModelData <- data.frame(year = tempData$year,
        fitvalue = fitted(fitModel))
      
      fitPlot <- ggplot(data = tempData,
        aes(x = year, y = value)) +
        geom_line(aes(color = "estimates")) +
        geom_point(color = asrcols[2]) +
        geom_line(aes(y = fitted(pmodel),
          colour = "overall")) +
        geom_line(data = fitModelData, aes(y = fitvalue,
          colour = "fit")) +
        scale_x_continuous(breaks = seq(startYear,
          resultsYear, by = 3)) +
        scale_y_continuous(labels = comma) +
        scale_colour_manual("", values = c(asrcols[2], "black", "blue"),
          limits = c("estimates", "overall", "fit"),
          labels = c("Estimates", "Overall model",
            "Fitted model")) +
        coord_cartesian(ylim = c(0, ymax[ii])) +
        ylab(yLabels[ii]) + xlab("Year") +
        PlotOptions() #+
      
      if (addSegment) {
        # Add Segment model plot for comparison
        segmentModel <- segModels[[ii]]
        
        segModelData <- data.frame(year = tempData$year,
          segvalue = fitted(segmentModel))
        
        fitPlot <- fitPlot +
          geom_line(data = segModelData, aes(y = segvalue,
            colour = "segment")) +
          scale_colour_manual("", values = c(asrcols[2], "black", 
            "dark green", "blue"),
            limits = c("estimates", "overall", "segment", "fit"),
            labels = c("Estimates", "Overall model",
              "Segmented model", "Fitted model")) +
          geom_text(x = 2010, y = 0.3 * ymax[ii],
            label = paste("Overall BIC:",
              toString(round(BIC(pmodel), digits = 4))), size = 3) +
          geom_text(x = 2010, y = 0.2 * ymax[ii],
            label = paste("Segmented BIC:",
              toString(round(BIC(segmentModel), digits = 4))), size = 3) +
          geom_text(x = 2010, y = 0.1 * ymax[ii],
            label = paste("Fitted BIC:",
              toString(round(BIC(fitModel), digits = 4))), size = 3)
        
        if (plotModel) {
          pars <- unname(coef(fitModel))
          fitPlot <- fitPlot +
            geom_vline(xintercept =  years[1] + TP(pars[1], pars[2], 
              pars[3], pars[4]), 
              linetype = "dashed",
              colour = "blue") +
            geom_vline(xintercept = segmentModel$psi[2], linetype = "dotted",
              colour = "dark green")
        }
        
      } else {
        fitPlot <- fitPlot +
          geom_text(x = 2010, y = 0.2 * ymax[ii],
            label = paste("Overall BIC:",
              toString(round(BIC(pmodel), digits = 4))), size = 3) +
          geom_text(x = 2010, y = 0.1 * ymax[ii],
            label = paste("Fitted BIC:",
              toString(round(BIC(fitModel), digits = 4))), size = 3)
        
        if (plotModel) {
          pars <- unname(coef(fitModel))
          fitPlot <- fitPlot +
            geom_vline(xintercept =  years[1] + TP(pars[1], pars[2], 
              pars[3], pars[4]), 
              linetype = "dashed",
              colour = "blue")
        }
      }
      
      fitPlots[[ii]] <<- fitPlot
      
      if (savePlots) {
        # Save the current plot
        ggsave(file.path(figFolder, paste0("HIVcascade-Trends-", ii,
          "-Fitted_",
          toString(startYear), "-",
          toString(resultsYear),
          saveFormat)),
          plot = fitPlots[[ii]], width = 7.5, height = 6, units = "cm")
      }
    })
  }
  
  # Create combined plot
  legend <- get_legend(fitPlots[[1]])
  
  stagesDiffsPlot3 <- ggdraw() +
    draw_plot(legend, 0, 0.93, 1, 0.07) + 
    draw_plot(fitPlots[[1]] + theme(legend.position="none"), 
      0, 0.62, 0.5, 0.31) +
    draw_plot(fitPlots[[2]] + theme(legend.position="none"),
      0, 0.32, 0.5, 0.31) +
    draw_plot(fitPlots[[3]] + theme(legend.position="none"),
      0, 0, 0.5, 0.31) +
    draw_plot(fitPlots[[4]] + theme(legend.position="none"),
      0.5, 0.62, 0.5, 0.31) +
    draw_plot(fitPlots[[5]] + theme(legend.position="none"),
      0.5, 0.31, 0.5, 0.31) +
    draw_plot_label(c("A", "B", "C", "D", "E"), c(0, 0, 0, 0.5, 0.5),
      c(0.93, 0.62, 0.31, 0.93, 0.62), size = 12)
  
  
  # Save combined plot-------------------------------------------------------
  if (savePlots) {
    if (addSegment) {
      plotFile <- "HIVcascade-Differences-Trends_Segment-Fitted_"
    } else {
      plotFile <- "HIVcascade-Differences-Trends_Fitted_"
    }
    
    ggsave(file.path(figFolder,
      paste(plotFile,
        toString(startYear), "-",
        toString(resultsYear),
        saveFormat, sep = "")),
      plot = stagesDiffsPlot3, width = 18, height = 25, units = "cm")
  }
}
```

```{r Generate uncertainty, eval = runtests}
if (runtests) {
  # In this chunk we generate ranges for the nls fits to the gaps using 
  # boot-strapping. This allows us to estimate the peak from the 
  # boot-strapped parameters. 
  
  LoadLibrary(tidymodels)
  
  # Set-up indicator fitting 
  set.seed(2653)
  numBoots <- 10000
  
  fitIndicators <- c("undiagnosed", "noART", "unsuppressed", "infections",
    "diagnoses")
  
  modelFits <- list()
  bootModelFits <- list()
  bootstrapPlots <- list()
  
  # Run fits
  for (ii in fitIndicators) { 
    # Need to use local to prevent scope issues with predicted values
    local({
      print(ii)
      ii <- ii
      tempData <- filter(fitData, stage == ii) %>%
        mutate(xseq = seq(0,length(years)-1))
      
      modelFit <- tryCatch(nls(value ~ FitModel(xseq, a, g, d, k), tempData, 
        start = initialParList[[ii]],
        control = nls.control(maxiter = 1000)), 
        error = function(cond) {
          glm(round(value) ~ xseq, data = tempData, 
            family = "poisson")})
      
      tempboots <- bootstraps(tempData, times = numBoots, apparent = TRUE)
      
      tempFit_on_bootstrap <- function(split) {
        # Uses a tryCatch() call to return a model for each boot split given nls
        # won't work for some cascade gaps. 
        # Need to be careful with scope in tryCatch() and what it returns.
        modelFitSplit <- tryCatch(nls(value ~ FitModel(xseq, a, g, d, k),
          analysis(split), 
          start = initialParList[[ii]],
          control = nls.control(maxiter = 1000, warnOnly = TRUE, 
            minFactor = 1/4096)), 
          error = function(err) {
            print("Using glm")
            # nls doesn't work
            fitData <- analysis(split)
            errModelSplit <- glm(round(value) ~ xseq, data = analysis(split), 
              family = "poisson")
            # Return alternative model
            return(errModelSplit)})
        
        # Return final model for split
        return(modelFitSplit)
      }
      
      temp_boot_models <- tempboots %>% 
        mutate(model = map(splits, tempFit_on_bootstrap),
          coef_info = map(model, tidy),
          predictions = map(model, augment))
      
      # New data for smoothing
      new_preds <- tempData %>%
        do(., data.frame(xseq = seq(min(.$xseq), max(.$xseq), 
          length.out = 250), stringsAsFactors = FALSE))
      
      preds <- augment(modelFit, newdata = new_preds, 
        type.predict = "response")
      
      # Create smoother predictions for bootstrapped replicate
      preds <- temp_boot_models %>%
        mutate(new_predictions = map(model, augment, newdata = new_preds, 
          type.predict = "response")) %>%
        unnest(new_predictions) %>%
        # group by each value of xseq and get quantiles
        group_by(., xseq) %>%
        summarise(lwr_CI = quantile(.fitted, 0.025),
          lwr_IRQ = quantile(.fitted, 0.25),
          upr_IQR = quantile(.fitted, 0.75),
          upr_CI = quantile(.fitted, 0.975)) %>%
        ungroup() %>%
        merge(., preds, by = 'xseq')
      
      # Plot model fit and bootstrap ranges
      bootstrapPlot <- ggplot() + 
        geom_ribbon(data = preds, aes(x = xseq, ymin = lwr_CI, ymax = upr_CI,
          fill = "ci",  alpha = "ci")) +
        geom_ribbon(data = preds, aes(x = xseq, ymin = lwr_IRQ, ymax = upr_IQR, 
          fill = "iqr",  alpha = "iqr")) +
        geom_point(data = tempData, aes(xseq, value, colour = "data")) +
        geom_line(data = tempData, aes(xseq, value), colour = asrcols[2]) +
        geom_line(data = preds, aes(x = xseq, y = .fitted, colour = "fit")) +
        ylab(yLabels[ii]) +
        xlab('Year') +
        scale_colour_manual(NULL, values = c(asrcols[2], "black"),
          limits = c("data", "fit"),
          labels = c("Estimates", "Fitted values")) +
        scale_alpha_manual(NULL, values = c(0.4, 0.1),
          limits = c("iqr", "ci"),
          labels = c("Fitted IQR", "Fitted 95% CI")) +
        scale_fill_manual(NULL, values = c("black", "black"),
          limits = c("iqr", "ci"),
          labels = c("Fitted IQR", "Fitted 95% CI")) +
        scale_x_continuous(breaks = seq(0, length(years)-1, by = 3), 
          labels = seq(startYear, resultsYear, by = 3)) +
        scale_y_continuous(labels = comma) +
        expand_limits(y = 0) +
        PlotOptions() + theme(legend.spacing = unit(0, "cm"),
          legend.margin = margin(0, 0, 0, 0, "cm")) +
        guides(colour = guide_legend(order = 1),
          alpha = guide_legend(order = 2),
          fill = FALSE)
      
      modelFits[[ii]] <<- modelFit
      bootModelFits[[ii]] <<- temp_boot_models
      bootstrapPlots[[ii]] <<- bootstrapPlot
      
      if (savePlots) {
        # Save the current plot
        ggsave(file.path(figFolder, paste0("HIVcascade-Trends-", ii,
          "-Bootstrap_Fit_",
          toString(startYear), "-",
          toString(resultsYear),
          saveFormat)),
          plot = bootstrapPlots[[ii]] + theme(legend.position = "none"), 
          width = 7.5, height = 6, units = "cm")
      }
    })
  }
  
  # Create combined plot
  legend <- get_legend(bootstrapPlots[[1]])
  
  combinedBootsPlot <- ggdraw() +
    draw_plot(legend, 0, 0.93, 1, 0.07) + 
    draw_plot(bootstrapPlots[[1]] + theme(legend.position="none"), 
      0, 0.62, 0.5, 0.31) +
    draw_plot(bootstrapPlots[[2]] + theme(legend.position="none"),
      0, 0.32, 0.5, 0.31) +
    draw_plot(bootstrapPlots[[3]] + theme(legend.position="none"),
      0, 0, 0.5, 0.31) +
    draw_plot(bootstrapPlots[[4]] + theme(legend.position="none"),
      0.5, 0.62, 0.5, 0.31) +
    draw_plot(bootstrapPlots[[5]] + theme(legend.position="none"),
      0.5, 0.31, 0.5, 0.31) +
    draw_plot_label(c("A", "B", "C", "D", "E"), c(0, 0, 0, 0.5, 0.5),
      c(0.93, 0.62, 0.31, 0.93, 0.62), size = 12)
  
  # Save combined plot-------------------------------------------------------
  if (savePlots) {
    plotFile <- "HIVcascade-Differences-Trends-Bootstrap_Fitted"
    
    ggsave(file.path(figFolder,
      paste0(plotFile, startYear, "-", resultsYear, saveFormat)),
      plot = combinedBootsPlot, width = 18, height = 25, units = "cm")
  }
  
  # set.seed(NULL)
}
```

```{r Non-linear stats, eval = runtests}
if (runtests) {
  # In this chuck we save the stats for the fitted and bootstrapped nls 
  # results
  
  # First save results so we can load later if necessay
  # save(numBoots, fitIndicators, fitModels, fitPlots, modelFits, bootModelFits,
  #   bootstrapPlots,
  #   file = file.path(figFolder, paste0("HIV_Cascade_nls_trends_", 
  #     startYear, "-", resultsYear, ".Rda")))
  load(file.path(figFolder, paste0("HIV_Cascade_nls_trends_",
    startYear, "-", resultsYear, ".Rda")))
  
  fitIndicators <- c("undiagnosed", "noART", "unsuppressed", "infections",
    "diagnoses")
  
  # Fitted estimates
  numRows <- length(fitIndicators)*5*2
  nlsStats <- tibble(
    indicator = character(numRows),
    fitting = character(numRows),
    parameter = character(numRows),
    estimate = numeric(numRows),
    lower = numeric(numRows),
    upper = numeric(numRows))
  
  for (ii in 1:length(fitIndicators)) {
    
    indicator <- fitIndicators[[ii]]
    print(indicator)
    pars <- unname(coef(fitModels[[ii]]))
    confIntervals <- tryCatch(confint(fitModels[[ii]]),
      error = function (err) {
        # Doesn't converge for diagnoses for some reason
        return(matrix(0, nrow = 4, ncol = 2))})
    
    if (indicator == "unsuppressed") {
      peak <- NA
      pars <- c(pars[1], NA, pars[2], NA)
      temp <- matrix(0, nrow= 4, ncol = 2)
      temp[c(1,3),] <- confIntervals
      confIntervals <- temp
    } else { 
      peak <- years[1] + TP(pars[1], pars[2], pars[3], pars[4])
    }
    
    indices <- (5*(ii-1)+1):(5*ii)
    
    nlsStats$indicator[indices] <- rep(indicator,5)
    nlsStats$fitting[indices] <- rep("fit",5)
    nlsStats$parameter[indices] <- c("a", "g", "d", "k", "TP")
    nlsStats$estimate[indices] <- c(pars, peak)
    nlsStats$lower[indices] <- c(confIntervals[,1], 0)
    nlsStats$upper[indices] <- c(confIntervals[,2], 0)
  }
  
  boot_coefs <- bootModelFits[[1]]%>%
    unnest(coef_info)
  mean(filter(boot_coefs, term == "g")$estimate)
  
  
  # percentile_intervals <- int_pctl(temp_boot_models, coef_info)
  # percentile_intervals
  
  # ggplot(boot_coefs, aes(estimate)) +
  #   geom_histogram(bins = 30) +
  #   facet_wrap( ~ term, scales = "free") +
  #   geom_vline(aes(xintercept = .lower), 
  #     data = percentile_intervals, col = "blue") +
  #   geom_vline(aes(xintercept = .upper), 
  #     data = percentile_intervals, col = "blue")
  # 
  # boot_aug <- boot_models_test %>% 
  #   sample_n(200) %>% 
  #   unnest(predictions)
  # 
  # ggplot(boot_aug, aes(xseq, value)) +
  #   geom_line(aes(y = .fitted, group = id), alpha = .2, col = "blue") +
  #   geom_point()
}
```



