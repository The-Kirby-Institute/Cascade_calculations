---
title: "HIV Cascade Trends Exploration"
author: "Richard T. Gray"
date: "Latest version - 3 February 2022"
---

This document is used to explore trends in the national Australian HIV 
Cascade.  

```{r setup}
# Open as a project (setting working directory to source and restarting R)

# Setup directories
basePath <- getwd() #dirname(getwd())
Rcode <- file.path(dirname(getwd()), "code")
HIVcode <- file.path(basePath, "code") 
dataFolder <- file.path(basePath, "data")
resultsFolder <- file.path(basePath, "output")

# Notifications folder is a private secure folder 
notificationsFolder <- file.path("/", "SVR-NAS", "Public", "SERP", "Data", 
  "National HIV Registry", "Cascades")

# Set working directory to current directory
#setwd(basePath)

# Load standard libraries and options ----------------------------------
source(file.path(Rcode, "LoadLibrary.R"), echo=TRUE)
source(file.path(Rcode, "PlotOptions.R"), echo=TRUE)
source(file.path(Rcode, "PlotColors.R"), echo=TRUE)
source(file.path(Rcode, "EveryNth.R"), echo=TRUE)
LoadLibrary(tidyverse)
LoadLibrary(scales)
LoadLibrary(cowplot) # Note this masks ggsave with save_plot
LoadLibrary(captioner)
LoadLibrary(stringr)
LoadLibrary(gridExtra)
LoadLibrary(svglite)

# Function to tidy notifications
source(file.path(HIVcode, "TidyNotifications.R"), echo=TRUE)

# Script parameters
resultsYear <- 2020  # year of cascade we will plot
minYear <- 17      # how long ago do we plot things
startYear <- resultsYear - minYear + 1 
savePlots <- TRUE
years <- startYear:resultsYear

# Set up project and cascade to analyse
projectName <- "HIV_Cascade_Paper"  
resultsFolder <- file.path(resultsFolder, projectName)
cascadeName <- "All-2020"
cascadePop <- "all"

# New infections parameters
infectsCalculation <- "middle" # "include", "exclude" or "middle"

# TODO:Plot specs
# stages <- c("infected", "pldhiv",  
#   "retained", "numART", "suppressed")
# stageNames <- c("Living with HIV", "Diagnosed", 
#   "Retained in care", "Receiving ART", "Suppressed virus")
# stageNamesNeat <- c("Living \n with HIV", "Diagnosed", 
#   "Retained \n in care", 
#   "Receiving \n ART", "Suppressed \n virus")

# Create output directory
if (savePlots) {
  saveFormat <- ".svg"
  figFolder <- file.path(resultsFolder, "figures", resultsYear)
  dir.create(figFolder, showWarnings = FALSE, recursive = TRUE)
}

# Captions
figs <- captioner()
tabs <- captioner(prefix = "Table")

# Plot colours 
asrcols <- PlotColors("hivcascade5")
```

```{r loadresults}

# Load hiv cascade dataframe
inputFile <- file.path(resultsFolder, cascadeName,
  paste0("HIVcascadeEstimates-", resultsYear, ".csv"))
hivCascade <- read.csv(inputFile)

# Exclude linked and retained in care
hivCascade <- filter(hivCascade, stage != "linked", stage != "retained")

# Only look at the overall national cascade
resultsAll <- filter(hivCascade,
  population == cascadePop,
  year >= startYear)

# Load cleaned notifications data and tidy up for diagnoses 
# trend calculations
origHivData <- read.csv(file.path(notificationsFolder, 
  paste0("cascadeHIVnotifications-clean-", resultsYear, 
    ".csv")))  
countryCodes <- read.csv(file.path(dataFolder, 
  "countryRegionCodes.csv"))
# Read in location of diagnosis coding
regionCodes <- read.csv(file.path(dataFolder, "postcodeRegionCodes.csv"))
hivSet <- TidyNotifications(origHivData, resultsYear, countryCodes,
  regionCodes)

# Load new infections estimates
inputFileInfections <- file.path(resultsFolder, cascadeName,
  paste0("newInfectionsEstimates-", resultsYear, ".csv"))
hivNewInfections <- read.csv(inputFileInfections) 
if (infectsCalculation == "include") {
  hivNewInfections <- hivNewInfections %>%
    filter(exclude == "no") %>% 
    select(-exclude)
} else if (infectsCalculation == "exclude") {
  hivNewInfections <- hivNewInfections %>%
    filter(exclude == "yes") %>% 
    select(-exclude)
} else {
  # Its "middle"
  infectsInclude <- hivNewInfections %>%
    filter(exclude == "no") %>% 
    select(-exclude)
  infectsExclude <- hivNewInfections %>%
    filter(exclude == "yes") %>% 
    select(-exclude)
  
  hivNewInfections <- tibble(year = infectsInclude$year,
    infections = (infectsInclude$infections + 
        infectsExclude$infections) / 2,
    infections_lower = infectsExclude$infections_lower,
    infections_upper = infectsInclude$infections_upper)
  
}

# Load cascade indicator estimates - might not need as we can recalculate 
# separately 
inputFileIndicators<- file.path(resultsFolder, cascadeName,
  paste0("cascadeIndicators.csv"))
hivCascadeIndicators <- read.csv(inputFileIndicators) 

```

# Simple trends of the cascade steps and gaps

We used a simple Poisson regression with year as the independent covariate 
for the main cascade steps and indicators over 2004-2016. A more
advanced trend analyses for teh cascade steps was completed by Hamish McMannus
but we decided a simple poisson progression of the best estimates would be 
sufficient. Hamish's analysis is available in the trend_analysis folder.

We aimed to produce a number of diagnostics of the poisson fit. Ended up 
sticking with a plot and pseudo R^2 calculation. The pseudo-R^2 uses 
the rsq package https://cran.r-project.org/web/packages/rsq/index.html
based on the calculation in the paper: Cameron & Windmeijer, An 
R-squared measure of goodness of fit for some common nonlinear 
regression model, Journal of Econometrics, 77 (1997) 329-342. 

Considered test for heteroscedasticity in the residuals using the 
Breusch-Pagan test (P > 0.05 means it is okay) using bptest() from the 
lmtest package https://cran.r-project.org/web/packages/rsq/index.html 
(but I don't think  it is valid for Poisson models).
Also the standard in built Chi-squared test isn't valid for Poisson
based on this blog post: http://thestatsgeek.com/2014/04/26/deviance-goodness-of-fit-test-for-poisson-regression/
So dropped these tests. 

```{r simple trends}
# This chunk is used to do some simple trend analysis of the cascade
# and other indicator estimates over 2004-2020. Throughout coefficients of 
# Poisson models are exponentiated to represent a rate ratio. Trends for the 
# cascade percentages and cascade indicators are done in the next chunk 
# because they need an offset as they are proportions/ratios. 

plotTrends <- FALSE # Add trend lines to plots

# Notifications ----------------------------------------------------------

# Notifications including and excluding people previously diagnosed overseas
diagsDataExclude <- hivSet %>%
  filter(is.na(previ_diag_overseas)) %>%
  group_by(yeardiagnosis) %>%
  summarise(diags = n()) %>%
  rename(year = yeardiagnosis) %>%
  filter(year >= startYear) %>%
  mutate(overseas = "no")

diagsDataInclude <- hivSet %>%
  group_by(yeardiagnosis) %>%
  summarise(diags = n()) %>%
  rename(year = yeardiagnosis) %>%
  filter(year >= startYear) %>%
  mutate(overseas = "yes")

diagsData <- dplyr::bind_rows(diagsDataExclude, diagsDataInclude)

trendDiagsExclude <- glm(diags ~ year, data = diagsDataExclude, 
  family = "poisson")
coeffDiagsExclude <- exp(coef(trendDiagsExclude)[2])
p_valueDiagsExclude  <- summary(trendDiagsExclude)$coefficients["year", "Pr(>|z|)"]
intervalDiagsExclude  <- exp(confint(trendDiagsExclude, "year", type = "Wald"))

trendDiagsInclude <- glm(diags ~ year, data = diagsDataInclude, 
  family = "poisson")
coeffDiagsInclude <- exp(coef(trendDiagsInclude)[2])
p_valueDiagsInclude <- summary(trendDiagsInclude)$coefficients["year", "Pr(>|z|)"]
intervalDiagsInclude <- exp(confint(trendDiagsInclude, "year", type = "Wald"))

diagsPlot <- ggplot(data = diagsDataExclude, aes(x = year)) +
  geom_line(aes(y = diags, colour = "exclude")) + 
  geom_point(aes(y = diags), colour = "blue") +
  # geom_line(aes(y = predict(trendDiagsExclude, type = "response"), 
  #   colour = "trend")) +
  geom_line(data = diagsDataInclude, aes(y = diags, colour = "include")) + 
  geom_point(data = diagsDataInclude, aes(y = diags), colour = "red") +
  # geom_line(aes(y = predict(trendDiagsInclude, type = "response")), 
  #   colour = "black") +
  geom_point(aes(y = diagsDataInclude$diags - diags, 
    colour = "gap")) +
  geom_line(aes(y = diagsDataInclude$diags - diags, 
    colour = "gap")) +
  scale_colour_manual(name = "", values = c("red", "blue", "black"),
    breaks = c("include", "exclude", "gap"), 
    labels = c("Including previously diagnosed overseas", 
      "Excluding previously diagnosed overses", "Difference"),
    guide = guide_legend(nrow = 3)) +
  coord_cartesian(ylim = c(0, 1500)) +
  expand_limits(y = 0) +
  scale_y_continuous(labels = comma) +
  ylab("Annual notifications") + xlab("Year") +
  PlotOptions() 

diagsPlot

if (savePlots) {
  # Save the diagnoses plot
  ggsave(file.path(figFolder, paste0("HIVcascade-Diagnoses_",
    startYear, "-", resultsYear, saveFormat)),
    plot = diagsPlot, width = 10, height = 8, units = "cm")
}

# Get new infections
newInfects <- hivNewInfections %>%
  filter(year >= startYear) %>%
  mutate(infections = round(infections),
    infections_lower = round(infections_lower),
    infections_upper = round(infections_upper))

# Gaps between steps -----------------------------------------------------------
diffsData <- tibble(year = diagsDataExclude$year)
diffsData$undiagnosed <- filter(resultsAll, stage == "infected")$value - 
  filter(resultsAll, stage == "pldhiv")$value
diffsData$noART <- filter(resultsAll, stage == "pldhiv")$value - 
  filter(resultsAll, stage == "numART")$value
diffsData$unsuppressed <- filter(resultsAll, stage == "numART")$value - 
  filter(resultsAll, stage == "suppressed")$value

diffSteps <- names(diffsData)[-1]

diffsData <- gather(diffsData, "stage", "value", 2:4)

diffsData$lower <- NA
diffsData$upper <- NA

trendData <- bind_rows(dplyr::select(resultsAll, year, stage, value,
  lower, upper), diffsData) %>%
  as_tibble()

# Add diagnoses and infections data --------------------------------------------
trendData <- bind_rows(trendData,
  diagsDataExclude %>% 
    mutate(stage = "diagnoses_exclude", lower = NA, upper = NA) %>% 
    select(year, stage, value = diags, lower, upper),
  diagsDataInclude %>% 
    mutate(stage = "diagnoses_include", lower = NA, upper = NA) %>% 
    select(year, stage, value = diags, lower, upper), 
  newInfects %>% 
    mutate(stage = "infections") %>% 
    select(year, stage, value = infections, lower = infections_lower, 
      upper = infections_upper))

# Trends ----------------------------------------------------
steps <- unique(trendData$stage)

trendCascade <- tibble(stage = character(length(steps)), 
  coeff = numeric(length(steps)),
  pvalue = numeric(length(steps)),
  lower = numeric(length(steps)),
  upper = numeric(length(steps)))

# Set up to save all the models and plots
trendModels <- list()
trendPlots <- list()

for (ii in 1:length(steps)) {
  tempData <- filter(trendData, stage == unique(trendData$stage)[ii])           
  temp <- glm(round(value) ~ year, data = tempData, family = "poisson")
  
  trendCascade$stage[ii] <- steps[ii]
  trendCascade$coeff[ii] <- exp(coef(temp)[2])
  trendCascade$pvalue[ii] <- summary(temp)$coefficients["year",
    "Pr(>|z|)"]
  tempInterval <- exp(confint(temp, "year", type = "Wald"))
  trendCascade$lower[ii] <- tempInterval[1]
  trendCascade$upper[ii] <- tempInterval[2]
  
  trendModels[[steps[ii]]] <- temp
}

# Simple Trend plots ------------------------------------------------------------

yLabels <- c("infected" = "Number of PLHIV",
  "pldhiv" = "Number diagnosed",
  "numART" = "Number on ART",
  "suppressed" = "Number suppressed\n(VL < 200 copies/ml)",
  "undiagnosed" = "Number of PLHIV\nundiagnosed",
  "noART" = "Number diagnosed\n not on ART",
  "unsuppressed" = "Number unsuppressed\n(VL >= 200 copies/ml)",
  "diagnoses_exclude" = "Annual notifications\n(excluding OS diagnoses)",
  "diagnoses_include" = "Annual notifications\n(including OS diagnoses)",
  "infections" = "Annual new infections")

# Function to produce plots of data versus trend
PlotTrend <- function(data, models, indicator, trend = TRUE) {
  model <- models[[indicator]]
  tempData <- filter(data, stage == indicator)
  tempPlot <- ggplot(data = tempData, aes(x = year, y = value)) +
    geom_ribbon(aes(ymin = lower, ymax = upper), 
      fill = asrcols[2], alpha = 0.4) +
    geom_line(color = asrcols[2]) + 
    geom_point(color = asrcols[2]) +
    scale_x_continuous(breaks = seq(startYear,                        
      resultsYear, by = 3)) +
    ylab(yLabels[indicator]) + xlab("Year") +  
    expand_limits(y = 0) +
    scale_y_continuous(labels = comma) + 
    PlotOptions() 
  
  if (trend) {
    tempPlot <- tempPlot + 
      geom_line(aes(y = predict(model, type = "response")),
        colour = "black")
  }
  
  # Save the current plot
  if (savePlots) {
    ggsave(file.path(figFolder, paste0("HIVcascade-Trends-", indicator, "_",
      toString(startYear), "-",
      toString(resultsYear),
      saveFormat)),
      plot = tempPlot, width = 7.5, height = 6, 
      units = "cm")
  }
  
  return(tempPlot)
}

# Apply to all steps - note will get warnings for steps where lower and upper 
# are NA
trendPlots <- lapply(steps, PlotTrend, data = trendData, 
  models = trendModels, trend = plotTrends)
names(trendPlots) <- steps

# Predictions for plotting 
# PredictTrend <- function(models, indicator){
#   model <- models[[indicator]]
#   return(predict(model, type = "response"))
# }

# Create a group plots ---------------------------------------------------------

# Cascade steps
stagesTrendPlot <- plot_grid(trendPlots[[1]], trendPlots[[2]],
  trendPlots[[3]], trendPlots[[4]],
  labels = c("A", "B", "C", "D"), ncol = 2, 
  nrow = 2, align = "v")

# Cascade gaps
stagesDiffsPlot <- plot_grid(trendPlots[[5]], trendPlots[[6]],
  trendPlots[[7]],
  labels = c("A", "B", "C"), ncol = 2, 
  nrow = 2, align = "v")

# Figure captions
figs("cascadeTrends", "Trends in each step of the Australian HIV cascade over 2004-2018. The red discs show the best estimates for the cascade with the shading showing the range. The black lines show the estimatesfrom the fitted Poisson models.")
figs("gapsTrends", "Trends in gaps between the steps of the Australian HIV cascade over 2004-2018. The red discs show the best estimates. The black lines show the estimates from the fitted Poisson models.")

# Save the current plots
if (savePlots) {
  ggsave(file.path(figFolder, paste("HIVcascade-Stages-Trends_",
    toString(startYear), "-",
    toString(resultsYear),
    saveFormat, sep = "")),
    plot = stagesTrendPlot, width = 18, height = 15, units = "cm")
  
  ggsave(file.path(figFolder, paste("HIVcascade-Differences-Trends_",
    toString(startYear), "-",
    toString(resultsYear),
    saveFormat, sep = "")),
    plot = stagesDiffsPlot, width = 18, height = 15, units = "cm")
}

```

# Trends in the UNAIDS 90-90-90 targets and Cascade Indicators

This section looks at the trends in the UNAIDS 90-90-90 targets and other
cascade indicators which are proportions or ratios. We used a Poisson model
with an offset to get a rate ratio. For each gap we obtain linear, logistic, 
and exponential trends for comparison but used the exponential models for 
ease of interpretability. 

```{r Trends 90-90-90}
# This chunk looks at the trends in the UNAIDS 90-90-90 targets.

# Produce the proportions
diagnosedProp <- filter(trendData, stage == "pldhiv")$value / 
  filter(trendData, stage == "infected")$value
artProp <- filter(trendData, stage == "numART")$value / 
  filter(trendData, stage == "pldhiv")$value
supProp <- filter(trendData, stage == "suppressed")$value / 
  filter(trendData, stage == "numART")$value
overallProp <- filter(trendData, stage == "suppressed")$value / 
  filter(trendData, stage == "infected")$value

year <- startYear:resultsYear

# Add to trend data and save
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "propdiagnosed", value = diagnosedProp, lower = NA, upper = NA))
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "proptreated", value = artProp, lower = NA, upper = NA))
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "propsuppressed", value = supProp, lower = NA, upper = NA))
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "propoverall", value = overallProp, lower = NA, upper = NA))

# if (savePlots) {
#   write_csv(trendData, file.path(figFolder, paste0("HIVcascade_Trend_data_",
#     toString(startYear), "-", toString(resultsYear), ".csv")))
# }

# Linear models -----------------------------------------------------------
# First simple linear models which allow us to estimate the percentage 
# point increase each year
diagslmModel <- lm(diagnosedProp ~ year)
treatedlmModel <- lm(artProp ~ year)
suppressedlmModel <- lm(supProp ~ year)
overalllmModel <- lm(overallProp ~ year)

# Coefficients for annual change
coefflmdiags <- coef(diagslmModel)["year"]
coefflmart <- coef(treatedlmModel)["year"]
coefflmsuppressed <- coef(suppressedlmModel)["year"]
coefflmoverall <- coef(overalllmModel)["year"]

# P-values for annual change
p_valuelmdiags <- summary(diagslmModel)$coefficients["year", "Pr(>|t|)"]
p_valuelmart <- summary(treatedlmModel)$coefficients["year", "Pr(>|t|)"]
p_valuelmsuppressed <- summary(suppressedlmModel)$coefficients["year",
  "Pr(>|t|)"]
p_valuelmoverall <- summary(overalllmModel)$coefficients["year",
  "Pr(>|t|)"]

# Confidence interval for annual change
intervallmdiags <- confint(diagslmModel, "year", type = "Wald")
intervallmart <- confint(treatedlmModel, "year", type = "Wald")
intervallmsuppressed <- confint(suppressedlmModel, "year", type = "Wald")
intervallmoverall <- confint(overalllmModel, "year", type = "Wald")

# Logistic models ---------------------------------------------------------
# Fit logistic curve to each trend to see if it produces a better fit. Feel
# a logistic curve is the best fit for proportions to account for 
# saturation, however, hard to interpret. Used here for comparison to the
# linear and exponential models.

diagnosedTrials <- cbind(round(filter(trendData, 
  stage == "pldhiv")$value), round(filter(trendData, 
    stage == "undiagnosed")$value))
artTrials <- cbind(round(filter(trendData, 
  stage == "numART")$value), round(filter(trendData, 
    stage == "noART")$value))
suppressedTrials <- cbind(round(filter(trendData, 
  stage == "suppressed")$value), round(filter(trendData, 
    stage == "unsuppressed")$value))
overallTrials <- cbind(round(filter(trendData, 
  stage == "suppressed")$value), round(filter(trendData, 
    stage == "infected")$value - filter(trendData, 
      stage == "suppressed")$value))

diagsModel <- glm(diagnosedTrials ~ year, 
  family = binomial(link = "logit"))
treatedModel <- glm(artTrials ~ year, 
  family = binomial(link = "logit"))
suppressedModel <- glm(suppressedTrials ~ year, 
  family = binomial(link = "logit"))
overallModel <- glm(overallTrials ~ year, 
  family = binomial(link = "logit"))

# Calculate p-values
p_diags <- summary(diagsModel)$coefficients["year", "Pr(>|z|)"]
p_art <- summary(treatedModel)$coefficients["year", "Pr(>|z|)"]
p_suppressed <- summary(suppressedModel)$coefficients["year", "Pr(>|z|)"]
p_overall <- summary(overallModel)$coefficients["year", "Pr(>|z|)"]

# Poisson models ----------------------------------------------------------
# Use a Poisson model with an offset to produce a rate ratio for the change 
# in the proportion. These are the main models we will use

trendModelsProp <- list()
trendPlotsProp <- list()

# Set-up data for Poisson/exponential models
expTrendData <- trendData %>% 
  select(year, stage, value) %>% 
  mutate(value = round(value)) %>%
  tidyr::spread(stage, value)

# Models - using denominator as an offset 
diagsExpModel <- glm(pldhiv ~ year, offset = log(infected), 
  data = expTrendData, family = "poisson")
treatedExpModel  <- glm(numART ~ year, offset = log(pldhiv), 
  data = expTrendData, family = "poisson")
suppressedExpModel  <- glm(suppressed ~ year, offset = log(numART), 
  data = expTrendData, family = "poisson")
overallExpModel  <- glm(suppressed ~ year, offset = log(infected), 
  data = expTrendData, family = "poisson")

trendModelsProp[["propdiagnosed"]] <- diagsExpModel
trendModelsProp[["proptreated"]] <- treatedExpModel
trendModelsProp[["propsuppressed"]] <- suppressedExpModel
trendModelsProp[["propoverall"]] <- overallExpModel

# Coefficients for annual change (as rate ratio)
coeffExpdiags <- exp(coef(diagsExpModel)["year"])
coeffExpart <- exp(coef(treatedExpModel)["year"])
coeffExpsuppressed <- exp(coef(suppressedExpModel)["year"])
coeffExpoverall <- exp(coef(overallExpModel)["year"])

# P-values for annual change
p_valueExpdiags <- summary(diagsExpModel)$coefficients["year", "Pr(>|z|)"]
p_valueExpart <- summary(treatedExpModel)$coefficients["year", "Pr(>|z|)"]
p_valueExpsuppressed <- summary(suppressedExpModel)$coefficients["year",
  "Pr(>|z|)"]
p_valueExpoverall <- summary(overallExpModel)$coefficients["year",
  "Pr(>|z|)"]

# Confidence interval for annual change (as a rate ratio)
intervalExpdiags <- exp(confint(diagsExpModel, "year", type = "Wald"))
intervalExpart <- exp(confint(treatedExpModel, "year", type = "Wald"))
intervalExpsuppressed <- exp(confint(suppressedExpModel, "year", 
  type = "Wald"))
intervalExpoverall <- exp(confint(overallExpModel, "year", type = "Wald"))

# Plots of estimates and trends ------------------------------------------------

# Plot the proportion, linear model and logistic model
# Function for plotting
plotPropFull <- function(proportion, lmmodel, logmodel, expmodel, expoffset,
  label) {
  propPlot <- ggplot(data = data.frame(year = year), aes(x = year)) + 
    geom_line(aes(y = proportion, color = "prop")) + 
    geom_point(aes(y = proportion), color = asrcols[2]) +
    geom_line(aes(y = fitted(lmmodel), colour = "linear")) +
    geom_line(aes(y = fitted(logmodel), colour = "logistic")) +
    geom_line(aes(y = fitted(expmodel)/expoffset, colour = "exponential")) +
    scale_colour_manual(name = "",
      limits = c("prop", "linear", "logistic", "exponential"), 
      values = c(asrcols[2], "black", "blue", "dark green"),
      labels = c("Estimated proportion", "Linear model", 
        "Logistic model", "Exponential model")) + 
    scale_x_continuous(breaks = seq(startYear,                        
      resultsYear, by = 3)) +
    scale_y_continuous(labels = percent) + 
    coord_cartesian(ylim = c(0,1)) +
    ylab(label) + xlab("Year") +  
    PlotOptions() 
  
  return(propPlot)
}

plotProp <- function(proportion, expmodel, expoffset, label, trend = TRUE) {
  propPlot <- ggplot(data = data.frame(year = year), aes(x = year)) + 
    geom_line(aes(y = proportion), color = asrcols[2]) + 
    geom_point(aes(y = proportion), color = asrcols[2]) +
    scale_x_continuous(breaks = seq(startYear,                        
      resultsYear, by = 3)) +
    scale_y_continuous(labels = percent) + 
    coord_cartesian(ylim = c(0,1)) +
    ylab(label) + xlab("Year") +  
    PlotOptions() 
  
  if (trend) {
    propPlot <- propPlot + 
      geom_line(aes(y = fitted(expmodel)/expoffset), colour = "black")
  }
  
  return(propPlot)
}

# Produce plots
diagsPropPlotFull <- plotPropFull(diagnosedProp, diagslmModel, diagsModel, 
  diagsExpModel, expTrendData$infected, "Percentage of\nPLHIV diagnosed")
treatedPropPlotFull <- plotPropFull(artProp, treatedlmModel, treatedModel,
  treatedExpModel, expTrendData$pldhiv, "Percentage diagnosed\non ART")
suppressedPropPlotFull <- plotPropFull(supProp, suppressedlmModel, 
  suppressedModel, suppressedExpModel, expTrendData$numART,
  "Percentage on\nART suppressed")
overallPropPlotFull <- plotPropFull(overallProp, overalllmModel, 
  overallModel, overallExpModel, expTrendData$infected, 
  "Percentage on\nART suppressed")

diagsPropPlot <- plotProp(diagnosedProp, diagsExpModel, 
  expTrendData$infected, "Percentage of\nPLHIV diagnosed", 
  trend = plotTrends)
treatedPropPlot <- plotProp(artProp, treatedExpModel, 
  expTrendData$pldhiv, "Percentage diagnosed\non ART", 
  trend = plotTrends)
suppressedPropPlot <- plotProp(supProp, suppressedExpModel, 
  expTrendData$numART, "Percentage on\nART suppressed", 
  trend = plotTrends)
overallPropPlot <- plotProp(overallProp, overallExpModel,
  expTrendData$infected, "Percentage on\nART suppressed", 
  trend = plotTrends)

trendPlotsProp[["propdiagnosed"]] <- diagsPropPlot
trendPlotsProp[["proptreated"]] <- treatedPropPlot
trendPlotsProp[["propsuppressed"]] <- suppressedPropPlot
trendPlotsProp[["propoverall"]] <- overallPropPlot

# Add linear and Poisson model results to trendCascade
propTrends <- tibble(stage = c("propdiagnosed", "proptreated",
  "propsuppressed", "propoverall"),
  coeff = c(coefflmdiags, coefflmart, coefflmsuppressed, coefflmoverall),
  pvalue = c(p_valuelmdiags, p_valuelmart, p_valuelmsuppressed,
    p_valuelmoverall),
  lower = c(intervallmdiags[1], intervallmart[1], intervallmsuppressed[1],
    intervallmoverall[1]),
  upper = c(intervallmdiags[2], intervallmart[2], intervallmsuppressed[2],
    intervallmoverall[2]),
  model = "linear")

propTrendsExp <- tibble(stage = c("propdiagnosed", "proptreated",
  "propsuppressed", "propoverall"),
  coeff = c(coeffExpdiags, coeffExpart, coeffExpsuppressed, coeffExpoverall),
  pvalue = c(p_valueExpdiags, p_valueExpart, p_valueExpsuppressed,
    p_valueExpoverall),
  lower = c(intervalExpdiags[1], intervalExpart[1], intervalExpsuppressed[1],
    intervalExpoverall[1]),
  upper = c(intervalExpdiags[2], intervalExpart[2], intervalExpsuppressed[2],
    intervalExpoverall[2]),
  model = "poisson-offset")

trendCascadeProp <- bind_rows(propTrends, propTrendsExp)

yLabels <- c(yLabels,
  "propdiagnosed" = "Percentage of\nPLHIV diagnosed", 
  "proptreated" = "Percentage diagnosed\non ART",
  "propsuppressed" = "Percentage on\nART suppressed",
  "propoverall" = "Percentage on\nART suppressed")

# Save plots --------------------------------------------------------------
# Create a group 90-90-90 plot with trend lines
legend <- get_legend(diagsPropPlot)

# Update group plot
combinedPropPlot <- grid.arrange(
  diagsPropPlot + theme(legend.position="none"), 
  treatedPropPlot + theme(legend.position="none"),
  suppressedPropPlot + theme(legend.position="none"), 
  overallPropPlot + theme(legend.position="none"), 
  ncol = 2, nrow = 2) 

stagesPropPlot <- ggdraw() +
  draw_plot(combinedPropPlot, 0, 0, 1, 1) +
  draw_plot_label(c("A", "B", "C", "D"), c(0, 0.5, 0, 0.5),
    c(0.9, 0.9, 0.45, 0.45), size = 12)

figs("unaidsTargets", "Trends in the UNAIDS 90-90-90 and overall targets over 2004-2018.")

if (savePlots) {
  ggsave(file.path(figFolder,
    paste("HIVcascade_Proportion_Trends_",
      toString(startYear), "-",
      toString(resultsYear),
      saveFormat, sep = "")),
    plot = stagesPropPlot, width = 18, height = 15, units = "cm")
}

```

```{r Trends indicators}
# This chunk looks at the trends in cascade indicators: yearly diagnosed 
# fraction (ydf), case detection rate (cdr), infection prevalence ration 
# (ipr). These are calculated from scratch using the cascade results

# Produce the proportions
ydf <- filter(trendData, stage == "diagnoses_include")$value / 
  (filter(trendData, stage == "undiagnosed")$value + 
      filter(trendData, stage == "diagnoses_include")$value)
cdr <- filter(trendData, stage == "diagnoses_include")$value / 
  filter(trendData, stage == "infections")$value
ipr <- filter(trendData, stage == "infections")$value / 
  filter(trendData, stage == "infected")$value

year <- startYear:resultsYear

# Add to trend data and save
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "ydf", value = ydf, lower = NA, upper = NA))
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "cdr", value = cdr, lower = NA, upper = NA))
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "ipr", value = ipr, lower = NA, upper = NA))
trendData <- bind_rows(trendData, tibble(year = year,
  stage = "ydfoffest", 
  value = (filter(trendData, stage == "undiagnosed")$value + 
      filter(trendData, stage == "diagnoses_include")$value), 
  lower = NA, upper = NA))

# if (savePlots) {
#   write_csv(trendData, file.path(figFolder, paste0("HIVcascade_Trend_data_",
#     toString(startYear), "-", toString(resultsYear), ".csv")))
# }

# Poisson models ----------------------------------------------------------
# Use a Poisson model with an offset to produce a rate ratio for the change 
# in the proportion. These are the main models we will use

# trendModelsProp <- list()
# trendPlotsProp <- list()

# Set-up data for Poisson/exponential models
expTrendData <- trendData %>% 
  select(year, stage, value) %>% 
  mutate(value = round(value)) %>%
  tidyr::spread(stage, value)

# Models - using denominator as an offset - explicitly add location of of 
# offset so segmented fits work: https://stackoverflow.com/questions/19034403/r-package-segmented-with-an-offset-term
ydfModel <- glm(diagnoses_include ~ year, offset = log(ydfoffest), 
  data = expTrendData, family = "poisson")
cdrModel  <- glm(diagnoses_include ~ year, offset = log(infections),
  data = expTrendData, family = "poisson")
iprModel  <- glm(infections ~ year, offset = log(infected), 
  data = expTrendData, family = "poisson")

trendModelsProp[["ydf"]] <- ydfModel
trendModelsProp[["cdr"]] <- cdrModel
trendModelsProp[["ipr"]] <- iprModel

# Coefficients for annual change (as rate ratio)
coeffydf <- exp(coef(ydfModel)["year"])
coeffcdr <- exp(coef(cdrModel)["year"])
coeffipr <- exp(coef(iprModel)["year"])

# P-values for annual change
p_valueydf <- summary(ydfModel)$coefficients["year", "Pr(>|z|)"]
p_valuecdr <- summary(cdrModel)$coefficients["year", "Pr(>|z|)"]
p_valueipr <- summary(iprModel)$coefficients["year",
  "Pr(>|z|)"]

# Confidence interval for annual change (as a rate ratio)
intervalydf <- exp(confint(ydfModel, "year", type = "Wald"))
intervalcdr <- exp(confint(cdrModel, "year", type = "Wald"))
intervalipr <- exp(confint(iprModel, "year", 
  type = "Wald"))

# Plots of estimates and trends ------------------------------------------------

ydfPlot <- plotProp(ydf, ydfModel, expTrendData$ydfoffest, "YDF", 
  trend = plotTrends)
cdrPropPlot <- plotProp(cdr, cdrModel, 
  expTrendData$infections, "CDR", 
  trend = plotTrends) +
  # Fix up y axis - will get warnings about replacement
  scale_y_continuous(labels = number) +
  coord_cartesian(ylim = c(0,NA))
iprPlot <- plotProp(ipr, iprModel, 
  expTrendData$infected, "IPR", 
  trend = plotTrends)

trendPlotsProp[["ydf"]] <- ydfPlot
trendPlotsProp[["cdr"]] <- cdrPropPlot
trendPlotsProp[["ipr"]] <- iprPlot

# Poisson model results to trendCascadeProp
propTrendsIndicators <- tibble(stage = c("ydf", "cdr", "ipr"),
  coeff = c(coeffydf, coeffcdr, coeffipr),
  pvalue = c(p_valueydf, p_valuecdr, p_valueipr),
  lower = c(intervalydf[1], intervalcdr[1], intervalipr[1]),
  upper = c(intervalydf[2], intervalcdr[2], intervalipr[2]),
  model = "poisson-offset")

trendCascadeProp <- bind_rows(trendCascadeProp, propTrendsIndicators)

yLabels <- c(yLabels,
  "ydf" = "YDF", 
  "cdr" = "CDR",
  "ipr" = "IPR")

```

```{r Save trends objects}
# Save main trend storage variables for ease of loading later
save(trendData,
  file = file.path(figFolder, "CascadeTrendData.Rda"))
save(trendCascade, trendModels, trendCascadeProp, trendModelsProp, 
  file = file.path(figFolder, "CascadeTrendModels.Rda"))

```

```{r Trends table}
# Write the trends diagnostics to file
if (savePlots) {
  trendCascade$model <- "poisson"
  trendCascade <- bind_rows(trendCascade, trendCascadeProp)
  
  write_csv(trendCascade, file.path(figFolder, 
    paste0("HIVcascade_trends_", 
      toString(startYear), "-", toString(resultsYear), ".csv")))
}
```

# Exploration of breakpoints

In this section we start exploring the annual estimates for each cascade 
step and indicator for the presence for change or break points. 

We first tried the approach within the changepoint package. This was not 
really useful for trends that are increasing or decreasing as it looks 
forchanges in mean (or variance) rather than slope. Here we just look for
one changepoint using the mean.

The main analysis was done using the breakpoints() function in the 
strucchange package. As there are only 14 time points of data we have to 
set h = 3 (the minimal number of points in each segment for a linear 
regression to be fitted) for the function to work. Given there are only 14 data
points any models with >= 2 breakpoints are unlikely to be statistically 
robust and are more likely reflect over-fitting. 

```{r Breakpoints}
# This chunk is used to explore if structural break points might be 
# present. The packages here use linear regression. Poisson regression is more
# appropriate but the results give a good summary of where breakpoints might
# occur and can inform initial assumptions for the segmented Poisson approach
# below. 

# Load key libraries
LoadLibrary(tseries)
LoadLibrary(forecast)
LoadLibrary(strucchange)
LoadLibrary(ggfortify) # enable timeseries in autoplot
LoadLibrary(changepoint) # Not really used

# Set up data -------------------------------------------------------------
# Covert everything into a time series which is more useful in the
# strucchange package functions. This means results are rounded to the
# nearest year

tots <- function(indicator) {
  return(ts(filter(trendData, stage == indicator)$value,
    start = c(startYear, 1), end = c(resultsYear, 1),
    frequency = 1)) 
}

infectedts <- tots("infected")
pldhivts <- tots("pldhiv")
numARTts <- tots("numART")
suppressedts <- tots("suppressed")
undiagnosedts <- tots("undiagnosed")
noARTts <- tots("noART")
unsuppressedts <- tots("unsuppressed")
diagnoses_excludets <- tots("diagnoses_exclude")
diagnoses_includets <- tots("diagnoses_include")
infectionsts <- tots("infections")
propdiagnosedts <- tots("propdiagnosed")
proptreatedts <- tots("proptreated")
propsuppressedts <- tots("propsuppressed")
propoverallts <- tots("propoverall")
ydfts <- tots("ydf")
cdrts <- tots("cdr")
iprts <- tots("ipr")

data <- cbind(infectedts, pldhivts, numARTts, suppressedts, undiagnosedts,
  noARTts, unsuppressedts, diagnoses_excludets, diagnoses_includets,
  infectionsts, propdiagnosedts, proptreatedts, propsuppressedts, propoverallts,
  ydfts, cdrts, iprts)
colnames(data) <- c("infected", "pldhiv", "numART", "suppressed",
  "undiagnosed","noART", "unsuppressed", "diagnoses_exclude",
  "diagnoses_include", "infections", "propdiagnosed", "proptreated",
  "propsuppressed", "propoverall", "ydf", "cdr", "ipr")
data <- window(data, start = c(startYear, 1), end = c(resultsYear, 1))

# Search for changepoints -------------------------------------------------
# Using the changepoint package. 
autoplot(cpt.mean(infectedts))
autoplot(cpt.mean(pldhivts))
autoplot(cpt.mean(numARTts))
autoplot(cpt.mean(suppressedts))
autoplot(cpt.mean(undiagnosedts))
autoplot(cpt.mean(noARTts))
autoplot(cpt.mean(unsuppressedts))
autoplot(cpt.mean(diagnoses_excludets))
autoplot(cpt.mean(diagnoses_includets))
autoplot(cpt.mean(propdiagnosedts))
autoplot(cpt.mean(proptreatedts))
autoplot(cpt.mean(propsuppressedts))
autoplot(cpt.mean(propoverallts))
autoplot(cpt.mean(ydfts))
autoplot(cpt.mean(cdrts))
autoplot(cpt.mean(iprts))

# Search for breakpoints --------------------------------------------------
# The following code looks for breakpoints in each indicator using the 
# breakpoints() function in the strucchange package which uses linear 
# regression.  

BPindicator <- function(indicator, tsdata) {
  bpIndicator <- breakpoints(data[, indicator] ~ years, data = data, h = 3)
  print(summary(bpIndicator))
  
  autoplot(bpIndicator)
  plot(bpIndicator)
  plot(tsdata)
  lines(bpIndicator)
  try(lines(confint(bpIndicator))) # CIs might not be able to be calculated
  lines(fitted(bpIndicator, breaks = 1), col = 4)
  lines(fitted(bpIndicator, breaks = 2), col = 2)
  lines(fitted(bpIndicator, breaks = 3), col = 3)
  
  return(bpIndicator)
  
}

bpInfected <- BPindicator("infected", infectedts)
bpPldhiv <- BPindicator("pldhiv", pldhivts)
bpNumART <- BPindicator("numART", numARTts)
bpSuppressed <- BPindicator("suppressed", suppressedts)
bpUndiagnosed <- BPindicator("undiagnosed", undiagnosedts)
bpNoART <- BPindicator("noART", noARTts)
bpUnsuppressed <- BPindicator("unsuppressed", unsuppressedts)
bpDiagnoses_exclude <- BPindicator("diagnoses_exclude", diagnoses_excludets)
bpDiagnoses_include <- BPindicator("diagnoses_include", diagnoses_includets)
bpInfections <- BPindicator("infections", infectionsts)
bpPropdiagnosed <- BPindicator("propdiagnosed", propdiagnosedts)
bpProptreated <- BPindicator("proptreated", proptreatedts)
bpPropsuppressed <- BPindicator("propsuppressed", propsuppressedts)
bpPropoverall <- BPindicator("propoverall", propoverallts)
bpYdf <- BPindicator("ydf", ydfts)
bpCdr <- BPindicator("cdr", cdrts)
bpIpr <- BPindicator("ipr", iprts)

```

```{r Breakpoints table}
# Create table of summary results ----------------------------------------
breakTable <- NULL

bpmodels <- list(bpInfected, bpPldhiv, bpNumART, bpSuppressed, bpUndiagnosed,
  bpNoART, bpUnsuppressed, bpDiagnoses_exclude, bpDiagnoses_include, 
  bpInfections, bpPropdiagnosed, bpProptreated, bpPropsuppressed, 
  bpPropoverall, bpYdf, bpCdr, bpIpr)
modelNames <- colnames(data)
modelString <- c("Number infected",
  "Number diagnosed", 
  "Number on ART",
  "Number suppressed", 
  "Number undiagnosed",
  "Diagnosed but untreated",
  "On ART but unsuppressed",
  "Diagnoses excluding OS",
  "Diagnoses including OS",
  "Annual new infections",
  "Proportion undiagnosed", 
  "Proportion diagnosed treated",
  "Proportion treated suppressed",
  "Proportion suppressed overall",
  "Yearly diagnosed fraction",
  "Case detection rate",
  "Incidence prevalence ratio")

# NOTE: confidence interval calculation will produce lots of warnings if it
# can't be calculated (returns NA)

for (ii in 1:length(modelNames)) {
  tempbp <- bpmodels[[ii]]
  
  tempDf <- data.frame(step = character(5),
    indicator = character(5),
    break0 = integer(5),
    break1 = integer(5),
    break1ci = character(5),
    break2 = integer(5),
    break2ci = character(5),
    break3 = character(5),
    break3ci = character(5))
  
  
  tempDf$step <- rep(modelString[ii], 5)
  tempDf$indicator <- c("breakpoint1", "breakpoint2", "breakpoint3", "rss",
    "bic")
  
  tempDf$break0 <- c(NA, NA, NA, 
    breakpoints(tempbp, breaks = 1)$RSS,
    BIC(breakpoints(tempbp, breaks = 0)))
  
  tempDf$break1 <- c(years[breakpoints(tempbp, breaks = 1)$breakpoints],
    NA, NA,
    breakpoints(tempbp, breaks = 1)$RSS,
    BIC(breakpoints(tempbp, breaks = 1)))
  
  tempDf$break1ci <- c(paste0("(", 
    years[confint(tempbp, breaks = 1)$confint[1]],
    ", ",
    years[confint(tempbp, breaks = 1)$confint[3]],
    ")"), rep("NA", 4))
  
  tempDf$break2 <- c(years[breakpoints(tempbp, breaks = 2)$breakpoints],
    NA, 
    breakpoints(tempbp, breaks = 2)$RSS,
    BIC(breakpoints(tempbp, breaks = 2)))
  
  tempDf$break2ci <- c(paste0("(", 
    years[confint(tempbp, breaks = 2)$confint[1, 1]],
    ", ",
    years[confint(tempbp, breaks = 2)$confint[1, 3]],
    ")"), 
    paste0("(", 
      years[confint(tempbp, breaks = 2)$confint[2, 1]],
      ", ",
      years[confint(tempbp, breaks = 2)$confint[2, 3]],
      ")"),
    rep("NA", 3))
  
  tempDf$break3 <- c(years[breakpoints(tempbp, breaks = 3)$breakpoints],
    breakpoints(tempbp, breaks = 3)$RSS,
    BIC(breakpoints(tempbp, breaks = 3)))
  
  tempDf$break3ci <- c(paste0("(", 
    years[confint(tempbp, breaks = 3)$confint[1, 1]],
    ", ",
    years[confint(tempbp, breaks = 3)$confint[1, 3]],
    ")"), 
    paste0("(", 
      years[confint(tempbp, breaks = 3)$confint[2, 1]],
      ", ",
      years[confint(tempbp, breaks = 3)$confint[2, 3]],
      ")"),
    paste0("(", 
      years[confint(tempbp, breaks = 3)$confint[3, 1]],
      ", ",
      years[confint(tempbp, breaks = 3)$confint[3, 3]],
      ")"),
    rep("NA", 2))
  
  breakTable <- bind_rows(breakTable, tempDf)
  
}

if (savePlots) {
  write_csv(breakTable, file.path(figFolder, 
    paste0("HIVcascade_", "breakpoints_", 
      toString(startYear), "-", toString(resultsYear), ".csv")))
}

```

# Segmented trends

This section explores the trends in each step of the HIV cascade and 
notifications using a segmented Poisson regression which allows the 
presence of a continuous change point. To perform this analysis requires an
initial estimate for the location of the change point. Used the previous 
analyses and visual inspection to inform this for this estimate but varied 
the estimate from 2007 to 2013. This produced no change in the fitted 
curve. 

```{r Segmented trends}
# This chuck is used to explore the change in trends for each cascade step, gap,
# and indicator. Some seem to have a change point. We try to find a change point
# for each stage using the segmented package and with Poisson models. Note
# if one change point is not found using the segmented package then the 
# Poisson model is plotted instead (suggests it is a better model). 

LoadLibrary(segmented)

segmentStages <- c(names(trendModels), names(trendModelsProp))

segCI <- function(est, stdErr) {
  return(c(est - 1.96 * stdErr, est + 1.96 * stdErr))
}

allTrendModels <- c(trendModels, trendModelsProp)

# Function for producing results -----------------------------------------------
Segment <- function(indicator, initialbp, ymax, yLabel, offset = 1, 
  save = FALSE) {
  
  tempData <- filter(trendData, stage == indicator)
  
  # Get original model
  pmodel <- allTrendModels[[indicator]]
  
  # Generate segmented models - if unable to find checkpoint then error is
  # found and model becomes to straight Poisson model (0 change points)
  segModel1 <- tryCatch(segmented(pmodel, seg.Z = ~year, 
    psi = list(year = initialbp[[1]])),
    error = function(err) {
      print(paste0(indicator, ": Error in segmented model 1"))
      segModel1 <- pmodel
    })
  
  segModel2 <- tryCatch(segmented(pmodel, seg.Z = ~year, 
    psi = list(year = initialbp[[2]])),
    error = function(err) {
      print(paste0(indicator, ": Error in segmented model 2"))
      segModel2 <- pmodel
    })  
  
  segModel3 <- tryCatch(segmented(pmodel, seg.Z = ~year, 
    psi = list(year = initialbp[[3]])),
    error = function(err) {
      print(paste0(indicator, ": Error in segmented model 3"))
      segModel3 <- pmodel
    })
  
  segModel4 <- tryCatch(segmented(pmodel, seg.Z = ~year, 
    psi = list(year = initialbp[[4]])),
    error = function(err) {
      print(paste0(indicator, ": Error in segmented model 4"))
      segModel4 <- pmodel
    })
  
  # Calculate and save breakpoints for each model
  modelBreakpoints <- tibble(model = c("pmodel", "segModel1", 
    "segModel2", "segModel2", "segModel3", "segModel3", "segModel3",
    "segModel4", "segModel4", "segModel4", "segModel4"),
    estimate = 0,
    lower = 0,
    upper = 0)
  
  if (class(segModel1)[1] == "segmented") {
    modelBreakpoints$estimate[2] <- unname(segModel1$psi[,"Est."])
    modelBreakpoints$lower[2] <- segCI(segModel1$psi[, "Est."], 
      segModel1$psi[, "St.Err"])[1]
    modelBreakpoints$upper[2] <- segCI(segModel1$psi[, "Est."], 
      segModel1$psi[, "St.Err"])[2]
  }
  if (class(segModel2)[1] == "segmented") {
    modelBreakpoints$estimate[3:4] <- unname(segModel2$psi[,"Est."])
    modelBreakpoints$lower[3:4] <- segCI(segModel2$psi[, "Est."], 
      segModel2$psi[, "St.Err"])[1:2]
    modelBreakpoints$upper[3:4] <- segCI(segModel2$psi[, "Est."], 
      segModel2$psi[, "St.Err"])[3:4]
  }
  if (class(segModel3)[1] == "segmented") {
    modelBreakpoints$estimate[5:7] <- unname(segModel3$psi[,"Est."])
    modelBreakpoints$lower[5:7] <- segCI(segModel3$psi[, "Est."], 
      segModel3$psi[, "St.Err"])[1:3]
    modelBreakpoints$upper[5:7] <- segCI(segModel3$psi[, "Est."], 
      segModel3$psi[, "St.Err"])[4:6]
  }
  
  if (class(segModel4)[1] == "segmented") {
    modelBreakpoints$estimate[8:11] <- unname(segModel4$psi[,"Est."])
    modelBreakpoints$lower[8:11] <- segCI(segModel4$psi[, "Est."], 
      segModel4$psi[, "St.Err"])[1:4]
    modelBreakpoints$upper[8:11] <- segCI(segModel4$psi[, "Est."], 
      segModel4$psi[, "St.Err"])[5:8]
  }
  
  # Calculate and save slopes for each model
  modelSlopes <- tibble(model = c("pmodel", "segModel1", "segModel1", 
    "segModel2", "segModel2", "segModel2", "segModel3", "segModel3",
    "segModel3", "segModel3", "segModel4", "segModel4", "segModel4", 
    "segModel4", "segModel4"),
    estimate = 0,
    lower = 0,
    upper = 0)
  
  modelSlopes$estimate[1] <- exp(unname(coef(pmodel)[2]))
  modelSlopes$lower[1] <- exp(confint(pmodel, "year", type = "Wald"))[1]
  modelSlopes$upper[1] <- exp(confint(pmodel, "year", type = "Wald"))[2]
  
  if (class(segModel1)[1] == "segmented") {
    modelSlopes$estimate[2:3] <- exp(slope(segModel1)$year[,1])
    modelSlopes$lower[2:3] <- exp(slope(segModel1)$year[,"CI(95%).l"])
    modelSlopes$upper[2:3] <- exp(slope(segModel1)$year[,"CI(95%).u"])
  }
  if (class(segModel2)[1] == "segmented") {
    modelSlopes$estimate[4:6] <- exp(slope(segModel2)$year[,1])
    modelSlopes$lower[4:6] <- exp(slope(segModel2)$year[,"CI(95%).l"])
    modelSlopes$upper[4:6] <- exp(slope(segModel2)$year[,"CI(95%).u"])
  }
  if (class(segModel3)[1] == "segmented") {
    modelSlopes$estimate[7:10] <- exp(slope(segModel3)$year[,1])
    modelSlopes$lower[7:10] <- exp(slope(segModel3)$year[,"CI(95%).l"])
    modelSlopes$upper[7:10] <- exp(slope(segModel3)$year[,"CI(95%).u"])
  }
  
  if (class(segModel4)[1] == "segmented") {
    modelSlopes$estimate[11:15] <- exp(slope(segModel4)$year[,1])
    modelSlopes$lower[11:15] <- exp(slope(segModel4)$year[,"CI(95%).l"])
    modelSlopes$upper[11:15] <- exp(slope(segModel4)$year[,"CI(95%).u"])
  }
  
  # Calculate and save AIC and BIC values
  aicValues <- c(AIC(pmodel), AIC(segModel1), AIC(segModel2), AIC(segModel3),
    AIC(segModel4))
  bicValues <- c(BIC(pmodel), BIC(segModel1), BIC(segModel2), BIC(segModel3),
    BIC(segModel4))
  bicStr <- round(bicValues, digits = 1)
  
  modelData <- data.frame(year = tempData$year, 
    overall = fitted(pmodel)/offset,
    segvalue1 = fitted(segModel1)/offset, 
    segvalue2 = fitted(segModel2)/offset,
    segvalue3 = fitted(segModel3)/offset,
    segvalue4 = fitted(segModel4)/offset)
  
  # Create plot
  segPlotAll <- ggplot(data = tempData, 
    aes(x = year, y = value)) + 
    geom_line(aes(color = "estimates")) + 
    geom_point(color = asrcols[2]) +
    geom_line(data = modelData, aes(y = overall,
      colour = "overall")) +
    geom_line(data = modelData, aes(y = segvalue1, 
      colour = "segment1")) + 
    geom_line(data = modelData, aes(y = segvalue2, 
      colour = "segment2")) + 
    geom_line(data = modelData, aes(y = segvalue3,
      colour = "segment3")) +
    geom_line(data = modelData, aes(y = segvalue4,
      colour = "segment4")) +
    scale_x_continuous(breaks = seq(startYear, resultsYear),
      labels =  EveryNth(seq(startYear, resultsYear), 3, inverse = TRUE),
      limits = c(startYear, resultsYear), 
      expand = c(0,0)) +
    scale_y_continuous(labels = comma) + 
    scale_colour_manual("", values = c(asrcols[2], "black", "blue", 
      "darkgreen", "purple", "orange"),
      limits = c("estimates", "overall", "segment1", "segment2", "segment3",
        "segment4"),
      labels = c("Estimates", "Overall", "One change point", 
        "Two change points", "Three change points",
        "Four change points")) +
    coord_cartesian(ylim = c(0, ymax)) + 
    ylab(yLabel) + xlab("Year") +  
    PlotOptions() + theme(legend.position = "right") + 
    geom_text(x = 2012, y = 0.05 * ymax, 
      label = sprintf("BIC values\nOverall %s; One CP %s; Two CPs %s;\nThree CPs  %s; Four CPs %s.", 
        bicStr[1], bicStr[2], bicStr[3], bicStr[4], bicStr[5]), size = 3)
  
  # Select the model with the lowest BIC and plot
  segModels <- list(pmodel, segModel1, segModel2, segModel3, segModel4)
  minBic <- which.min(bicValues)
  bestModel <- segModels[[minBic]]
  bestModelData <- select(modelData, c(1, minBic + 1)) 
  colnames(bestModelData)[2] <- "value"
  
  segPlotBest <- ggplot(data = tempData, 
    aes(x = year, y = value)) + 
    geom_line(aes(color = "estimates")) + 
    geom_point(color = asrcols[2]) +
    geom_line(data = bestModelData, aes(y = value,
      colour = "best")) + 
    scale_x_continuous(breaks = seq(startYear, resultsYear),
      labels =  EveryNth(seq(startYear, resultsYear), 3, inverse = TRUE),
      limits = c(startYear, resultsYear), 
      expand = c(0,0)) +
    scale_y_continuous(labels = comma) + 
    scale_colour_manual("", values = c(asrcols[2], "black"), 
      limits = c("estimates", "best"), 
      labels = c("Estimates", "Best fit")) +
    coord_cartesian(ylim = c(0, ymax)) + 
    ylab(yLabel) + xlab("Year") +  
    PlotOptions() 
  
  if (save) {
    # Save the current plot
    ggsave(file.path(figFolder, paste0("HIVcascade-Trends-", indicator,
      "-Segment-All_",
      toString(startYear), "-",
      toString(resultsYear),
      saveFormat)),
      plot = segPlotAll, width = 16, height = 12, units = "cm")
  }
  
  return(list(models = segModels,
    fitted = modelData, breakpoints = modelBreakpoints, slopes = modelSlopes, 
    aic = aicValues, bic = bicValues, 
    plotall = segPlotAll, plotBest = segPlotBest))
}

# Find breakpoints -------------------------------------------------------------
# Initial break point estimates - use trial and error based on 
# breakpoints() results and visual inspection and to test for sensitivity by 
# varying.

initialbp <- list(2010, c(2007, 2016), c(2007, 2012, 2016),
  c(2006, 2010, 2013, 2017))

# Y axis range for each model
ymax <- c("infected" = 35000,
  "pldhiv" = 35000,
  "numART" = 35000, 
  "suppressed" = 35000,
  "undiagnosed" = 3500, 
  "noART" = 6500, 
  "unsuppressed" = 4500,
  "diagnoses_exclude" = 1500,
  "diagnoses_include" = 1500,
  "infections" = 1500, 
  "propdiagnosed" = 1, 
  "proptreated" = 1,       
  "propsuppressed" = 1,
  "propoverall" = 1,
  "ydf" = 1,  
  "cdr"=  2,
  "ipr" = 0.1)

offsets <- list("infected" = 1,
  "pldhiv" = 1,
  "numART" = 1, 
  "suppressed" = 1,
  "undiagnosed" = 1, 
  "noART" = 1, 
  "unsuppressed" = 1,
  "diagnoses_exclude" = 1,
  "diagnoses_include" = 1,
  "infections" = 1, 
  "propdiagnosed" = expTrendData$infected, 
  "proptreated" = expTrendData$pldhiv,       
  "propsuppressed" = expTrendData$numART,
  "propoverall" = expTrendData$infected,
  "ydf" = expTrendData$ydfoffest,
  "cdr"=  expTrendData$infections,
  "ipr" = expTrendData$infected)

# Generate results -------------------------------------------------------------

steps <- names(ymax)
segResults <- list()

for (ii in steps) {
  print(ii)
  segResults[[ii]] <- Segment(ii, initialbp, ymax[ii],
    yLabels[ii], save = TRUE, offset = offsets[[ii]])
}

save(segResults, file = file.path(figFolder, "CascadeSegmentedModels.Rda"))

```

```{r Produce combined plots} 

# Figure caption
figs("segmentedTrends", "")

legend <- get_legend(segResults[[1]]$plotall)

# Update group plot
combinedPlot <- grid.arrange(legend, 
  segResults[[1]]$plotall + theme(legend.position="none"), 
  segResults[[2]]$plotall + theme(legend.position="none"),
  segResults[[3]]$plotall + theme(legend.position="none"), 
  ncol = 2, nrow = 3, 
  layout_matrix = rbind(c(1, 1), c(2, 3), c(4, 5))) #,
  # widths = c(4, 4), heights = c(0.8, 3.1, 3.1))

stagesDiffsPlot2 <- ggdraw() +
  draw_plot(combinedPlot, 0, 0, 1, 1) +
  draw_plot_label(c("A", "B", "C"), c(0, 0.5, 0),
    c(0.9, 0.9, 0.45), size = 12)


# Save combined plot-------------------------------------------------------
if (savePlots) {
  ggsave(file.path(figFolder,
    paste("HIVcascade-Differences-Trends_Segment",
      toString(startYear), "-",
      toString(resultsYear),
      saveFormat, sep = "")),
    plot = stagesDiffsPlot2, width = 18, height = 15, units = "cm")
}

```

# Testing code =================================================================

The following sections were primarily used for testing and deciding on the best
approach to evaluating the trends. They are mostly superfluous now but have been
kept in this script for storage and safe keeping in case the code becomes useful
at a later date

# Chow and interaction tests of detected change points (DEPRECATED)

This section applies some statistical tests for the segmented model to test 
for the robustness of any change points and produces a number of summary 
results. 

The main test is a Chow test (https://en.wikipedia.org/wiki/Chow_test) we 
calculate this from first principles based on the code from  
https://thetarzan.wordpress.com/2011/06/16/the-chow-test-in-r-a-case-study-of-yellowstones-old-faithful-geyser/

We also looked at the difference on the slopes before and after the change 
point using an interaction model and performed a Wald test on the slopes 
returning the p-value. This test only tests if the difference between the 
slope parameters is different to zero as decribed here:  
https://andrewpwheeler.wordpress.com/2016/10/19/testing-the-equality-of-two-regression-coefficients/

*NOTE:* While the script below runs the estimates seem a bit funny for some
indicators! I haven't explored the reasons for this because I have decided to 
use the BIC to obtain best fitting change point model.

```{r Chow and interaction tests}
# This chunk runs chow and interaction tests for each intermediate
# cascade step. 
LoadLibrary(aod)

# Functions for testing segemented models ---------------------------------
pchow <- function(overalldata, model, premodel, postmodel) {
  # Computes the Chow test statistic (F-test) and pvalue
  
  # Calculate sum of squared residuals for each regression
  SSR <- NULL
  SSR$all <- model$residuals^2
  SSR$pre <- premodel$residuals^2
  SSR$post <- postmodel$residuals^2
  
  # K is the number of regressors in our model
  k <-  model$rank
  
  # Computing the Chow test statistic (F-test):
  numerator = (sum(SSR$all) - (sum(SSR$pre) + sum(SSR$post))) / k
  denominator = (sum(SSR$pre) + sum(SSR$post)) / 
    (nrow(overalldata) - 2 * k)
  chow = numerator / denominator
  chow
  
  # Calculate P-value using F test
  pchow <- 1 - pf(chow, k, (nrow(overalldata) - 2 * k))
  return(pchow)
} 

pslopes <- function(overalldata, cutpoint) {
  # This function produces an interaction model and performs a Wald test 
  # on the slopes returning the p-value
  
  interactData <- overalldata %>%
    mutate(ypre = ifelse(year <= cutpoint, year, 0),
      ypost = ifelse(year > cutpoint, year, 0),
      ipre = ifelse(year <= cutpoint, 1, 0),
      ipost = ifelse(year > cutpoint, 1, 0))
  
  # Model 
  intModel <- glm(round(value) ~ ypre + ypost + ipre, #+ ipost gives NA
    data = interactData, 
    family = "poisson")
  
  
  # Calculate the Wald ststatistic and p-value
  theta <- coef(intModel)[2:3] # KEEP AS COEFFICIENTS
  v <- vcov(intModel)[2:3, 2:3]
  diff <- theta[1] - theta[2] # Difference in parameters
  varAB <- sqrt(v[1,1] + v[2,2] - 2 * v[2,1])
  wstat <- diff/varAB # Stat sig if abs > 2 (2 sided p-value treating 
  # wstat as z-score in normal distribution
  pwstat <- 2*pnorm(-abs(wstat)) # test stat from normal
  return(list(model = intModel, wstat = wstat, pwstat = pwstat))
}

selectBreakpoint <- function(indicator, nbreakpoints, breakpoint_number, 
  offset) {
  # This function simply retrieves the correct information for each 
  # breakpoint
  
  indicatorData <- trendData %>%
    filter(stage == indicator) %>% 
    select(year, value) %>%
    mutate(offset = 1)
  
  if (offset[1] > 0) {
    indicatorData$offset <- offset
  }
  
  breakpoint <- 0
  preData <- 0
  postData <- 0
  
  if (nbreakpoints == 1) {
    breakpoint <- filter(segResults[[indicator]]$breakpoints, 
      model == "segModel1")$estimate
    if (breakpoint != 0) {
      preData <- filter(indicatorData, year <= breakpoint)
      postData <- filter(indicatorData, year > breakpoint)
    } 
  } else if (nbreakpoints == 2) {
    breakpoint <- filter(segResults[[indicator]]$breakpoints, 
      model == "segModel2")$estimate
    if (breakpoint[1] != 0) {
      if (breakpoint_number == 1) {
        preData <- filter(indicatorData, year <= breakpoint[1])
        postData <- filter(indicatorData, year > breakpoint[1], 
          year <= breakpoint[2])
      } else {
        # Second breakpoint
        preData <- filter(indicatorData, year > breakpoint[1], 
          year <= breakpoint[2])
        postData <- filter(indicatorData, year > breakpoint[2])
      }
      breakpoint <- breakpoint[breakpoint_number]
    }
  } else if (nbreakpoints == 3) {
    breakpoint <- filter(segResults[[indicator]]$breakpoints, 
      model == "segModel3")$estimate
    
    if (breakpoint[1] != 0) {
      if (breakpoint_number == 1) {
        preData <- filter(indicatorData, year <= breakpoint[1])
        postData <- filter(indicatorData, year > breakpoint[1], 
          year <= breakpoint[2])
      } else if (breakpoint_number == 2) {
        preData <- filter(indicatorData, year > breakpoint[1], 
          year <= breakpoint[2])
        postData <- filter(indicatorData, year > breakpoint[2], 
          year <= breakpoint[3])
      } else {
        # Third breakpoint
        preData <- filter(indicatorData, year > breakpoint[2], 
          year <= breakpoint[3])
        postData <- filter(indicatorData, year > breakpoint[3])
      }
      breakpoint <- breakpoint[breakpoint_number]
    }
  } else if (nbreakpoints == 4) {
    breakpoint <- filter(segResults[[indicator]]$breakpoints, 
      model == "segModel4")$estimate
    
    if (breakpoint[1] != 0) {
      if (breakpoint_number == 1) {
        preData <- filter(indicatorData, year <= breakpoint[1])
        postData <- filter(indicatorData, year > breakpoint[1], 
          year <= breakpoint[2])
      } else if (breakpoint_number == 2) {
        preData <- filter(indicatorData, year > breakpoint[1], 
          year <= breakpoint[2])
        postData <- filter(indicatorData, year > breakpoint[2], 
          year <= breakpoint[3])
      } else if (breakpoint_number == 3) {
        # Third breakpoint
        preData <- filter(indicatorData, year > breakpoint[2], 
          year <= breakpoint[3])
        postData <- filter(indicatorData, year > breakpoint[3],
          year <= breakpoint[4])
      } else {
        # fourth breakpoint
        preData <- filter(indicatorData, year > breakpoint[3], 
          year <= breakpoint[4])
        postData <- filter(indicatorData, year > breakpoint[4])
      }
      
      breakpoint <- breakpoint[breakpoint_number]
    }
  }
  
  output <- list(indicator = indicator, breakpoint = breakpoint, 
    pre_data = preData, post_data = postData)
  
  return(output)
}

prepostModels <- function(preData, postData, offset) {
  # This function produces the independent pre and post models
  # for the chow test and other testing 
  segModelPre <- glm(round(value) ~ year, data = preData, 
    offset = log(offset),
    family = "poisson")
  segModelPost <- glm(round(value) ~ year, data = postData, 
    offset = log(offset),
    family = "poisson")
  
  return(list(premodel = segModelPre, postmodel = segModelPost))
}

# Loop over each step and breakpoint store -------------------------------------

modelTable <- tibble()

for (ii in steps) {
  print(ii)
  results <- segResults[[ii]]
  
  tempTable <- results$breakpoints %>%
    mutate(indicator = ii) %>%
    select(indicator, model, breakpoint = estimate)
  
  tempTable$pchow <- 0
  tempTable$pslopes <- 0
  
  for (jj in 2:nrow(tempTable)) {
    print(jj)
    if (jj == 2) {
      nbreaks <- 1
      nbreak <- 1
    } else if (jj == 3) {
      nbreaks <- 2
      nbreak <- 1
    } else if (jj == 4) {
      nbreaks <- 2
      nbreak <- 2
    } else if (jj == 5) {
      nbreaks <- 3
      nbreak <- 1
    } else if (jj == 6) {
      nbreaks <- 3
      nbreak <- 2
    } else if (jj == 7) { 
      nbreaks <- 3
      nbreak <- 3
    } else if (jj == 8) { 
      nbreaks <- 4
      nbreak <- 1
    } else if (jj == 9) { 
      nbreaks <- 4
      nbreak <- 2
    } else if (jj == 10) { 
      nbreaks <- 4
      nbreak <- 3
    } else if (jj == 11) { 
      nbreaks <- 4
      nbreak <- 4
    }
    
    temp <- selectBreakpoint(ii, nbreaks, nbreak, offsets[[ii]])
    if (temp$breakpoint[1] != 0) {
      chowModels <- prepostModels(temp$pre_data, temp$post_data, offsets[[ii]])
      
      overalldata <- bind_rows(temp$pre_data, temp$post_data)
      model <- glm(value ~ year, offset = log(offset), 
        data = overalldata, family = "poisson")
      
      tempTable$pchow[jj] <- pchow(overalldata, model, chowModels$premodel, 
        chowModels$postmodel)
      
      tempTable$pslopes[jj] <- pslopes(overalldata, temp$breakpoint)$pwstat
    }
  }
  
  modelTable <- bind_rows(modelTable, tempTable)
}

# Save as table -----------------------------------------------------------
if (savePlots) {
  
  write_csv(modelTable, file.path(figFolder,
    paste0("HIVcascade_trend_breakpoints_", 
      toString(startYear), "-", toString(resultsYear), ".csv")))
}

```

# Sensitivity of diagnosed untreated changepoint

Given the diagnosed not on ART trends shows very clear change points we 
explored the robustness of the change points to assumptions about the number
on treatment. One detected change point is close to the point where the ART
estimates transition from AHOD to PBS based. 

In this section we explore the impact of varying the ART estimates for 
2011, prior to 2012 and overall on the segmented model and change point 
detected. 

```{r Test noART breakpoint}
# This chunk is used to look at the sensitivity of the noART changepoint
# by using different estimates for the number on ART. 

# Original estimates for noART
noARTorig <- filter(resultsAll, stage == "pldhiv")$value - 
  filter(resultsAll, stage == "numART")$value

# Load the ART_Estimates_2014 file with the various fit options for merging
# the AHOD and PBS + temporary residents data. Need to specifiy which ART
# estimates (specifically temporary estimates number) we are using in 
# the treatment data merging.
addTempRes <- TRUE # Add estimates for temporary residents on ART
atrasTRest <- TRUE # Use ATRAS estimates, FALSE = NAPWHA estimates
# See 0-ArtAnalysis.Rmd for details
# FALSE for ASR and TRUE for paper

if (addTempRes) {
  trString <- ifelse(atrasTRest,"ATRAS", "NAPWHA")
} else {
  trString <- "PBS"
}

artEstimates <- read.csv(file.path(resultsFolder,"..",
  paste0("ART_Estimates-2017-",
    trString, ".csv")))

artDiffs <- list()

# Original estimates
artDiffs[[1]] <- filter(resultsAll, stage == "pldhiv")$value - 
  filter(resultsAll, stage == "numART")$value

# First test - replace 2011 ART value with fitted 2011 value
artTest <- filter(resultsAll, stage == "numART")$value

artTest[8] <- artEstimates$fitlog[12]

artDiffs[[2]] <- filter(resultsAll, stage == "pldhiv")$value -
  artTest

# Second test - replace all AHOD values with fitted values
artTest <- filter(resultsAll, stage == "numART")$value
artTest[1:8] <- artEstimates$fitlog[5:12]

artDiffs[[3]] <- filter(resultsAll, stage == "pldhiv")$value -
  artTest

# Third test - Use both fitted pldhiv and numART over 2004-2016
artDiffs[[4]] <- fitted(trendModels[["pldhiv"]]) -
  fitted(trendModels[["numART"]])

# Loop across stages and save plots 
segTestPlot <- list()
testCaption <- c("Replace 2011 on ART value 
  from AHOD with fitted estimate",
  "Replace AHOD estimates with 
  fitted estimates 2004-2012",
  "Use difference between fitted 
  PLDHIV and fitted on ART")

for (ii in 1:4) {
  # Need to use local to prevent scope issues with predicted values
  local({
    ii <- ii
    artTrial <- data.frame(value = artDiffs[[ii]], year = 2004:resultsYear)
    
    # Regenerate original model in case of scope issues
    artmodel <- glm(round(value) ~ year, data = artTrial, 
      family = "poisson")
    
    # Now run segmented to produce a segmented Poisson model. Varying the
    # initial guess of the breakpoint from 2007 to 2013 seems to produce 
    # no change in the fitted curve. 
    segModeltest <- segmented(artmodel, seg.Z = ~year, 
      psi = list(year = 2008))
    
    segTestData <- data.frame(year = artTrial$year, 
      segvalue = fitted(segModeltest))
    
    plotMax <- 6500
    segTestPlot[[ii]] <<- ggplot(data = artTrial, 
      aes(x = year, y = value)) + 
      geom_line(aes(color = "estimates")) + 
      geom_point(color = asrcols[2]) +
      geom_line(aes(y = fitted(artmodel),
        colour = "overall")) +
      geom_line(data = segTestData, aes(y = segvalue, 
        colour = "segment")) + 
      scale_x_continuous(breaks = seq(startYear,                        
        resultsYear, by = 3)) +
      scale_y_continuous(labels = comma) + 
      scale_colour_manual("", values = c(asrcols[2], "black", "blue"),
        limits = c("estimates", "overall", "segment"),
        labels = c("Estimates", "Overall model",
          "Segmented model")) +
      coord_cartesian(xlim = c(2004, resultsYear), ylim = c(0, plotMax)) + 
      ylab("Number diagnosed\nnot on ART") + xlab("Year") +  
      PlotOptions() + theme(legend.position = "bottom") + 
      geom_vline(xintercept = segModeltest$psi[2], linetype = "dashed",
        colour = "blue") + 
      geom_errorbarh(aes(y = 0.975 * plotMax,
        xmin = segCI(segModeltest$psi[2],
          segModeltest$psi[3])[1],
        xmax = segCI(segModeltest$psi[2],
          segModeltest$psi[3])[2]),
        colour = "blue",
        height = 0.025 * plotMax) +
      ggtitle(testCaption[ii]) +
      theme(plot.title = element_text(hjust = 0.5, size = 10))
    
    if (savePlots) {
      # Save the current plot
      ggsave(file.path(figFolder, paste0("HIVcascade_noART_Test", 
        toString(ii), "_", 
        toString(startYear), "-",
        toString(resultsYear),
        saveFormat)),
        plot = segTestPlot[[ii]], width = 12, height = 9, units = "cm")
    }
  })
}

# Save a combined plot comparison -----------------------------------------

# Figure caption
figs("trendSensitivity", "Trends in the number diagnosed not on ART over 2004-2016 under varying assumptions for the number on ART.The red discs show the best estimates for the cascade. The black lines show the estimates from the overall fitted Poisson models. The blue lines show the estimates from the segmented fitted Poisson models.")

legend <- get_legend(segTestPlot[[1]])

# Add the original plot to the combination plot
combinedTest <- grid.arrange(legend, 
  segTestPlot[[1]] + theme(legend.position="none",
    plot.title = element_text(hjust = 0.5, size = 10)) +
    ggtitle("Original\nestimates"),
  segTestPlot[[2]] + theme(legend.position="none"), 
  segTestPlot[[3]] + theme(legend.position="none"),
  segTestPlot[[4]] + theme(legend.position="none"), 
  ncol = 2, nrow = 3, 
  layout_matrix = rbind(c(1, 1), c(2, 3), c(4, 5)),
  widths = c(4, 4), heights = c(0.8, 3.1, 3.1))

stagesDiffsPlot4 <- ggdraw() +
  draw_plot(combinedTest, 0, 0, 1, 1) +
  draw_plot_label(c("A", "B", "C", "D"), c(0, 0.5, 0, 0.5),
    c(0.9, 0.9, 0.45, 0.45), size = 12)

if (savePlots) {
  ggsave(file.path(figFolder,
    paste("HIVcascade_noART_Segment_Test_",
      toString(startYear), "-",
      toString(resultsYear),
      saveFormat, sep = "")),
    plot = stagesDiffsPlot4, width = 18, height = 15, units = "cm")
}

```

# Non-linear model (DEPRECATED)

This section was used to explore the explore a non-linear least squares fitting 
of a non-linear model which allows for an increase and decrease in values over
time. Fitting the model allows us to report a rise and decay rate ratio and time 
where the max of peak value occurs. A disadvantage is that it is less 
interpretable. 

This fitting was applied to the cascade gaps data where a single change point 
original seemed to produce a good fit. However, this has now been superseeded by 
the multiple change point approach. The code has been kept here for prosperity 
and future use. 

The model is based on the following formula:
$$
f(t) = \frac {ake^{(g-d)t}} {(k-a)+ae^{gt}}.
$$
where $a$ is the initial value at $x = 0$, $g$ is the growth rate, $d$ is 
the decay rate, and $k$ is a threshold parameter which specifies the 
maximum value the grwoth can achieve (when $d = 0$). This function has been 
used previously in: 

> RT Gray, et al. Modeling the Impact of Potential Vaccines on Epidemics of 
> Sexually Transmitted Chlamydia Trachomatis Infection.
> JID 2009;199(11):1680-88. https://doi.org/10.1086/598983.

and

> AJ Shattock, et al. In the Interests of Time: Improving HIV Allocative 
> Efficiency Modelling via Optimal Time-Varying Allocations.
> JIAS 2016;19(1):20627. http://dx.doi.org/10.7448/IAS.19.1.20627.

The function is a combination of a logistic growth function and an 
exponential decay function. For $t \approx 0$, $f(t) \approx ae^{(g-d)t}$ and the 
growth is proportional to $e^{(g-d)t}$. Similarly, when x is large $f(t)$
is proportional to $e^{-dt}$. This means we can describe a rate ratio (RR) 
for the growth and decay of the function when $t$ represents time. With the 
the growth RR equal to $e^{g-d}$ and the decay RR $e^{-d}$. 

Though algebraic manipulation functional forms for the maximum (minimum)
value and the corresponding $t$ value $t_p$ can be obtained:
$$
t_p = \frac {1} {g} ln{\Big[ \frac {(g-d)(k-a)} {da}\Big]}.
$$

To fit the model to the annual data for `r startYear` to `r resultsYear` we 
use non-linear least squares via the `nls()` function with $t$ starting at 
zero and then being mapped to the years. Using `nls()` requires careful 
specification of the initial values which is done via guess and check and
visual inspection. From the resulting model we obtain the standard 
statistics though we can't generate an $R^2$ estimate by rights for a 
non-linear model. We assess goodness of fit using the BIC. To produce 
uncertainty in the model fits and results we sample from the 95% CIs for 
the parameters and simulate. From the simulations we obtain IQRs and 95% 
ranges for the fits and RRs. 

```{r Non-linear model}
# This chunk uses nls() to fit the model to the gaps as well as diagnoses
# and infections. 

# Load results from previous chunck 
# load(file.path(resultsFolder, cascadeName, "CascadeTrendData.Rda"))
# load(file.path(resultsFolder, cascadeName, "CascadeTrendModels.Rda"))

LoadLibrary(minpack.lm)

# Options
addSegment <- TRUE

# Set-up the functions we will use ----------------------------------------

# Main model
FitModel <- function(x, a, g, d, k) {
  return(k * a * exp((g-d) * x) / ((k - a) +
      a*exp(g * x)))
}

FitModel2 <- function(x, a, g, d) {
  return(10 * a * exp((g-d) * x) / ((10 - a) +
      a*exp(g * x)))
}

# Time to peak in model
TP <- function(a, g, d, k) {
  return((1/g) * log((g-d)*(k-a)/(d*a)))
}

fitIndicators <- c("undiagnosed", "noART", "unsuppressed", "infections",
  "diagnoses")

xseq <- years - years[1] # time points

yLabels[["diagnoses"]] <- "Annual diagnoses"
yLabels[["infections"]] <- "Annual new infections"

# Estimates for plots for each stage---------------------------------------
fitPlots <- list()
fitModels <- list()

ymax <- c("undiagnosed" = 3500, 
  "noART" = 6500, 
  "unsuppressed" = 4500,
  "diagnoses" = 1200,
  "infections" = 1200)

fitData <- trendData %>%
  select(year, stage, value)

# Add diagnoses and infections
fitDiagsData <- diagsData %>%
  select(-overseas) %>%
  mutate(stage = "diagnoses") %>%
  select(year, stage, value = diags)

fitInfectsData <- newInfects %>%
  select(year, infections) %>%
  mutate(stage = "infections") %>%
  select(year, stage, value = infections)

fitData <- bind_rows(fitData, fitDiagsData, fitInfectsData)

# Set-up initial values for fits ------------------------------------------

# Guess and check 
ydataTest <- filter(fitData, stage == "noART")$value
qplot(xseq, FitModel(xseq, 5800, 0.2, 0.135, 20000), 
  geom = "line", 
  ylim = c(0, NA), 
  ylab = "Value") + 
  geom_point(aes(y = ydataTest), colour = "black") +
  PlotOptions()

# Store initial values
initialParList <- list(
  "undiagnosed" = list(a= 2900, g = 0.2, d = 0.007, k = 3250),
  "noART" = list(a = 5800, g = 0.2, d = 0.133, k = 20000), 
  "unsuppressed" = list(a = 3000, g = 0.001, d = 0.05, k = 3000),
  "infections" = list(a = 900, g = 0.3, d = 0.01, k = 1100),
  "diagnoses" = list(a = 900, g = 0.43, d = 0.41, k = 1500000))

# Run fits
for (ii in fitIndicators) { 
  # Need to use local to prevent scope issues with predicted values
  local({
    print(ii)
    ii <- ii
    tempData <- filter(fitData, stage == ii)
    
    # Regenerate original Poisson model in case of scope issues
    pmodel <- glm(round(value) ~ year, data = tempData, 
      family = "poisson")
    
    # Now run nls() to produce a non-linear model. Use try in
    # case fit does not converge (which occurs for unsuppressed). 
    plotModel <- TRUE
    fitModel <- try(nlsLM(tempData$value ~ FitModel(xseq, a, g, d, k),
      start = initialParList[[ii]],
      control = nls.control(maxiter = 1000)))
    # weights = c(rep(0.2,8), rep(1, 9))))
    
    if ("try-error" %in% class(fitModel)) {
      print(paste("Unable to fit nls to",ii))
      fitModel <- pmodel #trendModels[[ii]]
      plotModel <- FALSE
    } 
    
    fitModel2 <- nlsLM(value ~ FitModel2(xseq, a, g, d), tempData, 
      start = initialParList[[ii]][1:3],
      control = nls.control(maxiter = 1000))
    
    
    fitModels[[ii]] <<- fitModel
    
    # Plot on top of trend plot
    fitModelData <- data.frame(year = tempData$year,
      fitvalue = fitted(fitModel))
    
    fitPlot <- ggplot(data = tempData,
      aes(x = year, y = value)) +
      geom_line(aes(color = "estimates")) +
      geom_point(color = asrcols[2]) +
      geom_line(aes(y = fitted(pmodel),
        colour = "overall")) +
      geom_line(data = fitModelData, aes(y = fitvalue,
        colour = "fit")) +
      scale_x_continuous(breaks = seq(startYear,
        resultsYear, by = 3)) +
      scale_y_continuous(labels = comma) +
      scale_colour_manual("", values = c(asrcols[2], "black", "blue"),
        limits = c("estimates", "overall", "fit"),
        labels = c("Estimates", "Overall model",
          "Fitted model")) +
      coord_cartesian(ylim = c(0, ymax[ii])) +
      ylab(yLabels[ii]) + xlab("Year") +
      PlotOptions() #+
    
    if (addSegment) {
      # Add Segment model plot for comparison
      segmentModel <- segModels[[ii]]
      
      segModelData <- data.frame(year = tempData$year,
        segvalue = fitted(segmentModel))
      
      fitPlot <- fitPlot +
        geom_line(data = segModelData, aes(y = segvalue,
          colour = "segment")) +
        scale_colour_manual("", values = c(asrcols[2], "black", 
          "dark green", "blue"),
          limits = c("estimates", "overall", "segment", "fit"),
          labels = c("Estimates", "Overall model",
            "Segmented model", "Fitted model")) +
        geom_text(x = 2010, y = 0.3 * ymax[ii],
          label = paste("Overall BIC:",
            toString(round(BIC(pmodel), digits = 4))), size = 3) +
        geom_text(x = 2010, y = 0.2 * ymax[ii],
          label = paste("Segmented BIC:",
            toString(round(BIC(segmentModel), digits = 4))), size = 3) +
        geom_text(x = 2010, y = 0.1 * ymax[ii],
          label = paste("Fitted BIC:",
            toString(round(BIC(fitModel), digits = 4))), size = 3)
      
      if (plotModel) {
        pars <- unname(coef(fitModel))
        fitPlot <- fitPlot +
          geom_vline(xintercept =  years[1] + TP(pars[1], pars[2], 
            pars[3], pars[4]), 
            linetype = "dashed",
            colour = "blue") +
          geom_vline(xintercept = segmentModel$psi[2], linetype = "dotted",
            colour = "dark green")
      }
      
    } else {
      fitPlot <- fitPlot +
        geom_text(x = 2010, y = 0.2 * ymax[ii],
          label = paste("Overall BIC:",
            toString(round(BIC(pmodel), digits = 4))), size = 3) +
        geom_text(x = 2010, y = 0.1 * ymax[ii],
          label = paste("Fitted BIC:",
            toString(round(BIC(fitModel), digits = 4))), size = 3)
      
      if (plotModel) {
        pars <- unname(coef(fitModel))
        fitPlot <- fitPlot +
          geom_vline(xintercept =  years[1] + TP(pars[1], pars[2], 
            pars[3], pars[4]), 
            linetype = "dashed",
            colour = "blue")
      }
    }
    
    fitPlots[[ii]] <<- fitPlot
    
    if (savePlots) {
      # Save the current plot
      ggsave(file.path(figFolder, paste0("HIVcascade-Trends-", ii,
        "-Fitted_",
        toString(startYear), "-",
        toString(resultsYear),
        saveFormat)),
        plot = fitPlots[[ii]], width = 7.5, height = 6, units = "cm")
    }
  })
}

# Figure caption
figs("fittedTrends", "")

# Create combined plot
legend <- get_legend(fitPlots[[1]])

stagesDiffsPlot3 <- ggdraw() +
  draw_plot(legend, 0, 0.93, 1, 0.07) + 
  draw_plot(fitPlots[[1]] + theme(legend.position="none"), 
    0, 0.62, 0.5, 0.31) +
  draw_plot(fitPlots[[2]] + theme(legend.position="none"),
    0, 0.32, 0.5, 0.31) +
  draw_plot(fitPlots[[3]] + theme(legend.position="none"),
    0, 0, 0.5, 0.31) +
  draw_plot(fitPlots[[4]] + theme(legend.position="none"),
    0.5, 0.62, 0.5, 0.31) +
  draw_plot(fitPlots[[5]] + theme(legend.position="none"),
    0.5, 0.31, 0.5, 0.31) +
  draw_plot_label(c("A", "B", "C", "D", "E"), c(0, 0, 0, 0.5, 0.5),
    c(0.93, 0.62, 0.31, 0.93, 0.62), size = 12)


# Save combined plot-------------------------------------------------------
if (savePlots) {
  if (addSegment) {
    plotFile <- "HIVcascade-Differences-Trends_Segment-Fitted_"
  } else {
    plotFile <- "HIVcascade-Differences-Trends_Fitted_"
  }
  
  ggsave(file.path(figFolder,
    paste(plotFile,
      toString(startYear), "-",
      toString(resultsYear),
      saveFormat, sep = "")),
    plot = stagesDiffsPlot3, width = 18, height = 25, units = "cm")
}
```

```{r Generate uncertainty}
# In this chunk we generate ranges for the nls fits to the gaps using 
# boot-strapping. This allows us to estimate the peak from the 
# boot-strapped parameters. 

library(tidymodels)

# Set-up indicator fitting 
set.seed(2653)
numBoots <- 10000

fitIndicators <- c("undiagnosed", "noART", "unsuppressed", "infections",
  "diagnoses")

modelFits <- list()
bootModelFits <- list()
bootstrapPlots <- list()

# Run fits
for (ii in fitIndicators) { 
  # Need to use local to prevent scope issues with predicted values
  local({
    print(ii)
    ii <- ii
    tempData <- filter(fitData, stage == ii) %>%
      mutate(xseq = seq(0,length(years)-1))
    
    modelFit <- tryCatch(nls(value ~ FitModel(xseq, a, g, d, k), tempData, 
      start = initialParList[[ii]],
      control = nls.control(maxiter = 1000)), 
      error = function(cond) {
        glm(round(value) ~ xseq, data = tempData, 
          family = "poisson")})
    
    tempboots <- bootstraps(tempData, times = numBoots, apparent = TRUE)
    
    tempFit_on_bootstrap <- function(split) {
      # Uses a tryCatch() call to return a model for each boot split given nls
      # won't work for some cascade gaps. 
      # Need to be careful with scope in tryCatch() and what it returns.
      modelFitSplit <- tryCatch(nls(value ~ FitModel(xseq, a, g, d, k),
        analysis(split), 
        start = initialParList[[ii]],
        control = nls.control(maxiter = 1000, warnOnly = TRUE, 
          minFactor = 1/4096)), 
        error = function(err) {
          print("Using glm")
          # nls doesn't work
          fitData <- analysis(split)
          errModelSplit <- glm(round(value) ~ xseq, data = analysis(split), 
            family = "poisson")
          # Return alternative model
          return(errModelSplit)})
      
      # Return final model for split
      return(modelFitSplit)
    }
    
    temp_boot_models <- tempboots %>% 
      mutate(model = map(splits, tempFit_on_bootstrap),
        coef_info = map(model, tidy),
        predictions = map(model, augment))
    
    # New data for smoothing
    new_preds <- tempData %>%
      do(., data.frame(xseq = seq(min(.$xseq), max(.$xseq), 
        length.out = 250), stringsAsFactors = FALSE))
    
    preds <- augment(modelFit, newdata = new_preds, 
      type.predict = "response")
    
    # Create smoother predictions for bootstrapped replicate
    preds <- temp_boot_models %>%
      mutate(new_predictions = map(model, augment, newdata = new_preds, 
        type.predict = "response")) %>%
      unnest(new_predictions) %>%
      # group by each value of xseq and get quantiles
      group_by(., xseq) %>%
      summarise(lwr_CI = quantile(.fitted, 0.025),
        lwr_IRQ = quantile(.fitted, 0.25),
        upr_IQR = quantile(.fitted, 0.75),
        upr_CI = quantile(.fitted, 0.975)) %>%
      ungroup() %>%
      merge(., preds, by = 'xseq')
    
    # Plot model fit and bootstrap ranges
    bootstrapPlot <- ggplot() + 
      geom_ribbon(data = preds, aes(x = xseq, ymin = lwr_CI, ymax = upr_CI,
        fill = "ci",  alpha = "ci")) +
      geom_ribbon(data = preds, aes(x = xseq, ymin = lwr_IRQ, ymax = upr_IQR, 
        fill = "iqr",  alpha = "iqr")) +
      geom_point(data = tempData, aes(xseq, value, colour = "data")) +
      geom_line(data = tempData, aes(xseq, value), colour = asrcols[2]) +
      geom_line(data = preds, aes(x = xseq, y = .fitted, colour = "fit")) +
      ylab(yLabels[ii]) +
      xlab('Year') +
      scale_colour_manual(NULL, values = c(asrcols[2], "black"),
        limits = c("data", "fit"),
        labels = c("Estimates", "Fitted values")) +
      scale_alpha_manual(NULL, values = c(0.4, 0.1),
        limits = c("iqr", "ci"),
        labels = c("Fitted IQR", "Fitted 95% CI")) +
      scale_fill_manual(NULL, values = c("black", "black"),
        limits = c("iqr", "ci"),
        labels = c("Fitted IQR", "Fitted 95% CI")) +
      scale_x_continuous(breaks = seq(0, length(years)-1, by = 3), 
        labels = seq(startYear, resultsYear, by = 3)) +
      scale_y_continuous(labels = comma) +
      expand_limits(y = 0) +
      PlotOptions() + theme(legend.spacing = unit(0, "cm"),
        legend.margin = margin(0, 0, 0, 0, "cm")) +
      guides(colour = guide_legend(order = 1),
        alpha = guide_legend(order = 2),
        fill = FALSE)
    
    modelFits[[ii]] <<- modelFit
    bootModelFits[[ii]] <<- temp_boot_models
    bootstrapPlots[[ii]] <<- bootstrapPlot
    
    if (savePlots) {
      # Save the current plot
      ggsave(file.path(figFolder, paste0("HIVcascade-Trends-", ii,
        "-Bootstrap_Fit_",
        toString(startYear), "-",
        toString(resultsYear),
        saveFormat)),
        plot = bootstrapPlots[[ii]] + theme(legend.position = "none"), 
        width = 7.5, height = 6, units = "cm")
    }
  })
}

# Figure caption
figs("bootTrends", "")

# Create combined plot
legend <- get_legend(bootstrapPlots[[1]])

combinedBootsPlot <- ggdraw() +
  draw_plot(legend, 0, 0.93, 1, 0.07) + 
  draw_plot(bootstrapPlots[[1]] + theme(legend.position="none"), 
    0, 0.62, 0.5, 0.31) +
  draw_plot(bootstrapPlots[[2]] + theme(legend.position="none"),
    0, 0.32, 0.5, 0.31) +
  draw_plot(bootstrapPlots[[3]] + theme(legend.position="none"),
    0, 0, 0.5, 0.31) +
  draw_plot(bootstrapPlots[[4]] + theme(legend.position="none"),
    0.5, 0.62, 0.5, 0.31) +
  draw_plot(bootstrapPlots[[5]] + theme(legend.position="none"),
    0.5, 0.31, 0.5, 0.31) +
  draw_plot_label(c("A", "B", "C", "D", "E"), c(0, 0, 0, 0.5, 0.5),
    c(0.93, 0.62, 0.31, 0.93, 0.62), size = 12)

# Save combined plot-------------------------------------------------------
if (savePlots) {
  plotFile <- "HIVcascade-Differences-Trends-Bootstrap_Fitted"
  
  ggsave(file.path(figFolder,
    paste0(plotFile, startYear, "-", resultsYear, saveFormat)),
    plot = combinedBootsPlot, width = 18, height = 25, units = "cm")
}

# set.seed(NULL)

```

```{r Non-linear stats}
# In this chuck we save the stats for the fitted and bootstrapped nls 
# results

# First save results so we can load later if necessay
# save(numBoots, fitIndicators, fitModels, fitPlots, modelFits, bootModelFits,
#   bootstrapPlots,
#   file = file.path(figFolder, paste0("HIV_Cascade_nls_trends_", 
#     startYear, "-", resultsYear, ".Rda")))
load(file.path(figFolder, paste0("HIV_Cascade_nls_trends_",
  startYear, "-", resultsYear, ".Rda")))

fitIndicators <- c("undiagnosed", "noART", "unsuppressed", "infections",
  "diagnoses")

# Fitted estimates
numRows <- length(fitIndicators)*5*2
nlsStats <- tibble(
  indicator = character(numRows),
  fitting = character(numRows),
  parameter = character(numRows),
  estimate = numeric(numRows),
  lower = numeric(numRows),
  upper = numeric(numRows))

for (ii in 1:length(fitIndicators)) {
  
  indicator <- fitIndicators[[ii]]
  print(indicator)
  pars <- unname(coef(fitModels[[ii]]))
  confIntervals <- tryCatch(confint(fitModels[[ii]]),
    error = function (err) {
      # Doesn't converge for diagnoses for some reason
      return(matrix(0, nrow = 4, ncol = 2))})
  
  if (indicator == "unsuppressed") {
    peak <- NA
    pars <- c(pars[1], NA, pars[2], NA)
    temp <- matrix(0, nrow= 4, ncol = 2)
    temp[c(1,3),] <- confIntervals
    confIntervals <- temp
  } else { 
    peak <- years[1] + TP(pars[1], pars[2], pars[3], pars[4])
  }
  
  indices <- (5*(ii-1)+1):(5*ii)
  
  nlsStats$indicator[indices] <- rep(indicator,5)
  nlsStats$fitting[indices] <- rep("fit",5)
  nlsStats$parameter[indices] <- c("a", "g", "d", "k", "TP")
  nlsStats$estimate[indices] <- c(pars, peak)
  nlsStats$lower[indices] <- c(confIntervals[,1], 0)
  nlsStats$upper[indices] <- c(confIntervals[,2], 0)
}

boot_coefs <- bootModelFits[[1]]%>%
  unnest(coef_info)
mean(filter(boot_coefs, term == "g")$estimate)


# percentile_intervals <- int_pctl(temp_boot_models, coef_info)
# percentile_intervals

# ggplot(boot_coefs, aes(estimate)) +
#   geom_histogram(bins = 30) +
#   facet_wrap( ~ term, scales = "free") +
#   geom_vline(aes(xintercept = .lower), 
#     data = percentile_intervals, col = "blue") +
#   geom_vline(aes(xintercept = .upper), 
#     data = percentile_intervals, col = "blue")
# 
# boot_aug <- boot_models_test %>% 
#   sample_n(200) %>% 
#   unnest(predictions)
# 
# ggplot(boot_aug, aes(xseq, value)) +
#   geom_line(aes(y = .fitted, group = id), alpha = .2, col = "blue") +
#   geom_point()

```



